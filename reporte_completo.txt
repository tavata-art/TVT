===== ./site_settings/views.py =====
from django.shortcuts import render

# Create your views here.
===== ./site_settings/translation.py =====
from modeltranslation.translator import register, TranslationOptions
from .models import SiteConfiguration

@register(SiteConfiguration)
class SiteConfigurationTranslationOptions(TranslationOptions):
    fields = ('site_slogan',)===== ./site_settings/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='SiteConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('blog_items_per_page', models.PositiveIntegerField(default=9, help_text='Number of posts to show on the main blog page and on category pages.', verbose_name='Items per Page in Blog/Category lists')),
                ('search_pages_per_page', models.PositiveIntegerField(default=5, verbose_name='Pages per Page in Search Results')),
                ('search_posts_per_page', models.PositiveIntegerField(default=5, verbose_name='Posts per Page in Search Results')),
                ('search_results_per_page', models.PositiveIntegerField(default=5, help_text='Number of items to show per section (Pages/Posts) on the search results page.', verbose_name='Results per Page in Search')),
                ('search_importance_limit', models.PositiveIntegerField(default=3, help_text='How many top-priority pages to display before regular search results.', verbose_name="Number of 'Important' Pages to show first in search")),
                ('comment_indentation_pixels', models.PositiveIntegerField(default=20, help_text='Controls the visual indentation for nested comments in the admin.', verbose_name='Comment Indentation (in pixels)')),
                ('auto_approve_comments', models.BooleanField(default=False, help_text='If checked, new comments will be published immediately without moderation.', verbose_name='Auto-approve comments')),
                ('menu_cache_timeout', models.PositiveIntegerField(default=3600, help_text='How long the site menus should be stored in cache. Set to 0 to disable menu caching (not recommended).', verbose_name='Menu Cache Timeout (in seconds)')),
                ('site_logo', models.ImageField(blank=True, help_text='The main logo displayed in the top bar.', null=True, upload_to='site_branding/', verbose_name='Site Logo')),
                ('site_slogan', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, verbose_name='Site Slogan')),
                ('site_slogan_es', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, null=True, verbose_name='Site Slogan')),
                ('site_slogan_en', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, null=True, verbose_name='Site Slogan')),
                ('site_slogan_ca', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, null=True, verbose_name='Site Slogan')),
                ('trusted_commenter_threshold', models.PositiveIntegerField(default=10, help_text='The number of approved comments a user needs to post before their future comments are auto-approved.', verbose_name='Trusted Commenter Threshold')),
                ('top_bar_banner_image', models.ImageField(blank=True, help_text='An optional banner image displayed in the top bar.', null=True, upload_to='site_branding/banners/', verbose_name='Top Bar Banner Image')),
                ('top_bar_banner_link', models.URLField(blank=True, help_text='The URL the banner image will link to.', max_length=255, verbose_name='Top Bar Banner Link')),
            ],
            options={
                'verbose_name': 'Site Configuration',
                'verbose_name_plural': 'Site Configuration',
            },
        ),
    ]
===== ./site_settings/migrations/0002_siteconfiguration_category_tree_cache_timeout.py =====
# Generated by Django 5.2.3 on 2025-06-19 20:53

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('site_settings', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='siteconfiguration',
            name='category_tree_cache_timeout',
            field=models.PositiveIntegerField(default=43200, help_text='How long the full category tree should be stored in cache. High values are recommended.', verbose_name='Category Tree Cache Timeout (in seconds)'),
        ),
    ]
===== ./site_settings/migrations/0003_siteconfiguration_gallery_items_per_page.py =====
# Generated by Django 5.2.3 on 2025-06-21 10:47

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('site_settings', '0002_siteconfiguration_category_tree_cache_timeout'),
    ]

    operations = [
        migrations.AddField(
            model_name='siteconfiguration',
            name='gallery_items_per_page',
            field=models.PositiveIntegerField(default=9, help_text='Number of images to show on the image gallery page.', verbose_name='Items per Page in Gallery'),
        ),
    ]
===== ./site_settings/migrations/__init__.py =====
===== ./site_settings/migrations/0004_siteconfiguration_user_profile_items_per_page.py =====
# Generated by Django 5.2.3 on 2025-06-21 13:20

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('site_settings', '0003_siteconfiguration_gallery_items_per_page'),
    ]

    operations = [
        migrations.AddField(
            model_name='siteconfiguration',
            name='user_profile_items_per_page',
            field=models.PositiveIntegerField(default=5, help_text="Number of posts/comments to show per page on a user's public profile.", verbose_name='Items per Page on Public Profile'),
        ),
    ]
===== ./site_settings/models.py =====
from django.db import models
from django.utils.translation import gettext_lazy as _, gettext
from solo.models import SingletonModel

class SiteConfiguration(SingletonModel):
    """
    Singleton model to store site-wide configuration settings.
    Only one instance of this model will ever exist.
    """

    # --- Pagination Settings ---
    blog_items_per_page = models.PositiveIntegerField(
        default=9, 
        verbose_name=_("Items per Page in Blog/Category lists"),
        help_text=_("Number of posts to show on the main blog page and on category pages.")
    )
    search_pages_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Pages per Page in Search Results")
    )
    search_posts_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Posts per Page in Search Results")
    )
    search_results_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Results per Page in Search"),
        help_text=_("Number of items to show per section (Pages/Posts) on the search results page.")
    )
    # --- Search Settings ---
    search_importance_limit = models.PositiveIntegerField(
        default=3,
        verbose_name=_("Number of 'Important' Pages to show first in search"),
        help_text=_("How many top-priority pages to display before regular search results.")
    )

    # --- Admin Display Settings ---
    comment_indentation_pixels = models.PositiveIntegerField(
        default=20,
        verbose_name=_("Comment Indentation (in pixels)"),
        help_text=_("Controls the visual indentation for nested comments in the admin.")
    )

    # --- Comment Moderation Settings ---
    auto_approve_comments = models.BooleanField(
        default=False, 
        verbose_name=_("Auto-approve comments"),
        help_text=_("If checked, new comments will be published immediately without moderation.")
    )
        # --- Caching Settings ---
    menu_cache_timeout = models.PositiveIntegerField(
        default=3600, # Default to 1 hour (3600 seconds)
        verbose_name=_("Menu Cache Timeout (in seconds)"),
        help_text=_("How long the site menus should be stored in cache. Set to 0 to disable menu caching (not recommended).")
    )
    # --- Branding Settings ---
    site_logo = models.ImageField(
        upload_to='site_branding/',
        blank=True, null=True,
        verbose_name=_("Site Logo"),
        help_text=_("The main logo displayed in the top bar.")
    )
    site_slogan = models.CharField(
        max_length=150, 
        blank=True, 
        verbose_name=_("Site Slogan"),
        help_text=_("A short tagline displayed next to the logo.")
    )
    trusted_commenter_threshold = models.PositiveIntegerField(
        default=10,
        verbose_name=_("Trusted Commenter Threshold"),
        help_text=_("The number of approved comments a user needs to post before their future comments are auto-approved.")
    )
    category_tree_cache_timeout = models.PositiveIntegerField(
        default=43200, # Default to 12 hours
        verbose_name=_("Category Tree Cache Timeout (in seconds)"),
        help_text=_("How long the full category tree should be stored in cache. High values are recommended.")
    )
    gallery_items_per_page = models.PositiveIntegerField(
        default=9,
        verbose_name=_("Items per Page in Gallery"),
        help_text=_("Number of images to show on the image gallery page.")
    )
    user_profile_items_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Items per Page on Public Profile"),
        help_text=_("Number of posts/comments to show per page on a user's public profile.")
    )
    # --- Top Bar Banner/Ad Settings ---
    top_bar_banner_image = models.ImageField(
        upload_to='site_branding/banners/',
        blank=True, null=True,
        verbose_name=_("Top Bar Banner Image"),
        help_text=_("An optional banner image displayed in the top bar.")
    )
    top_bar_banner_link = models.URLField(
        max_length=255, 
        blank=True, 
        verbose_name=_("Top Bar Banner Link"),
        help_text=_("The URL the banner image will link to.")
    )

    class Meta:
        verbose_name = _("Site Configuration")
        verbose_name_plural = _("Site Configuration")

    def __str__(self):
        return gettext("Site Configuration")===== ./site_settings/apps.py =====
from django.apps import AppConfig


class SiteSettingsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'site_settings'
===== ./site_settings/admin.py =====
# File: site_settings/admin.py
from django.contrib import admin
from solo.admin import SingletonModelAdmin
from modeltranslation.admin import TabbedTranslationAdmin
from .models import SiteConfiguration

@admin.register(SiteConfiguration)
class SiteConfigurationAdmin(SingletonModelAdmin, TabbedTranslationAdmin):
    """
    Admin for the SiteConfiguration singleton model.
    We keep it simple and let solo and modeltranslation handle the rendering.
    """
    # No 'fields' or 'fieldsets'. Let the libraries do their job.
    pass===== ./site_settings/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./site_settings/templatetags/settings_tags.py =====
# File: site_settings/templatetags/settings_tags.py
from django import template
from site_settings.models import SiteConfiguration

register = template.Library()

@register.simple_tag
def get_site_config():
    """
    A simple template tag to fetch the single SiteConfiguration object.
    This allows easy access to global settings in templates.
    It uses caching for high performance.
    """
    # We can add caching here as we did with widgets.
    # For simplicity now, we get it directly.

    # .get() is safe because django-solo ensures there's only one.
    return SiteConfiguration.get_solo()===== ./site_settings/templatetags/__init__.py =====
===== ./site_settings/__init__.py =====
===== ./accounts/views.py =====
# File: accounts/views.py
import logging
import os
import uuid
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import get_user_model
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.conf import settings 
from django.contrib import messages
from django.contrib.auth import login
from django.contrib.auth.decorators import login_required
from django.utils.translation import gettext
from .forms import CustomUserCreationForm, UserUpdateForm, ProfileUpdateForm

# Import the models required for the public profile view
from .models import Profile # Model for user profiles
from blog.models import Post, Comment # Models for posts and comments

from site_settings.models import SiteConfiguration 

# Get a logger instance for this module.
logger = logging.getLogger(__name__)
User = get_user_model()

# --- SIGNUP VIEW ---
def signup_view(request):
    """ Handles new user registration. """
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            logger.info(f"New user account created: '{user.username}' (ID: {user.id})")
            login(request, user)
            messages.success(request, gettext("Welcome! Your account has been created successfully."))
            return redirect('home')
        else:
            logger.warning(f"Signup form failed validation. Errors: {form.errors.as_json()}")
    else:
        form = CustomUserCreationForm()
        
    return render(request, 'registration/signup.html', {'form': form})


@login_required 
def profile_edit_view(request):
    if request.method == 'POST':
        user_form = UserUpdateForm(request.POST, instance=request.user)
        profile_form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user.profile)

        if user_form.is_valid() and profile_form.is_valid():
            # Guardamos el formulario de usuario, que es simple.
            user_form.save()
            
            # --- LÓGICA FINAL Y EXPLÍCITA DE AVATAR ---
            profile = request.user.profile

            # Caso 1: El usuario subió una nueva imagen.
            if 'avatar' in request.FILES:
                uploaded_file = request.FILES['avatar']
                # Construimos el nuevo nombre de archivo
                extension = os.path.splitext(uploaded_file.name)[1]
                new_filename = f"avatars/{uuid.uuid4().hex}{extension}"
                
                # Si ya existe una imagen personalizada, la borramos para no dejar basura.
                if profile.avatar and os.path.exists(profile.avatar.path):
                    default_paths = [c[0] for c in profile.AvatarChoice.choices]
                    if profile.avatar.name not in default_paths:
                        os.remove(profile.avatar.path)
                
                # Guardamos el nuevo archivo con el nuevo nombre.
                profile.avatar.save(new_filename, uploaded_file)
                logger.info(f"User '{request.user.username}' uploaded new avatar, saved as {new_filename}")
            
            # Caso 2: El usuario marcó "Limpiar".
            elif profile_form.cleaned_data.get('avatar-clear'):
                chosen_default = profile_form.cleaned_data.get('default_avatar_choice')
                profile.avatar = chosen_default
                logger.info(f"User '{request.user.username}' cleared avatar, reverting to {chosen_default}")

            # Actualizamos los otros campos del perfil desde los datos validados del formulario
            profile.display_name = profile_form.cleaned_data['display_name']
            profile.bio = profile_form.cleaned_data['bio']
            profile.location = profile_form.cleaned_data['location']
            profile.website_url = profile_form.cleaned_data['website_url']
            
            # Si no se limpió el avatar, la elección por defecto también se guarda
            if not profile_form.cleaned_data.get('avatar-clear'):
                 profile.default_avatar_choice = profile_form.cleaned_data.get('default_avatar_choice')
            
            profile.save() # Guardamos todos los cambios en el objeto profile
            
            messages.success(request, gettext("Your profile has been updated successfully!"))
            return redirect('accounts:profile_edit')
            
        else:
            logger.warning("Profile update form failed validation.", extra={'errors': profile_form.errors.as_json()})

    else:
        user_form = UserUpdateForm(instance=request.user)
        profile_form = ProfileUpdateForm(instance=request.user.profile)

    context = {
        'user_form': user_form,
        'profile_form': profile_form
    }
    
    return render(request, 'registration/profile_edit.html', context)

def user_profile_public_view(request, username):
    """
    Displays public information for a given user, including their profile details
    and a paginated list of their public contributions (posts, comments).
    """
    try:
        # Get the user by username, or return a 404
        user_obj = get_object_or_404(User, username=username)
        # Ensure the user has an associated profile
        if not hasattr(user_obj, 'profile') or user_obj.profile is None:
            logger.warning(f"User '{username}' does not have an associated profile. Creating one.")
            # This should ideally not happen due to the signal, but as a failsafe
            profile = user_obj.profile = Profile.objects.create(user=user_obj)
        else:
            profile = user_obj.profile

        logger.info(f"Public profile view accessed for user: '{username}'.")

        # --- User's Blog Posts (Publicly visible) ---
        user_posts = Post.objects.filter(
            author=user_obj, 
            status='published'
        ).order_by('-published_date')

        # --- User's Comments (Approved and publicly visible) ---
        user_comments = Comment.objects.filter(
            user=user_obj, 
            is_approved=True
        ).order_by('-created_at')

        site_config = SiteConfiguration.get_solo()
        items_per_page = getattr(site_config, 'user_profile_items_per_page', 5) # Fallback to 5


        # Paginate Posts
        posts_paginator = Paginator(user_posts, items_per_page)
        posts_page_number = request.GET.get('posts_page', 1)
        paginated_user_posts = posts_paginator.get_page(posts_page_number)

        # Paginate Comments
        comments_paginator = Paginator(user_comments, items_per_page)
        comments_page_number = request.GET.get('comments_page', 1)
        paginated_user_comments = comments_paginator.get_page(comments_page_number)

        context = {
            'user_obj': user_obj, # The User object
            'profile': profile,   # The associated Profile object
            'user_posts': paginated_user_posts,
            'user_comments': paginated_user_comments,
        }
        return render(request, 'accounts/public_profile_view.html', context)

    except User.DoesNotExist:
        logger.warning(f"Public profile requested for non-existent user: '{username}'.")
        raise
    except Exception as e:
        logger.error(f"Error accessing public profile for user '{username}': {e}", exc_info=True)
        raise # Re-raise for Django to handle 500 error page

def user_directory_view(request):
    """
    Displays a paginated list of all active users in the system.
    """
    # 1. Get all active users, ordered by username.
    # You might want to filter out staff/superusers if you don't want them listed.
    all_users = User.objects.filter(
        is_active=True,
        profile__is_listed_publicly=True
    ).order_by('username')
    
    # 2. Get pagination settings.
    try:
        site_config = SiteConfiguration.get_solo()
        items_per_page = getattr(site_config, 'user_directory_items_per_page', 25)
    except SiteConfiguration.DoesNotExist:
        items_per_page = 25
        logger.warning("SiteConfiguration not found. Using default user directory items per page (25).")

    # 3. Apply pagination.
    paginator = Paginator(all_users, items_per_page)
    page_number = request.GET.get('page')

    try:
        users_on_page = paginator.get_page(page_number)
    except PageNotAnInteger:
        users_on_page = paginator.get_page(1)
    except EmptyPage:
        if paginator.num_pages > 0:
            users_on_page = paginator.get_page(paginator.num_pages)
        else:
            users_on_page = []

    logger.info(f"User directory view accessed. Showing page {getattr(users_on_page, 'number', 0)} of {getattr(users_on_page, 'paginator.num_pages', 0)} users.")

    context = {
        'users': users_on_page, # Pass the paginated user objects
    }
    return render(request, 'accounts/user_directory.html', context)===== ./accounts/urls.py =====
# accounts/urls.py
from django.urls import path
from . import views

app_name = 'accounts'

urlpatterns = [
    path('signup/', views.signup_view, name='signup'),
    path('profile/edit/', views.profile_edit_view, name='profile_edit'),
    path('profile/<str:username>/', views.user_profile_public_view, name='public_profile'),
    path('directory/', views.user_directory_view, name='user_directory'),
]===== ./accounts/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Profile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('display_name', models.CharField(blank=True, help_text='Your full name or a nickname, which will be shown publicly.', max_length=150, verbose_name='Display Name')),
                ('public_email', models.EmailField(blank=True, help_text="An email address you don't mind sharing publicly for contact.", max_length=254, verbose_name='Public Email')),
                ('website_url', models.URLField(blank=True, max_length=255, verbose_name='Website URL')),
                ('location', models.CharField(blank=True, max_length=100, verbose_name='Location')),
                ('bio', models.TextField(blank=True, verbose_name='Biography')),
                ('avatar', models.ImageField(default='images/avatars/default_private.png', upload_to='avatars/', verbose_name='Avatar')),
                ('default_avatar_choice', models.CharField(choices=[('images/avatars/default_private.png', "Don't specify"), ('images/avatars/default_female.png', 'Female'), ('images/avatars/default_male.png', 'Male'), ('images/avatars/default_nonbinary.png', 'Non-binary')], default='images/avatars/default_private.png', max_length=100, verbose_name='Default Avatar Preference')),
                ('is_trusted_commenter', models.BooleanField(default=False, help_text='If checked, comments are automatically approved.', verbose_name='Is a Trusted Commenter?')),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Profile',
                'verbose_name_plural': 'Profiles',
            },
        ),
    ]
===== ./accounts/migrations/0003_alter_profile_is_listed_publicly.py =====
# Generated by Django 5.2.3 on 2025-06-22 13:52

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0002_profile_is_listed_publicly'),
    ]

    operations = [
        migrations.AlterField(
            model_name='profile',
            name='is_listed_publicly',
            field=models.BooleanField(default=False, help_text='If checked, your profile will be visible in the public user directory.', verbose_name='List profile publicly?'),
        ),
    ]
===== ./accounts/migrations/0002_profile_is_listed_publicly.py =====
# Generated by Django 5.2.3 on 2025-06-22 08:34

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='profile',
            name='is_listed_publicly',
            field=models.BooleanField(default=True, help_text='If checked, your profile will be visible in the public user directory.', verbose_name='List profile publicly?'),
        ),
    ]
===== ./accounts/migrations/__init__.py =====
===== ./accounts/forms.py =====
# File: accounts/forms.py
import logging
from django import forms
from django.contrib.auth.models import User
from django.contrib.auth.forms import UserCreationForm
from django.utils.translation import gettext_lazy as _
from widgets.widgets import CustomClearableFileInput
from .models import Profile

logger = logging.getLogger(__name__)


# --- 1. Custom SIGNUP Form (for new user registration) ---
class CustomUserCreationForm(UserCreationForm):
    """
    A custom form for new user registration. It only handles User model fields.
    """
    class Meta(UserCreationForm.Meta):
        model = User
        # The 'fields' tuple should only contain fields from the User model.
        # 'password1' and 'password2' are handled automatically by UserCreationForm.
        fields = ("username",)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['password2'].help_text = None
        self.fields['username'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Choose a username')})
        self.fields['password1'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Enter password')})
        self.fields['password2'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Confirm password')})
        self.fields['username'].label = _('Username')
        self.fields['password1'].label = _('Password')
        self.fields['password2'].label = _('Confirm Password')


# --- 2. Custom User UPDATE Form (for editing basic User data) ---
class UserUpdateForm(forms.ModelForm):
    """
    A form for updating basic, non-sensitive user information.
    """
    email = forms.EmailField(
        required=True, 
        widget=forms.EmailInput(attrs={'class': 'form-control'})
    )

    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'email']
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['first_name'].label = _('First Name')
        self.fields['last_name'].label = _('Last Name')
        self.fields['email'].label = _('Contact Email')
        self.fields['first_name'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Your first name')})
        self.fields['last_name'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Your last name')})


# --- 3. Custom Profile UPDATE Form (for editing extended Profile data) ---
class ProfileUpdateForm(forms.ModelForm):
    """
    A form for updating the extended profile, using a custom widget for the avatar.
    """
    # We explicitly define the avatar field to force our custom widget.
    avatar = forms.ImageField(
        label=_("Profile Picture"),
        required=False,
        widget=CustomClearableFileInput() # Custom widget for file input
    )
    clear_avatar = forms.BooleanField(
        label=_("Use default avatar"),
        required=False,
        # Le damos una clase de Bootstrap para que se vea bien
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )
    class Meta:
        model = Profile
        fields = [
            'display_name', 
            'bio', 
            'location', 
            'website_url', 
            'avatar', 
            'default_avatar_choice',
            'is_listed_publicly'
        ]
        
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Apply Bootstrap classes to the rest of the fields.
        self.fields['display_name'].widget.attrs.update({'class': 'form-control'})
        self.fields['bio'].widget.attrs.update({'class': 'form-control', 'rows': 4})
        self.fields['location'].widget.attrs.update({'class': 'form-control'})
        self.fields['website_url'].widget.attrs.update({'class': 'form-control', 'placeholder': 'https://...'})
        self.fields['default_avatar_choice'].widget.attrs.update({'class': 'form-select'})

        logger.debug(f"ProfileUpdateForm initialized for instance: {self.instance}")
===== ./accounts/models.py =====
# accounts/models.py
from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils.translation import gettext_lazy as _
from django.templatetags.static import static 

class Profile(models.Model):
    """
    Extends Django's base User model to include additional user information,
    such as a display name, avatar, and bio.
    """
    
    # --- Avatar Choices Enumeration ---
    # This provides a user-friendly way to select a default avatar.
    class AvatarChoice(models.TextChoices):
        PRIVATE = 'images/avatars/default_private.png', _("Don't specify")
        FEMALE = 'images/avatars/default_female.png', _('Female')
        MALE = 'images/avatars/default_male.png', _('Male')
        NONBINARY = 'images/avatars/default_nonbinary.png', _('Non-binary')

    # --- Core Relationship ---
    # A One-to-One link to Django's built-in User model.
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")

    # --- Identity & Contact Fields ---
    display_name = models.CharField(
        max_length=150, 
        blank=True, 
        verbose_name=_("Display Name"),
        help_text=_("Your full name or a nickname, which will be shown publicly.")
    )
    public_email = models.EmailField(
        blank=True, 
        verbose_name=_("Public Email"),
        help_text=_("An email address you don't mind sharing publicly for contact.")
    )
    website_url = models.URLField(
        max_length=255, 
        blank=True, 
        verbose_name=_("Website URL")
    )

    # --- Profile Information Fields ---
    location = models.CharField(
        max_length=100, 
        blank=True, 
        verbose_name=_("Location")
    )
    bio = models.TextField(
        blank=True, 
        verbose_name=_("Biography")
    )
    
    # --- Avatar Fields ---
    avatar = models.ImageField(
        upload_to='avatars/', 
        default='images/avatars/default_private.png', 
        verbose_name=_("Avatar")
    )
    default_avatar_choice = models.CharField(
        max_length=100,
        choices=AvatarChoice.choices,
        default=AvatarChoice.PRIVATE,
        verbose_name=_("Default Avatar Preference")
    )
    is_trusted_commenter = models.BooleanField(
        default=False,
        verbose_name=_("Is a Trusted Commenter?"),
        help_text=_("If checked, comments are automatically approved.")
    )
    is_listed_publicly = models.BooleanField(
        default=False, # consider False for new registrations.
                       # We will make this configurable in the signup process.
        verbose_name=_("List profile publicly?"),
        help_text=_("If checked, your profile will be visible in the public user directory.")
    )

    class Meta:
        verbose_name = _("Profile")
        verbose_name_plural = _("Profiles")

    # accounts/models.py
    def get_avatar_url(self):
        # Si el usuario ha subido un archivo, su nombre NO será una de las rutas por defecto.
        default_paths = [c[0] for c in self.AvatarChoice.choices]
        if self.avatar and self.avatar.name not in default_paths:
            return self.avatar.url

        # Si no, mostramos el avatar por defecto que el usuario haya elegido.
        return static(self.default_avatar_choice)
        
    def __str__(self):
        return f"{self.user.username}'s Profile"

    def get_display_name(self):
        """
        Returns the user's preferred display name, with fallbacks.
        Order of preference: Profile's display_name -> User's full_name -> User's username.
        """
        return self.display_name or self.user.get_full_name() or self.user.username


# --- Django Signal to Automate Profile Creation ---
@receiver(post_save, sender=User)
def create_or_update_user_profile(sender, instance, created, **kwargs):
    """
    Signal to automatically create a Profile when a new User is created.
    """
    if created:
        # Simply create the profile. Django will handle the default avatar.
        Profile.objects.create(user=instance)

    # This part ensures that if you save a User, its related Profile
    # is also saved, which can be useful for other signals.
    if hasattr(instance, 'profile'):
        instance.profile.save()===== ./accounts/apps.py =====
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'
===== ./accounts/admin.py =====
# accounts/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Profile

# Define an inline admin descriptor for Profile model
# which acts a bit like a singleton
class ProfileInline(admin.StackedInline):
    model = Profile
    can_delete = False
    verbose_name_plural = 'profile'

# Define a new User admin
class UserAdmin(BaseUserAdmin):
    inlines = (ProfileInline,)

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)===== ./accounts/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./accounts/templates/accounts/public_profile_view.html =====
<!-- File: accounts/templates/accounts/public_profile_view.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load static %}
{% load humanize %} {# For ordinal dates/timesince #}

{% block title %}{{ profile.get_display_name }}'s Profile{% endblock %}

{% block content %}
<div class="container my-5">
    <div class="row justify-content-center">
        <div class="col-lg-10">

            {# --- PROFILE HEADER --- #}
            <div class="d-flex align-items-center mb-5 p-4 bg-light rounded shadow-sm">
                <img src="{{ profile.get_avatar_url }}" 
                     alt="{{ profile.get_display_name }}'s Avatar"
                     class="img-fluid rounded-circle me-4" 
                     style="width: 120px; height: 120px; object-fit: cover;">
                
                <div>
                    <h1 class="display-5 mb-0">{{ profile.get_display_name }}</h1>
                    <p class="lead text-muted">{{ user_obj.username }}</p>
                    {% if profile.location %}<p><i class="fas fa-map-marker-alt text-muted me-2"></i>{{ profile.location }}</p>{% endif %}
                    {% if profile.website_url %}<p><i class="fas fa-link text-muted me-2"></i><a href="{{ profile.website_url }}" target="_blank" rel="noopener noreferrer">{{ profile.website_url }}</a></p>{% endif %}
                    {% if profile.public_email %}<p><i class="fas fa-envelope text-muted me-2"></i><a href="mailto:{{ profile.public_email }}">{{ profile.public_email }}</a></p>{% endif %}
                </div>
            </div>

            {# --- BIOGRAPHY --- #}
            {% if profile.bio %}
                <div class="card shadow-sm mb-5 border-0">
                    <div class="card-body">
                        <h4 class="card-title">{% translate "About Me" %}</h4>
                        <p class="card-text">{{ profile.bio|linebreaksbr }}</p>
                    </div>
                </div>
            {% endif %}

            {# --- USER'S BLOG POSTS --- #}
            <div class="mb-5">
                <h3 class="mb-4">{% translate "Posts by" %} {{ profile.get_display_name }}</h3>
                <div class="list-group list-group-flush">
                    {% for post in user_posts %}
                        <a href="{{ post.get_absolute_url }}" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center">
                            {{ post.title }}
                            <small class="text-muted">{% translate "Published on" %} {{ post.published_date|date:"DATE_FORMAT" }}</small>
                        </a>
                    {% empty %}
                        <p>{% translate "This user has not published any blog posts yet." %}</p>
                    {% endfor %}
                </div>
                {% include 'core/partials/_pagination.html' with page_obj=user_posts param_name='posts_page' %}
            </div>

            {# --- USER'S COMMENTS --- #}
            <div>
                <h3 class="mb-4">{% translate "Comments by" %} {{ profile.get_display_name }}</h3>
                <div class="list-group list-group-flush">
                    {% for comment in user_comments %}
                        <div class="list-group-item d-flex align-items-center">
                            <div>
                                <small class="text-muted me-2">{{ comment.created_at|timesince }} {% translate "ago" %}:</small>
                                <p class="mb-0">{{ comment.content|truncatechars:100 }}</p>
                                <a href="{{ comment.post.get_absolute_url }}#comment-{{ comment.id }}" class="btn btn-sm btn-link">{% translate "View in context" %}</a>
                            </div>
                        </div>
                    {% empty %}
                        <p>{% translate "This user has not posted any comments yet." %}</p>
                    {% endfor %}
                </div>
                {% include 'core/partials/_pagination.html' with page_obj=user_comments param_name='comments_page' %}
            </div>

        </div>
    </div>
</div>
{% endblock %}===== ./accounts/templates/accounts/user_directory.html =====
<!-- File: accounts/templates/accounts/user_directory.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load static %}

{% block title %}{% translate "User Directory" %}{% endblock %}

{% block content %}
<div class="container my-5">
    <h1 class="mb-4 text-center">{% translate "Our Community Members" %}</h1>
    <p class="lead text-muted text-center mb-5">{% translate "Explore profiles of users who are part of our community." %}</p>

    <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 g-4">
        {% for user_item in users %} {# 'users' is the paginated object `Page` #}
            <div class="col">
                <div class="card h-100 shadow-sm border-0 text-center">
                    <div class="card-body">
                        <a href="{% url 'accounts:public_profile' username=user_item.username %}">
                            <img src="{{ user_item.profile.get_avatar_url }}" 
                                 alt="{{ user_item.profile.get_display_name }}'s Avatar"
                                 class="rounded-circle mb-3 border border-3 border-primary" 
                                 style="width: 80px; height: 80px; object-fit: cover;">
                        </a>
                        <h5 class="card-title mb-1">
                            <a href="{% url 'accounts:public_profile' username=user_item.username %}" class="text-decoration-none">
                                {{ user_item.profile.get_display_name }}
                            </a>
                        </h5>
                        <p class="card-text text-muted">@{{ user_item.username }}</p>
                        {% if user_item.profile.location %}
                            <p class="card-text"><small class="text-muted"><i class="fas fa-map-marker-alt"></i> {{ user_item.profile.location }}</small></p>
                        {% endif %}
                    </div>
                </div>
            </div>
        {% empty %}
            <div class="col-12">
                <p class="text-center">{% translate "No users found in the directory." %}</p>
            </div>
        {% endfor %}
    </div>

    {# --- PAGINATION --- #}
    {% include 'core/partials/_pagination.html' with page_obj=users %}
    {# --- END PAGINATION --- #}

</div>
{% endblock %}===== ./accounts/templates/registration/password_reset_form.html =====
<!-- File: accounts/templates/registration/password_reset_form.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Reset Password" %}{% endblock %}

{% block content %}
<div class="row justify-content-center mt-5">
    <div class="col-md-6">
        <div class="card shadow-sm border-0">
            <div class="card-body">
                <h2 class="card-title text-center mb-4">{% translate "Reset Your Password" %}</h2>
                <p class="text-center text-muted">{% translate "Enter your email address below, and we'll send you instructions to set a new one." %}</p>
                <form method="post">
                    {% csrf_token %}
                    {% for field in form %}
                        <div class="mb-3">
                            <label for="{{ field.id_for_label }}" class="form-label">{{ field.label }}</label>
                            {{ field }}
                            {% if field.errors %}<div class="invalid-feedback d-block">{{ field.errors|striptags }}</div>{% endif %}
                        </div>
                    {% endfor %}
                    <div class="d-grid">
                        <button type="submit" class="btn btn-primary btn-lg">{% translate "Send Reset Link" %}</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}===== ./accounts/templates/registration/password_reset_done.html =====
<!-- File: accounts/templates/registration/password_reset_done.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Password Reset Sent" %}{% endblock %}

{% block content %}
<div class="row justify-content-center mt-5">
    <div class="col-md-6 text-center">
        <div class="card shadow-sm border-0">
            <div class="card-body py-5">
                <i class="fas fa-envelope-open-text fa-5x text-success mb-4"></i>
                <h2 class="card-title mb-4">{% translate "Password Reset Email Sent" %}</h2>
                <p>{% translate "We've emailed you instructions for setting your password. You should receive them shortly." %}</p>
                <p>{% translate "If you don't receive an email, please make sure you've entered the address you registered with, and check your spam folder." %}</p>
                <p class="mt-4"><a href="{% url 'login' %}">{% translate "Return to Login" %}</a></p>
            </div>
        </div>
    </div>
</div>
{% endblock %}===== ./accounts/templates/registration/profile_edit.html =====
<!-- File: accounts/templates/registration/profile_edit.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Edit Profile" %}{% endblock %}

{% block content %}
<div class="container my-5">
    <div class="row justify-content-center">
        <div class="col-lg-8">
            
            <h1 class="display-5 mb-4">{% translate "Edit Your Profile" %}</h1>

            <form method="post" enctype="multipart/form-data">
                {% csrf_token %}

                <!-- USER DETAILS CARD -->
                <div class="card shadow-sm mb-4">
                    <div class="card-header">
                        <h5 class="mb-0">{% translate "User Information" %}</h5>
                    </div>
                    <div class="card-body">
                        {% for field in user_form %}
                            <div class="mb-3">
                                <label for="{{ field.id_for_label }}" class="form-label">{{ field.label }}</label>
                                {{ field }}
                                {% if field.help_text %}<div class="form-text">{{ field.help_text|safe }}</div>{% endif %}
                                {% if field.errors %}<div class="invalid-feedback d-block">{{ field.errors|striptags }}</div>{% endif %}
                            </div>
                        {% endfor %}
                    </div>
                </div>

                <!-- PROFILE DETAILS CARD -->
                <div class="card shadow-sm">
                    <div class="card-header">
                        <h5 class="mb-0">{% translate "Profile Details" %}</h5>
                    </div>
                    <div class="card-body">
                        {# --- Render each field explicitly for full control --- #}

                        {# Display Name #}
                        <div class="mb-3">
                            <label for="{{ profile_form.display_name.id_for_label }}" class="form-label">{{ profile_form.display_name.label }}</label>
                            {{ profile_form.display_name }}
                            {% if profile_form.display_name.help_text %}<div class="form-text">{{ profile_form.display_name.help_text|safe }}</div>{% endif %}
                            {% if profile_form.display_name.errors %}<div class="invalid-feedback d-block">{{ profile_form.display_name.errors|striptags }}</div>{% endif %}
                        </div>

                        {# Bio #}
                        <div class="mb-3">
                            <label for="{{ profile_form.bio.id_for_label }}" class="form-label">{{ profile_form.bio.label }}</label>
                            {{ profile_form.bio }}
                            {% if profile_form.bio.help_text %}<div class="form-text">{{ profile_form.bio.help_text|safe }}</div>{% endif %}
                            {% if profile_form.bio.errors %}<div class="invalid-feedback d-block">{{ profile_form.bio.errors|striptags }}</div>{% endif %}
                        </div>

                        {# Location #}
                        <div class="mb-3">
                            <label for="{{ profile_form.location.id_for_label }}" class="form-label">{{ profile_form.location.label }}</label>
                            {{ profile_form.location }}
                            {% if profile_form.location.help_text %}<div class="form-text">{{ profile_form.location.help_text|safe }}</div>{% endif %}
                            {% if profile_form.location.errors %}<div class="invalid-feedback d-block">{{ profile_form.location.errors|striptags }}</div>{% endif %}
                        </div>

                        {# Website URL #}
                        <div class="mb-3">
                            <label for="{{ profile_form.website_url.id_for_label }}" class="form-label">{{ profile_form.website_url.label }}</label>
                            {{ profile_form.website_url }}
                            {% if profile_form.website_url.help_text %}<div class="form-text">{{ profile_form.website_url.help_text|safe }}</div>{% endif %}
                            {% if profile_form.website_url.errors %}<div class="invalid-feedback d-block">{{ profile_form.website_url.errors|striptags }}</div>{% endif %}
                        </div>

                        {# --- AVATAR FIELD SECTION --- #}
                        <div class="mb-3">
                            <label for="{{ profile_form.avatar.id_for_label }}" class="form-label">{{ profile_form.avatar.label }}</label>
                            
                            {# Preview of current avatar #}
                            <div class="mb-2">
                                <img src="{{ profile_form.instance.get_avatar_url }}" 
                                    alt="{% translate 'Current Avatar' %}"
                                    class="img-thumbnail" 
                                    style="max-width: 150px; height: auto;">
                            </div>
                            
                            {# File input for new avatar #}
                            {{ profile_form.avatar }} 
                            {% if profile_form.avatar.help_text %}<div class="form-text">{{ profile_form.avatar.help_text|safe }}</div>{% endif %}
                            {% if profile_form.avatar.errors %}<div class="invalid-feedback d-block">{{ profile_form.avatar.errors|striptags }}</div>{% endif %}
                        </div>

                        {# --- DEFAULT AVATAR CHOICE AND CLEAR CHECKBOX --- #}
                        {# These two fields are handled together for clear UX #}
                        {% if profile_form.default_avatar_choice %} {# Check if the field exists (it should, always) #}
                            <div class="mb-3">
                                <label for="{{ profile_form.default_avatar_choice.id_for_label }}" class="form-label">{{ profile_form.default_avatar_choice.label }}</label>
                                {{ profile_form.default_avatar_choice }}
                                {% if profile_form.default_avatar_choice.help_text %}<div class="form-text">{{ profile_form.default_avatar_choice.help_text|safe }}</div>{% endif %}
                                {% if profile_form.default_avatar_choice.errors %}<div class="invalid-feedback d-block">{{ profile_form.default_avatar_choice.errors|striptags }}</div>{% endif %}
                            </div>
                        {% endif %}

                        {% if profile_form.clear_avatar %} {# Check if the field exists (it should, always) #}
                            <div class="mb-3 form-check"> {# Use form-check for checkboxes #}
                                {{ profile_form.clear_avatar }} {# Renders the checkbox input #}
                                <label class="form-check-label" for="{{ profile_form.clear_avatar.id_for_label }}">
                                    {{ profile_form.clear_avatar.label }}
                                </label>
                                {% if profile_form.clear_avatar.help_text %}<div class="form-text">{{ profile_form.clear_avatar.help_text|safe }}</div>{% endif %}
                                {% if profile_form.clear_avatar.errors %}<div class="invalid-feedback d-block">{{ profile_form.clear_avatar.errors|striptags }}</div>{% endif %}
                            </div>
                        {% endif %}
                        
                        {% if profile_form.is_listed_publicly %} {# Check if the field exists (it should, always) #}
                            <div class="mb-3 form-check"> 
                                {{ profile_form.is_listed_publicly }} 
                                <label class="form-check-label" for="{{ profile_form.is_listed_publicly.id_for_label }}">
                                    {{ profile_form.is_listed_publicly.label }}
                                </label>
                                {% if profile_form.is_listed_publicly.help_text %}<div class="form-text">{{ profile_form.is_listed_publicly.help_text|safe }}</div>{% endif %}
                                {% if profile_form.is_listed_publicly.errors %}<div class="invalid-feedback d-block">{{ profile_form.is_listed_publicly.errors|striptags }}</div>{% endif %}
                            </div>
                        {% endif %}
                    </div> {# End card-body #}
                </div> {# End PROFILE DETAILS CARD #}
                
                <!-- SUBMIT BUTTON -->
                <div class="d-grid mt-4">
                    <button type="submit" class="btn btn-primary btn-lg">{% translate "Save Changes" %}</button>
                </div>

            </form>
        </div>
    </div>
</div>
{% endblock %}===== ./accounts/templates/registration/password_reset_email.html =====
<!-- File: accounts/templates/registration/password_reset_email.html -->
{% load i18n %}
{% autoescape off %}
{% translate "Hi" %} {{ user.get_username }},

{% translate "It looks like you requested a password reset for your account at" %} {{ site_name }}.

{# --- THE CORRECTION --- #}
{# Generate the password reset URL outside of blocktranslate #}
{% url 'password_reset_confirm' uidb64=uid token=token as reset_url %}

{# Now use blocktranslate, passing the generated URL as a variable #}
{% blocktranslate with reset_password_url=reset_url %}
Please go to the following page and choose a new password:
{{ protocol }}://{{ domain }}{{ reset_password_url }}
{% endblocktranslate %}
{# --- END CORRECTION --- #}

{% translate "Your username, in case you've forgotten:" %} {{ user.get_username }}

{% translate "Thanks for using our site!" %}

{% translate "The" %} {{ site_name }} {% translate "team" %}
{% endautoescape off %}===== ./accounts/templates/registration/password_reset_confirm.html =====
<!-- File: accounts/templates/registration/password_reset_confirm.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Enter New Password" %}{% endblock %}

{% block content %}
<div class="row justify-content-center mt-5">
    <div class="col-md-6">
        <div class="card shadow-sm border-0">
            <div class="card-body">
                <h2 class="card-title text-center mb-4">{% translate "Set a New Password" %}</h2>
                {% if validlink %}
                    <form method="post">
                        {% csrf_token %}
                        {# Display non-field errors #}
                        {% if form.non_field_errors %}
                            <div class="alert alert-danger">{{ form.non_field_errors|striptags }}</div>
                        {% endif %}
                        {% for field in form %}
                            <div class="mb-3">
                                <label for="{{ field.id_for_label }}" class="form-label">{{ field.label }}</label>
                                {{ field }}
                                {% if field.help_text %}<div class="form-text">{{ field.help_text|safe }}</div>{% endif %}
                                {% if field.errors %}<div class="invalid-feedback d-block">{{ field.errors|striptags }}</div>{% endif %}
                            </div>
                        {% endfor %}
                        <div class="d-grid">
                            <button type="submit" class="btn btn-primary btn-lg">{% translate "Change Password" %}</button>
                        </div>
                    </form>
                {% else %}
                    <div class="alert alert-danger text-center">
                        {% translate "The password reset link was invalid, possibly because it has already been used." %}
                        {% translate "Please request a new password reset." %}
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}===== ./accounts/templates/registration/login.html =====
<!-- File: accounts/templates/registration/login.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Log In" %}{% endblock %}

{% block content %}
<div class="row justify-content-center mt-5">
    <div class="col-md-6">
        <div class="card shadow-sm border-0"> {# Added border-0 for consistency #}
            <div class="card-body p-4 p-md-5"> {# Added padding for better mobile appearance #}
                <h2 class="card-title text-center mb-4">{% translate "Log In" %}</h2>

                {# Display form errors, if any #}
                {% if form.errors %}
                    <p class="text-danger text-center">{% translate "Your username and password didn't match. Please try again." %}</p>
                {% endif %}

                <form method="post" action="{% url 'login' %}">
                    {% csrf_token %}
                    <div class="mb-3">
                        <label for="{{ form.username.id_for_label }}" class="form-label">{% translate "Username" %}</label>
                        <input type="text" name="username" class="form-control" id="{{ form.username.id_for_label }}" required>
                    </div>
                    <div class="mb-3">
                        <label for="{{ form.password.id_for_label }}" class="form-label">{% translate "Password" %}</label>
                        <input type="password" name="password" class="form-control" id="{{ form.password.id_for_label }}" required>
                    </div>
                    
                    {# --- Forgot Password Link --- #}
                    <div class="text-end mb-3">
                        <a href="{% url 'password_reset' %}" class="small text-muted text-decoration-none">{% translate "Forgot password?" %}</a>
                    </div>
                    {# --- END NEW --- #}

                    <div class="d-grid">
                        <button type="submit" class="btn btn-primary btn-lg">{% translate "Log In" %}</button>
                    </div>
                </form>
            </div>
        </div>
        {# Link to signup page #}
        {# --- THE CORRECTION --- #}
        {# 1. Generate the URL outside of blocktranslate, using 'as' #}
        {% url 'accounts:signup' as signup_url %}
        <p class="text-center mt-3">
            {% blocktranslate %}Don't have an account? <a href="{{ signup_url }}">Sign up here</a>.{% endblocktranslate %}
        </p>
        {# --- END CORRECTION --- #}
    </div>
</div>
{% endblock %}===== ./accounts/templates/registration/password_reset_complete.html =====
<!-- File: accounts/templates/registration/password_reset_complete.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Password Changed" %}{% endblock %}

{% block content %}
<div class="row justify-content-center mt-5">
    <div class="col-md-6 text-center">
        <div class="card shadow-sm border-0">
            <div class="card-body py-5">
                <i class="fas fa-check-circle fa-5x text-success mb-4"></i>
                <h2 class="card-title mb-4">{% translate "Password has been changed successfully!" %}</h2>
                <p>{% translate "Your password has been set. You may go ahead and log in now." %}</p>
                <p class="mt-4"><a href="{% url 'login' %}">{% translate "Log In" %}</a></p>
            </div>
        </div>
    </div>
</div>
{% endblock %}===== ./accounts/templates/registration/signup.html =====
<!-- accounts/templates/registration/signup.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{% block title %}{% translate "Sign Up" %}{% endblock %}

{% block content %}
<div class="row justify-content-center mt-5">
    <div class="col-md-8 col-lg-6">
        <div class="card shadow-sm border-0">
            <div class="card-body p-4 p-md-5">
                <h2 class="card-title text-center mb-4">{% translate "Create an Account" %}</h2>
                
                {# The 'novalidate' attribute tells the browser not to use its native validation, #}
                {# allowing our Django error messages to always be displayed. #}
                <form method="post" novalidate>
                    {% csrf_token %}
                    
                    {# Display any non-field errors (e.g., "password mismatch") at the top. #}
                    {% if form.non_field_errors %}
                        <div class="alert alert-danger p-2" role="alert">
                            {{ form.non_field_errors|striptags }}
                        </div>
                    {% endif %}

                    {# Username Field #}
                    <div class="mb-3">
                        <label for="{{ form.username.id_for_label }}" class="form-label">{{ form.username.label }}</label>
                        {{ form.username }}
                        <div id="usernameHelp" class="form-text">{% translate "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only." %}</div>
                        {% if form.username.errors %}<div class="invalid-feedback d-block">{{ form.username.errors|striptags }}</div>{% endif %}
                    </div>

                    {# Password Field #}
                    <div class="mb-3">
                        <label for="{{ form.password1.id_for_label }}" class="form-label">{{ form.password1.label }}</label>
                        {{ form.password1 }}
                        <div id="passwordHelp" class="form-text">{% translate "Your password must contain at least 8 characters." %}</div>
                        {% if form.password1.errors %}<div class="invalid-feedback d-block">{{ form.password1.errors|striptags }}</div>{% endif %}
                    </div>

                    {# Password Confirmation Field #}
                    <div class="mb-3">
                        <label for="{{ form.password2.id_for_label }}" class="form-label">{{ form.password2.label }}</label>
                        {{ form.password2 }}
                        {% if form.password2.errors %}<div class="invalid-feedback d-block">{{ form.password2.errors|striptags }}</div>{% endif %}
                    </div>

                    <div class="d-grid mt-4">
                        <button type="submit" class="btn btn-primary btn-lg">{% translate "Sign Up" %}</button>
                    </div>
                </form>
            </div>
        </div>
        <p class="text-center mt-3">
            {% translate "Already have an account?" %} <a href="{% url 'login' %}">{% translate "Log in here" %}</a>.
        </p>
    </div>
</div>
{% endblock %}===== ./accounts/__init__.py =====
===== ./passenger_wsgi.py =====
import os
import sys

# Asegura que el directorio del proyecto esté en el PATH
project_home = '/home/sextavac/tvt'
if project_home not in sys.path:
    sys.path.insert(0, project_home)

# Configura la variable DJANGO_SETTINGS_MODULE a tu settings
os.environ['DJANGO_SETTINGS_MODULE'] = 'tvt.settings'

# Obtén la aplicación WSGI de Django
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()===== ./pages/views.py =====
# pages/views.py
import logging
from django.shortcuts import render, get_object_or_404
from .models import Page
from categories.models import Category
from django.core.paginator import Paginator # Asegúrate de importar Paginator
from site_settings.models import SiteConfiguration

logger = logging.getLogger(__name__)

def page_detail_view(request, slug):
    # Buscamos una página que coincida con el slug Y que esté publicada.
    # Si no la encuentra, automáticamente devuelve un error 404.
    page = get_object_or_404(Page, slug=slug, status='published')

    # El contexto es el diccionario de datos que pasamos a la plantilla.
    context = {
        'page': page,
        'translatable_object': page,
    }

    return render(request, 'pages/page_detail.html', context)

def pages_by_category_view(request, category_slug):
    """
    Displays a paginated list of published pages belonging
    to a specific category.
    """
    category = get_object_or_404(Category, slug=category_slug)
    all_pages_in_category = category.pages.filter(status='published').order_by('title')

    try:
        site_config = SiteConfiguration.get_solo()
        # Usamos el mismo setting que para el blog para mantener la consistencia
        items_per_page = site_config.blog_items_per_page 
    except SiteConfiguration.DoesNotExist:
        logger.warning("SiteConfiguration does not exist. Using default items per page.")
        items_per_page = 9 # Fallback

    paginator = Paginator(all_pages_in_category, items_per_page)
    page_number = request.GET.get('page', 1)

    pages_list = paginator.get_page(page_number)

    context = {
        'category': category,
        'pages_list': pages_list, # Pasamos el objeto paginado
    }
    return render(request, 'pages/pages_by_category.html', context)
   ===== ./pages/translation.py =====
# pages/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Page
    
@register(Page)
class PageTranslationOptions(TranslationOptions):
    fields = ('title', 'slug', 'content', 'meta_title', 'meta_description')===== ./pages/urls.py =====
# pages/urls.py
from django.urls import path
from . import views

app_name = 'pages' # <-- AÑADIMOS ESTA LÍNEA

urlpatterns = [
    # NUEVA RUTA: Recibirá un 'slug' de categoría como parámetro
    # Ejemplo: /pages/category/tutoriales/
    path('category/<slug:category_slug>/', views.pages_by_category_view, name='pages_by_category'),

    # Ruta existente para el detalle de una página
    # Ejemplo: /pages/sobre-nosotros/
    path('<slug:slug>/', views.page_detail_view, name='page_detail'),
]===== ./pages/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('categories', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Page',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=250, verbose_name='Title')),
                ('title_es', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_en', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_ca', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('slug', models.SlugField(max_length=250, unique=True, verbose_name='Slug (URL friendly)')),
                ('slug_es', models.SlugField(max_length=250, null=True, unique=True, verbose_name='Slug (URL friendly)')),
                ('slug_en', models.SlugField(max_length=250, null=True, unique=True, verbose_name='Slug (URL friendly)')),
                ('slug_ca', models.SlugField(max_length=250, null=True, unique=True, verbose_name='Slug (URL friendly)')),
                ('content', models.TextField(verbose_name='Content')),
                ('content_es', models.TextField(null=True, verbose_name='Content')),
                ('content_en', models.TextField(null=True, verbose_name='Content')),
                ('content_ca', models.TextField(null=True, verbose_name='Content')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('published', 'Published')], default='draft', max_length=10, verbose_name='Status')),
                ('is_homepage', models.BooleanField(default=False, help_text='Mark only one page with this option. If multiple are marked, the most recent one will be used.', verbose_name='Is Homepage?')),
                ('meta_title', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_es', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_en', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_ca', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_description', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_es', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_en', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_ca', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Creation Date')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Last Updated')),
                ('importance_order', models.PositiveIntegerField(default=99, help_text="A lower number means higher priority in search results. E.g., 1 for 'About Us', 2 for 'Contact', 99 for others.", verbose_name='Importance Order')),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='pages', to=settings.AUTH_USER_MODEL, verbose_name='Author')),
                ('categories', models.ManyToManyField(blank=True, related_name='pages', to='categories.category', verbose_name='Categories')),
            ],
            options={
                'verbose_name': 'page',
                'verbose_name_plural': 'pages',
                'ordering': ['-created_at'],
            },
        ),
    ]
===== ./pages/migrations/__init__.py =====
===== ./pages/migrations/0002_page_featured_image.py =====
# Generated by Django 5.2.3 on 2025-06-21 10:41

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('pages', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='page',
            name='featured_image',
            field=models.ImageField(blank=True, null=True, upload_to='blog/featured/', verbose_name='Featured Image'),
        ),
    ]
===== ./pages/models.py =====
from django.db import models
from django.contrib.auth.models import User
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from django.contrib.contenttypes.fields import GenericRelation
from categories.models import Category
from django.utils.translation import override 

class Page(models.Model):
    """ Represents a single static page in the CMS, like 'About Us'. """
    
    STATUS_CHOICES = (
        ('draft', _('Draft')),
        ('published', _('Published')),
    )
    
    title = models.CharField(max_length=250, verbose_name=_("Title"))
    slug = models.SlugField(max_length=250, unique=True, verbose_name=_("Slug (URL friendly)"))
    content = models.TextField(verbose_name=_("Content")) # The editor will be applied in admin.py
    
    author = models.ForeignKey(User, on_delete=models.PROTECT, related_name="pages", verbose_name=_("Author"))
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft', verbose_name=_("Status"))
    
    categories = models.ManyToManyField(
        Category,
        blank=True,
        verbose_name=_("Categories"),
        related_name="pages"
    )
    
    is_homepage = models.BooleanField(
        default=False,
        verbose_name=_("Is Homepage?"),
        help_text=_("Mark only one page with this option. If multiple are marked, the most recent one will be used.")
    )

    meta_title = models.CharField(max_length=70, blank=True, null=True, verbose_name=_("Meta Title (SEO)"))
    meta_description = models.CharField(max_length=160, blank=True, null=True, verbose_name=_("Meta Description (SEO)"))

    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Creation Date"))
    updated_at = models.DateTimeField(auto_now=True, verbose_name=_("Last Updated"))

    importance_order = models.PositiveIntegerField(
        default=99,
        verbose_name=_("Importance Order"),
        help_text=_("A lower number means higher priority in search results. E.g., 1 for 'About Us', 2 for 'Contact', 99 for others.")
    )
    featured_image = models.ImageField(
        upload_to='blog/featured/', 
        blank=True, 
        null=True, 
        verbose_name=_("Featured Image")
    )
    class Meta:
        verbose_name = _("page")
        verbose_name_plural = _("pages")
        ordering = ['-created_at']

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        # Uses the 'pages' namespace to generate the correct URL.
        return reverse('pages:page_detail', kwargs={'slug': self.slug})
    
    def get_absolute_url_for_language(self, language_code):
        with override(language_code):
            # 'self.slug' automáticamente devuelve el slug para el idioma actual del contexto.
            # Al usar 'override(language_code)', estamos forzando el contexto.
            return reverse('pages:page_detail', kwargs={'slug': self.slug}) ===== ./pages/apps.py =====
from django.apps import AppConfig


class PagesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pages'
===== ./pages/admin.py =====
# File: pages/admin.py
import logging
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from django.conf import settings # Required for dynamically generating search fields

# Third-party imports
from django_summernote.admin import SummernoteModelAdmin # For WYSIWYG editor on Page
from modeltranslation.admin import TabbedTranslationAdmin # For multilingual admin
from modeltranslation.translator import translator # Required for dynamic fields

# Local application imports (ensure these models exist in pages.models, categories.models)
from .models import Page 
from categories.models import Category # Universal Category model


logger = logging.getLogger(__name__)


# Helper function to dynamically generate search_fields and prepopulated_fields
# This is a re-use of the logic from blog/admin.py
def get_language_aware_admin_fields(model_kls):
    search_fields_list = []
    prepopulated_fields_dict = {}
    
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except translator.NotRegistered:
        logger.warning(f"Model {model_kls.__name__} not registered for translation. Dynamic admin fields might be incomplete.")
        pass 

    for lang_code, _ in settings.LANGUAGES:
        if trans_opts:
            # Assuming 'title' and 'content' are common translatable fields
            if 'title' in trans_opts.fields:
                search_fields_list.append(f'title_{lang_code}')
            if 'content' in trans_opts.fields:
                search_fields_list.append(f'content_{lang_code}')
        
        # Consistent prepopulated_fields for slug based on title
        if hasattr(model_kls, 'slug') and hasattr(model_kls, f'title_{lang_code}'): 
            prepopulated_fields_dict[f'slug_{lang_code}'] = (f'title_{lang_code}',)
            
    return tuple(search_fields_list), prepopulated_fields_dict


# --- ADMIN FOR UNIVERSAL CATEGORIES ---
# This part is for the Category model in the categories app, not in pages app.
# Ensure this is defined in categories/admin.py, not here.


# --- ADMIN FOR PAGES ---
@admin.register(Page)
class PageAdmin(SummernoteModelAdmin, TabbedTranslationAdmin):
    """
    Admin options for the Page model, integrating Summernote for content,
    ModelTranslation for multilingual fields, and managing categories.
    """
    # What fields to display in the list view
    list_display = ('title', 'status', 'is_homepage', 'importance_order', 'author', 'display_categories_list')
    
    # Allow editing these fields directly from the list view
    list_editable = ('status', 'is_homepage', 'importance_order') # Removed 'author' if it's a many-to-many relationship
    
    # Filters in the right sidebar
    list_filter = ('status', 'author', 'categories', 'is_homepage')
    
    # Generate search_fields and prepopulated_fields dynamically
    _search_fields, _prepopulated_fields = get_language_aware_admin_fields(Page)
    search_fields = _search_fields
    prepopulated_fields = _prepopulated_fields
    
    # Default ordering for the list
    ordering = ('importance_order', '-updated_at')
    
    # ManyToManyField for categories, uses a nice multi-selector interface
    filter_horizontal = ('categories',) 
    
    # Summernote fields must be specified for each language (e.g., 'content_en')
    summernote_fields = tuple([f'content_{lang_code}' for lang_code, _ in settings.LANGUAGES])


    # Custom method to display categories in the list view
    @admin.display(description=_("Categories"))
    def display_categories_list(self, obj):
        return ", ".join([cat.name for cat in obj.categories.all()])===== ./pages/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./pages/templates/pages/pages_by_category.html =====
{% extends 'core/base.html' %}
{% load i18n %}

{# --- SEO and Browser Tab Title Blocks --- #}
{% block seo_title %}{{ category.meta_title|default:category.name }}{% endblock %}
{% block seo_description %}{{ category.meta_description|default:"" }}{% endblock %}
{% block title %}{% blocktranslate %}Pages in {{ category.name }}{% endblocktranslate %}{% endblock %}


{% block content %}
<div class="container mt-5">

    {# --- Category Page Header --- #}
    <div class="category-header mb-5 text-center">
        <h1 class="display-4">
            {# The main visible title of the page #}
            {% blocktranslate %}
                Pages in category: <span class="text-primary">{{ category.name }}</span>
            {% endblocktranslate %}
        </h1>
        {# Display the category description if it exists #}
        {% if category.description %}
            <p class="lead text-muted">{{ category.description }}</p>
        {% endif %}
    </div>

    {# --- List of Pages --- #}
    <div class="page-list">
        {# Check if the pages_list (the paginated object) contains any items #}
        {% if pages_list %} 
            <ul class="list-group list-group-flush">
                {# Loop through each page in the current page's list #}
                {% for page in pages_list %}
                <li class="list-group-item bg-transparent">
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <h5 class="mb-0">
                            <a href="{{ page.get_absolute_url }}" class="fs-4 text-decoration-none">{{ page.title }}</a>
                        </h5>
                        <small class="text-muted">
                            {# Displaying the 'last updated' date is often more relevant for static pages #}
                            {% blocktranslate with updated_date=page.updated_at|date:"DATE_FORMAT" %}
                            Updated on {{ updated_date }}
                            {% endblocktranslate %}
                        </small>
                    </div>
                </li>
                {% endfor %}
            </ul>
        {% else %}
            {# This message is displayed when no pages are found in this category #}
            <div class="alert alert-info" role="alert">
                {% translate "There are currently no published pages in this category." %}
            </div>
        {% endif %}
    </div>

    {# --- PAGINATION --- #}
    {# We include our single, centralized pagination component. #}
    {# We must pass the paginated object `pages_list` to the component's `page_obj` variable. #}
    {% include 'core/partials/_pagination.html' with page_obj=pages_list %}

</div>
{% endblock %}===== ./pages/templates/pages/page_detail.html =====
<!-- File: pages/templates/pages/page_detail.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load static %}
{% load widget_tags %} {# Ensure widget_tags is loaded for show_widget_zone #}

{# This template is used to render single static pages and the dynamic homepage. #}
{# It checks if a 'page' object exists in the context to handle both cases. #}


{# --- SEO AND BROWSER TAB TITLE BLOCKS (CORRECTED) --- #}

{% block title %}
    {# The 'title' block is defined only ONCE. The conditional logic is inside. #}
    {% if page %}
        {{ page.title }}
    {% else %}
        {% translate "Welcome to TAVATA!" %}
    {% endif %}
{% endblock title %}

{% block seo_title %}
    {# The 'seo_title' block is defined only ONCE. The conditional logic is inside. #}
    {% if page %}
        {{ page.meta_title|default:page.title }}
    {% else %}
        {% translate "Welcome" %} | Tavata.art 
    {% endif %}
{% endblock seo_title %}

{% block seo_description %}
    {# The 'seo_description' block is defined only ONCE. The conditional logic is inside. #}
    {% if page %}
        {{ page.meta_description|default:"" }}
    {% else %}
        {% translate "Content is being prepared. An administrator needs to configure a homepage from the admin panel." %}
    {% endif %}
{% endblock seo_description %}


{# --- MAIN CONTENT BLOCK --- #}
{% block content %}
<div class="container mt-5">
    {# If a valid page object was passed from the view, display its content. #}
    {% if page %}

        {# --- NEW: Widget Zone for Main Content Area on the Homepage --- #}
        {# This section displays prominent content like a carousel or a grid, #}
        {# only if the current page is the designated homepage. #}
        {% if page.is_homepage %}
            <hr class="my-5"> {# Separator before the dynamic content zone #}
            <div class="homepage-main-content-display">
                {% show_widget_zone 'homepage-main-content' %} {# Renders widgets configured for this zone #}
            </div>
        {% endif %}
        <div class="row">
            <div class="col-lg-10 mx-auto">

                <!-- 1. Page Title -->
                <h1 class="display-4 fw-bold">{{ page.title }}</h1>
                
                <!-- 2. Page Metadata (Author and Last Updated) -->
                <p class="lead text-muted">
                    {% firstof page.author.profile.get_display_name page.author.username as author_name %}
                    {% blocktranslate with author=author_name updated_date=page.updated_at|date:"DATE_FORMAT" %}
                        By {{ author }} | Last updated: {{ updated_date }}
                    {% endblocktranslate %}
                </p>

                <!-- 3. Page Categories -->
                {% if page.categories.exists %}
                    <div class="mb-3">
                        <strong>{% translate "Categories" %}:</strong>
                        {% for category in page.categories.all %}
                            <a href="{{ category.get_absolute_url }}" class="badge bg-primary text-dark text-decoration-none">
                                {{ category.name }}
                            </a>
                        {% endfor %}
                    </div>
                {% endif %}

                <hr class="my-4">

                <!-- 4. Main Page Content (from WYSIWYG editor) -->
                <div class="page-content fs-6">
                    {{ page.content|safe }}
                </div>

            </div>
        </div>

        <hr class="my-5"> {# Separator before the dynamic content grid #}

        {# --- NEW: Widget Zone for Post Grids on the Homepage --- #}
        {# This section will render any widgets assigned to 'homepage-content-grid' zone #}
        {# This specific zone is intended for larger content blocks like post grids. #}
        <div class="homepage-post-grid">
            {% show_widget_zone 'homepage-content-grid' %} {# Renders widgets configured for this zone #}
        </div>

    {% else %}
        {# If no page is configured as the homepage, show this friendly message. #}
        <div class="text-center py-5">
            <i class="fas fa-tools fa-4x text-muted mb-4"></i>
            <h1 class="display-4">{% translate "Welcome to Tavata CMS!" %}</h1>
            <p class="lead text-muted">{% translate "Content is being prepared. An administrator needs to configure a homepage from the admin panel." %}</p>
        </div>
    {% endif %}
</div>
{% endblock %}


{# --- LEFT SIDEBAR BLOCK (Conditional) --- #}
{# This sidebar will only appear if we are rendering the designated homepage. #}
{% block sidebar_left %}
    {% if page and page.is_homepage %}
        <div class="sticky-top pt-5">
            {% show_widget_zone 'homepage-sidebar-left' %}
        </div>
    {% endif %}
{% endblock sidebar_left %}


{# --- RIGHT SIDEBAR BLOCK (Conditional) --- #}
{# This sidebar will also only appear on the designated homepage. #}
{% block sidebar_right %}
    {% if page and page.is_homepage %}
        <div class="sticky-top pt-5">
            {% show_widget_zone 'homepage-sidebar-right' %}
        </div>
    {% endif %}
{% endblock sidebar_right %}===== ./pages/__init__.py =====
===== ./gallery/views.py =====
# File: gallery/views.py
from django.shortcuts import render, get_object_or_404
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.utils.html import strip_tags 
from django.utils.translation import get_language, activate, deactivate 
from django.conf import settings # Import settings for accessing LANGUAGES

from site_settings.models import SiteConfiguration # For pagination settings
from blog.models import Post # For collecting featured images from posts
from pages.models import Page # For collecting featured images from pages (assuming it has featured_image)
from .models import Image # For images specifically in the gallery app
import logging
import datetime

logger = logging.getLogger(__name__)

# Helper function to get a truncated description (remains the same)
def get_truncated_description(text, max_length=200):
    """Safely truncates and cleans text for description display."""
    if not text:
        return ""
    stripped_text = strip_tags(str(text)) 
    if len(stripped_text) > max_length:
        return stripped_text[:max_length] + "..."
    return stripped_text

def gallery_view(request):
    """
    Collects images from the Image model and featured images from Posts and Pages,
    normalizes their data, sorts them, and displays them in a paginated gallery.
    """
    gallery_items_data = [] # This list will hold uniform dictionaries for the template
    current_lang = get_language() # Get current language for consistent data retrieval

    # --- Get all images from the gallery.Image model ---
    # Log the number of objects found before processing
    logger.debug(f"Collecting images from gallery.Image model. Found {Image.objects.count()} objects.")
    for img_obj in Image.objects.all():
        # Ensure image has a file attached before trying to get its URL
        img_url = img_obj.image.url if img_obj.image else '' 
        # get_absolute_url() needs to be correctly defined in Image model
        detail_url = img_obj.get_absolute_url() 
        logger.debug(f"Processing Image (ID: {img_obj.pk}): URL={img_url}, DetailURL={detail_url}, Title={img_obj.title}")

        gallery_items_data.append({
            'image_url': img_url,
            'title': img_obj.title, # Modeltranslation handles title directly
            'description': get_truncated_description(img_obj.description),
            'detail_url': detail_url,
            'date': img_obj.uploaded_at, # Use uploaded_at for sorting
            'type': 'Image'
        })
    
    # --- Get featured images from blog.Post model ---
    # Filter for published posts that have a featured image
    posts_with_images = Post.objects.filter(
        status='published', 
        featured_image__isnull=False # Ensure featured_image is not null
    ).exclude(featured_image='').order_by('-published_date') # Exclude empty string
    
    logger.debug(f"Collecting featured images from blog.Post model. Found {posts_with_images.count()} objects.")
    for post_obj in posts_with_images:
        post_img_url = post_obj.featured_image.url if post_obj.featured_image else ''
        post_detail_url = post_obj.get_absolute_url()
        post_published_date = post_obj.published_date 
        
        # Use get_language()/activate/deactivate for language-specific fields like title/description from other models
        # It ensures we grab the translation in the CURRENT language for uniform data collection.
        old_lang = get_language()
        activate(current_lang) 
        
        gallery_items_data.append({
            'image_url': post_img_url,
            'title': post_obj.title, # Modeltranslation handles this
            'description': get_truncated_description(getattr(post_obj, 'meta_description', '') or post_obj.content), 
            'detail_url': post_detail_url,
            'date': post_published_date,
            'type': 'Post'
        })
        activate(old_lang) # Restore original language context

    # --- Get featured images from pages.Page model (if featured_image field exists) ---
    try:
        # Check if Page model has featured_image before querying
        if hasattr(Page, 'featured_image'):
            pages_with_images = Page.objects.filter(
                status='published',
                featured_image__isnull=False
            ).exclude(featured_image='').order_by('-updated_at')
            
            logger.debug(f"Collecting featured images from pages.Page model. Found {pages_with_images.count()} objects.")
            for page_obj in pages_with_images:
                page_img_url = page_obj.featured_image.url if page_obj.featured_image else ''
                page_detail_url = page_obj.get_absolute_url()
                page_updated_at = page_obj.updated_at
                
                old_lang = get_language()
                activate(current_lang)
                gallery_items_data.append({
                    'image_url': page_img_url,
                    'title': page_obj.title, # Modeltranslation handles this
                    'description': get_truncated_description(getattr(page_obj, 'meta_description', '') or page_obj.content),
                    'detail_url': page_detail_url,
                    'date': page_updated_at,
                    'type': 'Page'
                })
                activate(old_lang) # Restore original language context
        else:
            logger.debug("Page model does not have 'featured_image' field. Skipping page image collection.")
    except Exception as e:
        logger.warning(f"Error collecting featured images from Pages: {e}. Check Page model's 'featured_image' field configuration.")


    # --- Sort the combined list by date (newest first) ---
    # Ensure 'date' key always exists with a valid datetime object for sorting.
    # Handle cases where `date` might be None, placing them at the end.
    gallery_items_data.sort(key=lambda x: x.get('date') if x.get('date') is not None else datetime.min, reverse=True)
    
    # --- Apply Pagination ---
    try:
        site_config = SiteConfiguration.get_solo()
        gallery_items_per_page = getattr(site_config, 'gallery_items_per_page', 9) 
    except SiteConfiguration.DoesNotExist:
        gallery_items_per_page = 9 # Fallback value
        logger.warning("SiteConfiguration not found. Using default gallery pagination (9 items).")
    
    paginator = Paginator(gallery_items_data, gallery_items_per_page)
    page_number = request.GET.get('page')

    try:
        images_on_page = paginator.get_page(page_number)
    except PageNotAnInteger:
        images_on_page = paginator.get_page(1)
    except EmptyPage:
        # If the page number is out of range, get the last page, or an empty list if no items
        if paginator.num_pages > 0:
            images_on_page = paginator.get_page(paginator.num_pages)
        else:
            images_on_page = [] # No pages to display if paginator has 0 pages
    
    logger.info(f"Gallery view accessed. Showing page {getattr(images_on_page, 'number', 0)} of {getattr(images_on_page, 'paginator.num_pages', 0)} images.")

    context = {
        'images': images_on_page # Passed to template as 'images'
    }

    return render(request, 'gallery/gallery_page.html', context)

# NEW: View for individual image detail (basic placeholder)
def image_detail_view(request, pk):
    """ Displays details for a single image from the gallery. """
    image = get_object_or_404(Image, pk=pk)
    context = {
        'image': image,
        'translatable_object': image,
    }
    # Create this template: gallery/templates/gallery/image_detail.html
    return render(request, 'gallery/image_detail.html', context)===== ./gallery/translation.py =====
# File: gallery/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Image

@register(Image)
class ImageTranslationOptions(TranslationOptions):
    fields = ('title', 'description',) # Include 'description' for translation===== ./gallery/urls.py =====
# File: gallery/urls.py
from django.urls import path
from . import views

app_name = 'gallery'

urlpatterns = [
    path('', views.gallery_view, name='gallery_view'),
    path('image/<int:pk>/', views.image_detail_view, name='image_detail'), # NEW: for individual image detail
]===== ./gallery/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-20 21:50

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Image',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100)),
                ('image', models.ImageField(upload_to='gallery/')),
                ('uploaded_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]
===== ./gallery/migrations/0002_image_title_ca_image_title_en_image_title_es.py =====
# Generated by Django 5.2.3 on 2025-06-20 22:10

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('gallery', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='image',
            name='title_ca',
            field=models.CharField(max_length=100, null=True),
        ),
        migrations.AddField(
            model_name='image',
            name='title_en',
            field=models.CharField(max_length=100, null=True),
        ),
        migrations.AddField(
            model_name='image',
            name='title_es',
            field=models.CharField(max_length=100, null=True),
        ),
    ]
===== ./gallery/migrations/0003_alter_image_image_alter_image_title_and_more.py =====
# Generated by Django 5.2.3 on 2025-06-21 09:22

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('gallery', '0002_image_title_ca_image_title_en_image_title_es'),
    ]

    operations = [
        migrations.AlterField(
            model_name='image',
            name='image',
            field=models.ImageField(upload_to='gallery/', verbose_name='Image'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title',
            field=models.CharField(max_length=100, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title_ca',
            field=models.CharField(max_length=100, null=True, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title_en',
            field=models.CharField(max_length=100, null=True, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title_es',
            field=models.CharField(max_length=100, null=True, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='uploaded_at',
            field=models.DateTimeField(auto_now_add=True, verbose_name='Uploaded at'),
        ),
    ]
===== ./gallery/migrations/0004_alter_image_options_image_description_and_more.py =====
# Generated by Django 5.2.3 on 2025-06-21 10:41

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('gallery', '0003_alter_image_image_alter_image_title_and_more'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='image',
            options={'ordering': ['-uploaded_at'], 'verbose_name': 'Image', 'verbose_name_plural': 'Images'},
        ),
        migrations.AddField(
            model_name='image',
            name='description',
            field=models.TextField(blank=True, verbose_name='Description'),
        ),
        migrations.AddField(
            model_name='image',
            name='description_ca',
            field=models.TextField(blank=True, null=True, verbose_name='Description'),
        ),
        migrations.AddField(
            model_name='image',
            name='description_en',
            field=models.TextField(blank=True, null=True, verbose_name='Description'),
        ),
        migrations.AddField(
            model_name='image',
            name='description_es',
            field=models.TextField(blank=True, null=True, verbose_name='Description'),
        ),
    ]
===== ./gallery/migrations/__init__.py =====
===== ./gallery/models.py =====
# File: gallery/models.py
from django.db import models
from django.urls import reverse # Import reverse
from django.utils.translation import gettext_lazy as _
from django.utils.translation import override 
import logging

logger = logging.getLogger(__name__)

class Image(models.Model):
    """
    Represents an image in the gallery with a title and description.
    """
    # Title stores the image's name/description, translatable.
    title = models.CharField(max_length=100, verbose_name=_("Title"))
    
    # Image file field. Images will be uploaded to the 'gallery/' subfolder in MEDIA_ROOT.
    image = models.ImageField(upload_to='gallery/', verbose_name=_("Image"))
    
    # NEW: Optional description for the image, translatable.
    description = models.TextField(blank=True, verbose_name=_("Description"))
    
    # Auto-added timestamp for when the image was uploaded.
    uploaded_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Uploaded at"))

    class Meta:
        ordering = ['-uploaded_at']
        verbose_name = _("Image")
        verbose_name_plural = _("Images")

    def __str__(self):
        # modeltranslation automatically returns the translated title.
        return self.title

    def get_absolute_url(self):
        """ Returns the URL to view this specific image's detail page. """
        # This will point to a dedicated view for the image itself.
        return reverse('gallery:image_detail', args=[self.pk]) 
    
    def get_absolute_url_for_language(self, language_code):
        with override(language_code):
            # El PK no cambia con el idioma, así que solo necesitamos el reverse en el contexto del idioma.
            return reverse('gallery:image_detail', args=[self.pk])===== ./gallery/apps.py =====
from django.apps import AppConfig


class GalleryConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'gallery'
===== ./gallery/admin.py =====
# File: gallery/admin.py
from django.contrib import admin
from .models import Image
from django.utils.translation import gettext_lazy as _
from modeltranslation.admin import TabbedTranslationAdmin
from django.conf import settings # NEW: Import settings
import logging

logger = logging.getLogger(__name__)

@admin.register(Image)
class ImageAdmin(TabbedTranslationAdmin):
    """
    Admin options for the Image model, integrating ModelTranslation for multilingual fields.
    Dynamically generates search_fields based on configured languages.
    """
    list_display = (
        'get_translated_title',  
        'image',                 
        'uploaded_at',           
    )
    list_filter = ('uploaded_at',) 
    ordering = ('-uploaded_at',) 

    # --- NEW: Dynamically generate search_fields ---
    # We create a list of all translatable fields (as defined in translation.py)
    # for each configured language.
    search_fields = []
    for lang_code, lang_name in settings.LANGUAGES:
        # Assuming 'title' and 'description' are the translatable fields for Image
        # as defined in gallery/translation.py
        search_fields.append(f'title_{lang_code}')
        search_fields.append(f'description_{lang_code}')
    # Convert the list to a tuple, as search_fields expects a tuple.
    search_fields = tuple(search_fields)
    # --- END NEW ---

    # Control which fields are editable in the form
    fields = ('title', 'description', 'image',) # Now 'title' and 'description' refer to the modeltranslation default fields (current language)

    # Custom method to display the translated title in the list view.
    @admin.display(description=_('Title'))
    def get_translated_title(self, obj):
        # obj.title automatically returns the translated title for the current admin language.
        return obj.title 
    
    def save_model(self, request, obj, form, change):
        """ Log when an image is saved or updated. """
        super().save_model(request, obj, form, change)
        if change:
            logger.info(f"Image '{obj.title}' (ID: {obj.id}) updated by {request.user.username}.")
        else:
            logger.info(f"New image '{obj.title}' (ID: {obj.id}) added by {request.user.username}.")
===== ./gallery/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./gallery/templates/gallery/image_detail.html =====
<!-- File: gallery/templates/gallery/image_detail.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load static %}

{% block title %}{{ image.title }} | {% translate "Image Detail" %}{% endblock %}

{% block content %}
<div class="container my-5 text-center">
    <h1>{{ image.title }}</h1>
    {% if image.description %}
        <p class="lead">{{ image.description }}</p>
    {% endif %}
    {% if image.image %}
        <img src="{{ image.image.url }}" alt="{{ image.title }}" class="img-fluid rounded shadow" style="max-width: 800px;">
    {% endif %}
    <p class="mt-4 text-muted">{% translate "Uploaded on" %} {{ image.uploaded_at|date:"DATE_FORMAT" }}</p>
    <p class="mt-4"><a href="{% url 'gallery:gallery_view' %}">{% translate "Back to Gallery" %}</a></p>
</div>
{% endblock %}===== ./gallery/templates/gallery/gallery_page.html =====
{% extends 'core/base.html' %}
{% load i18n %}
{% block content %}
<div class="container py-4">
  <h1 class="mb-4 text-center">{% trans "Image Gallery" %}</h1>
  <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 g-4">
    {% for img in images %}
      <div class="col">
        <div class="card h-100 shadow-sm">
          <a href="{{ img.detail_url }}">
            <img src="{{ img.image_url }}" class="card-img-top" alt="{{ img.title }}">
          </a>
          <div class="card-body">
            <h5 class="card-title">{{ img.title }}</h5>
            {% if img.description %}
              <p class="card-text">{{ img.description }}</p>
              <a href="{{ img.detail_url }}" class="btn btn-primary btn-sm">
                {% trans "Read more" %}
              </a>
            {% endif %}
            <p class="card-text mt-2">
              <small class="text-muted">
                {% blocktrans with date=img.date|date:"d M Y H:i" %}
                  Uploaded: {{ date }}
                {% endblocktrans %}
              </small>
            </p>
          </div>
        </div>
      </div>
    {% empty %}
      <div class="col">
        <p>{% trans "No images in the gallery." %}</p>
      </div>
    {% endfor %}
  </div>
  {% include "core/partials/_pagination.html" with page_obj=images %}
</div>
{% endblock %}===== ./gallery/__init__.py =====
===== ./tvt/asgi.py =====
"""
ASGI config for tvt project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')

application = get_asgi_application()
===== ./tvt/urls.py =====
from django.conf import settings
from django.conf.urls.i18n import i18n_patterns
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
from django.contrib.auth import views as auth_views
from django.contrib.staticfiles.urls import staticfiles_urlpatterns


# ==============================================================================
# URLS THAT SHOULD NOT BE TRANSLATED (e.g., admin, auth process)
# ==============================================================================
urlpatterns = [
    # 1. Third-party app URLs (like summernote)
    path('summernote/', include('django_summernote.urls')),

    # This includes all of Django's built-in auth URLs (login, password reset, etc.)
    # Our custom logout is technically handled by django.contrib.auth.urls's default logout,
    # as we now handle the POST request in the template. If we needed a custom
    # next_page, we'd define a specific logout path here BEFORE this include.
    path('accounts/', include('django.contrib.auth.urls')),
    path('i18n/', include('django.conf.urls.i18n')), 
]


# ==============================================================================
# URLS THAT WILL BE PREFIXED WITH A LANGUAGE CODE (e.g., /en/blog/, /es/blog/)
# ==============================================================================
urlpatterns += i18n_patterns(
    # 1. Django Admin
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls', namespace='accounts')),
    path('menus/', include('menus.urls', namespace='menus')),
    path('categories/', include('categories.urls', namespace='categories')),
    path('search/', include('search.urls', namespace='search')),
    path('pages/', include('pages.urls', namespace='pages')),
    path('blog/', include('blog.urls', namespace='blog')),
    path('contact/', include('contact.urls', namespace='contact')),
    path('gallery/', include('gallery.urls', namespace='gallery')),
    path('', include('core.urls')),
)


# ==============================================================================
# SERVING MEDIA FILES IN DEVELOPMENT
# ==============================================================================
# This is only for development (DEBUG=True) and should not be used in production.
# The web server (e.g., Nginx) should be configured to serve media files.
if settings.DEBUG:
    # Añadimos las URLs para los archivos MEDIA
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    
    # Este es para tus archivos de app (CSS, JS, imágenes por defecto)
    # Es la forma recomendada por Django para desarrollo.
    urlpatterns += staticfiles_urlpatterns()
# =================================================================================== ./tvt/wsgi.py =====
"""
WSGI config for tvt project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')

application = get_wsgi_application()
===== ./tvt/settings.py =====
"""
Django settings for tvt project.

Generated by 'django-admin startproject' using Django 5.2.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""
from pathlib import Path #-> Asegúrate de que BASE_DIR está definido con pathlib
from decouple import config, Csv
from pathlib import Path
import os
import pymysql
pymysql.install_as_MySQLdb()
from django.utils.translation import gettext_lazy as _

ADMINS = [('Tavata', 'tavata.art@outlook.com')]

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# 1. Leer la variable de entorno principal.
#    Por seguridad, si no se define, se asume 'production'.
ENVIRONMENT = config('ENVIRONMENT', default='development', cast=str)

print("*********************************************")
print(f"**** EJECUTANDO EN AMBIENTE: {ENVIRONMENT.upper()} ****")
print("*********************************************")

# 2. Configurar otras variables basadas en el ambiente
if ENVIRONMENT == 'development':
    SECRET_KEY = config('SECRET_KEY', default='django-insecure-dev-key-default')
    DEBUG = True
    ALLOWED_HOSTS = ['127.0.0.1', 'localhost']
    EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
else: # Para 'testing', 'production' u otros
    SECRET_KEY = config('SECRET_KEY')
    # DEBUG es False por defecto, a menos que un ambiente específico lo active
    DEBUG = config('DEBUG', default=False, cast=bool)
    ALLOWED_HOSTS = config('ALLOWED_HOSTS', cast=Csv()) #-> Permite múltiples hosts separados por comas
    EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# Application definition

INSTALLED_APPS = [
    # 1. modeltranslation PRIMERO. Esto asegura que su "magia" de
    #    parcheo y registro se ejecute antes que cualquier otra cosa,
    #    especialmente antes que el 'admin'.
    'modeltranslation',

    # 2. Las apps de Django Core
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',

    # 3. Otras apps de Terceros
    'django_summernote',
    'solo',
    'mptt',
    'taggit',

    # 4. Nuestras Propias Aplicaciones
    'core.apps.CoreConfig',
    'pages.apps.PagesConfig',
    'blog.apps.BlogConfig',
    'menus.apps.MenusConfig', 
    'site_settings.apps.SiteSettingsConfig', 
    'search.apps.SearchConfig', 
    'contact.apps.ContactConfig',
    'widgets.apps.WidgetsConfig',
    'accounts.apps.AccountsConfig',
    'categories.apps.CategoriesConfig',
    'gallery.apps.GalleryConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.locale.LocaleMiddleware',  # <-- ¡Localization!
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'tvt.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.i18n',
                'tvt.context_processors.languages_context',
            ],
        },
    },
]

WSGI_APPLICATION = 'tvt.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# 3. Configurar la base de datos basada en el ambiente
# Primero, la configuración por defecto para desarrollo
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Luego, sobrescribimos si estamos en un ambiente de tipo MySQL
if ENVIRONMENT == 'testing' or ENVIRONMENT == 'production':
    DATABASES['default'] = {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': config('DB_NAME'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST'),
        'PORT': config('DB_PORT', default='3306'),
        'OPTIONS': {
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }


# --- CACHING CONFIGURATION ---
# https://docs.djangoproject.com/en/5.2/topics/cache/
CACHES = {
    'default': {
        # In-memory cache for development. Fast but resets with every server restart.
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'tavata-cms-unique-cache',
    }
}

# Para producción, podríamos usar algo más robusto como Redis:
# 'default': {
#     'BACKEND': 'django.core.cache.backends.redis.RedisCache',
#     'LOCATION': 'redis://127.0.0.1:6379/1',
# }


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

# Idioma por defecto
LANGUAGE_CODE = 'en' 

# Lista de idiomas disponibles
LANGUAGES = [
    ('es', _('Spanish')),
    ('en', _('English')),
    ('ca', _('Català')),
]

# Rutas donde Django buscará los archivos de traducción (.po/.mo)
LOCALE_PATHS = [
    BASE_DIR / 'locale/',
]

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = '/static/'

# La ruta donde `collectstatic` copiará todos los archivos para producción.
# Es bueno tenerla definida aunque en desarrollo no se use directamente.
STATIC_ROOT = BASE_DIR / 'staticfiles'

# ¡LA CONFIGURACIÓN CLAVE PARA DESARROLLO!
# Directorios adicionales donde el servidor de desarrollo de Django buscará archivos estáticos.
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

X_FRAME_OPTIONS = 'SAMEORIGIN'

# ==============================================================================
# LOGGING CONFIGURATION
# ==============================================================================

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False, # No desactiva los loggers por defecto de Django

    # --- FORMATTERS: Cómo se verá cada línea del log ---
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },

    # --- FILTERS: Para añadir contexto o filtrar logs ---
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },
    },

    # --- HANDLERS: A dónde se envía cada log (consola, archivo, email) ---
    'handlers': {
        # Handler para la consola de desarrollo
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'], # Solo funciona si DEBUG=True
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        # Handler para guardar en un archivo los warnings y errores
        'file_error': {
            'level': 'WARNING',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs/error.log', # Ruta al archivo
            'maxBytes': 1024 * 1024 * 5,  # 5 MB
            'backupCount': 2,
            'formatter': 'verbose',
        },
        # Handler para que los administradores reciban un email en caso de error 500
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'], # Solo funciona si DEBUG=False
            'class': 'django.utils.log.AdminEmailHandler',
        },
    },

    # --- LOGGERS: El cerebro que une todo ---
    'loggers': {
        # Logger principal de Django. Capturará todo lo que pase en el framework.
        'django': {
            'handlers': ['console', 'file_error', 'mail_admins'],
            'level': 'INFO',
            'propagate': True,
        },
        # Podemos crear loggers para nuestras propias apps si queremos
        # 'blog': {
        #     'handlers': ['console', 'file_error'],
        #     'level': 'DEBUG',
        # },
    },
}

# URL to redirect to after a successful login.
LOGIN_REDIRECT_URL = '/'

# URL to redirect to after a successful logout.
LOGOUT_REDIRECT_URL = '/'===== ./tvt/context_processors.py =====
from django.conf import settings

def languages_context(request):
    return {
        'LANGUAGES': settings.LANGUAGES,
    }===== ./tvt/__init__.py =====
===== ./search/views.py =====
# search/views.py
import logging
from django.shortcuts import render
from django.db.models import Q
from django.core.paginator import Paginator

from pages.models import Page
from blog.models import Post
from site_settings.models import SiteConfiguration

logger = logging.getLogger(__name__)

def search_results_view(request):
    """
    Performs a search across Pages and Blog Posts, ordering Pages by importance,
    and paginates the results correctly.
    """
    try:
        site_config = SiteConfiguration.get_solo()
        pages_per_page = site_config.search_pages_per_page
        posts_per_page = site_config.search_posts_per_page
    except SiteConfiguration.DoesNotExist:
        logger.warning("SiteConfiguration does not exist. Using default pagination settings.")
        pages_per_page = 5
        posts_per_page = 5

    query = request.GET.get('q', '')
    
    # Initialize with empty QuerySets
    page_results_qs = Page.objects.none()
    post_results_qs = Post.objects.none()

    if query:
        # Build the Q objects for the search query
        page_query = Q(title__icontains=query) | Q(content__icontains=query)
        post_query = Q(title__icontains=query) | Q(content__icontains=query)

        # --- ¡LA LÓGICA CORRECTA! ---
        # 1. Obtenemos TODAS las páginas que coinciden con la búsqueda.
        # 2. LUEGO, las ordenamos por importancia y después por título.
        page_results_qs = Page.objects.filter(page_query, status='published') \
                                      .distinct() \
                                      .order_by('importance_order', 'title')
        
        post_results_qs = Post.objects.filter(post_query, status='published') \
                                      .distinct().order_by('-published_date')

    # --- Paginación (ahora sobre los QuerySets correctos) ---
    page_paginator = Paginator(page_results_qs, pages_per_page)
    page_page_number = request.GET.get('p_page', 1)
    paginated_page_results = page_paginator.get_page(page_page_number)
    
    post_paginator = Paginator(post_results_qs, posts_per_page)
    post_page_number = request.GET.get('p_post', 1)
    paginated_post_results = post_paginator.get_page(post_page_number)
    
    # --- Contexto ---
    total_results = page_results_qs.count() + post_results_qs.count()

    context = {
        'query': query,
        'page_results': paginated_page_results,
        'post_results': paginated_post_results,
        'total_results': total_results,
    }

    return render(request, 'search/search_results.html', context)===== ./search/urls.py =====
# search/urls.py
from django.urls import path
from . import views

app_name = 'search'

urlpatterns = [
    path('', views.search_results_view, name='search_results'),
]===== ./search/migrations/__init__.py =====
===== ./search/models.py =====
from django.db import models

# Create your models here.
===== ./search/apps.py =====
from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'
===== ./search/admin.py =====
from django.contrib import admin

# Register your models here.
===== ./search/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./search/templates/search/search_results.html =====
<!-- search/templates/search/search_results.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% block content %}
<div class="container mt-5">
    {# --- Search Results Header --- #}
    {% if query %}
        <h1 class="display-5">
            {% translate "Search results for:" %} <span class="text-primary">"{{ query }}"</span>
        </h1>
        <p class="lead text-muted">
            {# Manual pluralization for total results #}
            {% if total_results == 1 %}
                {% blocktranslate trimmed %}1 result found.{% endblocktranslate %}
            {% else %}
                {% blocktranslate with count=total_results trimmed %}
                {{ count }} results found.
                {% endblocktranslate %}
            {% endif %}
        </p>
    {% else %}
        <h1 class="display-5">{% translate "Search" %}</h1>
        <p class="lead text-muted">{% translate "Please enter a term in the search bar above." %}</p>
    {% endif %}

    <hr class="my-4">

    {# --- Display Page Results (ordered by importance) --- #}
    {# This section is only shown if the search found any matching Pages. #}
    {% if page_results %}
        <h3 class="mb-3">{% translate "Pages Found" %}</h3>
        <ul class="list-group list-group-flush mb-5">
            {% for page in page_results %}
            <li class="list-group-item">
                <a href="{{ page.get_absolute_url }}" class="fs-5 text-decoration-none">{{ page.title }}</a>
            </li>
            {% endfor %}
        </ul>
        {# Include the centralized pagination component. #}
        {# We pass the page object and specify the unique URL parameter name for this list. #}
        {% include 'core/partials/_pagination.html' with page_obj=page_results param_name='p_page' %}
    {% endif %}

    {# A divider that only shows if both result types are present #}
    <hr class="my-5 {% if not page_results or not post_results %}d-none{% endif %}">

    {# --- Display Blog Post Results --- #}
    {% if post_results %}
        <h3 class="mb-3">{% translate "Blog Posts Found" %}</h3>
        <ul class="list-group list-group-flush mb-5">
            {% for post in post_results %}
            <li class="list-group-item">
                <a href="{{ post.get_absolute_url }}" class="fs-5 text-decoration-none">{{ post.title }}</a>
                <p class="text-muted mb-0"><small>{% translate "Published on" %} {{ post.published_date|date:"DATE_FORMAT" }}</small></p>
            </li>
            {% endfor %}
        </ul>
        {# We reuse the exact same centralized component, just with different variables #}
        {% include 'core/partials/_pagination.html' with page_obj=post_results param_name='p_post' %}
    {% endif %}

</div>
{% endblock %}===== ./search/__init__.py =====
===== ./contact/views.py =====
# contact/views.py
from django.shortcuts import render, redirect
from django.urls import reverse
from django.contrib import messages
from django.utils.translation import gettext
from .forms import ContactForm

def contact_view(request):
    """
    Displays the contact form and handles form submission.
    """
    if request.method == 'POST':
        # If the form is submitted, bind the POST data to a form instance.
        form = ContactForm(request.POST)
        if form.is_valid():
            # If the data is valid, save it to the database.
            form.save()

            # Create a success message.
            success_message = gettext("Thank you for your message! We will get back to you shortly.")
            messages.success(request, success_message)

            # Redirect to the same page to prevent form resubmission (Post/Redirect/Get pattern).
            return redirect(reverse('contact:contact_form') + '#contact-form')
    else:
        # If it's a GET request, create a blank form instance.
        form = ContactForm()

    return render(request, 'contact/contact_form.html', {'form': form})

# Create your views here.
===== ./contact/urls.py =====
# contact/urls.py
from django.urls import path
from . import views

app_name = 'contact'

urlpatterns = [
    path('', views.contact_view, name='contact_form'),
]===== ./contact/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ContactMessage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=150, verbose_name='Name')),
                ('email', models.EmailField(max_length=254, verbose_name='Email')),
                ('subject', models.CharField(max_length=200, verbose_name='Subject')),
                ('message', models.TextField(verbose_name='Message')),
                ('priority', models.IntegerField(choices=[(1, 'Low'), (2, 'Medium'), (3, 'High'), (4, 'Urgent'), (5, 'Critical')], default=2, verbose_name='Priority')),
                ('is_read', models.BooleanField(default=False, help_text='Indicates if an admin has reviewed this message.', verbose_name='Has been read?')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Received At')),
                ('responded_at', models.DateTimeField(blank=True, help_text='Automatically set when the message is first marked as read.', null=True, verbose_name='Responded At')),
                ('responded_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='handled_contact_messages', to=settings.AUTH_USER_MODEL, verbose_name='Responded By')),
            ],
            options={
                'verbose_name': 'Contact Message',
                'verbose_name_plural': 'Contact Messages',
                'ordering': ['-priority', '-created_at'],
            },
        ),
    ]
===== ./contact/migrations/__init__.py =====
===== ./contact/forms.py =====
# contact/forms.py
from django import forms
from django.utils.translation import gettext_lazy as _
from .models import ContactMessage

class ContactForm(forms.ModelForm):
    """
    A form for users to send contact messages.
    It's based on the ContactMessage model.
    """
    class Meta:
        model = ContactMessage
        # These are the fields the user will see and fill out.
        # We exclude fields like 'is_read' or 'priority' which are for admin use only.
        fields = ['name', 'email', 'subject', 'message']

        # Here we can add Bootstrap classes and other attributes to our form fields.
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control', 
                'placeholder': _('Your Full Name')
            }),
            'email': forms.EmailInput(attrs={
                'class': 'form-control', 
                'placeholder': _('Your Email Address')
            }),
            'subject': forms.TextInput(attrs={
                'class': 'form-control', 
                'placeholder': _('Message Subject')
            }),
            'message': forms.Textarea(attrs={
                'class': 'form-control', 
                'rows': 5,
                'placeholder': _('Write your message here...')
            }),
        }

        # Optional: Customize the labels if needed.
        # By default, Django uses the verbose_name from the model.
        labels = {
            'name': _('Full Name'),
            'email': _('Email Address'),
        }===== ./contact/models.py =====
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.contrib.auth.models import User 

class ContactMessage(models.Model):
    """
    Represents a message submitted through the site's contact form.
    """
    
    # An enumeration for message priority levels.
    # This is the modern, recommended way to create choices in Django.
    class Priority(models.IntegerChoices):
        LOW = 1, _('Low')
        MEDIUM = 2, _('Medium')
        HIGH = 3, _('High')
        URGENT = 4, _('Urgent')
        CRITICAL = 5, _('Critical')

    # Fields for the submitted message content
    name = models.CharField(max_length=150, verbose_name=_("Name"))
    email = models.EmailField(verbose_name=_("Email"))
    subject = models.CharField(max_length=200, verbose_name=_("Subject"))
    message = models.TextField(verbose_name=_("Message"))
    
    # Fields for internal management
    priority = models.IntegerField(
        choices=Priority.choices, 
        default=Priority.MEDIUM,
        verbose_name=_("Priority")
    )
    is_read = models.BooleanField(
        default=False, 
        verbose_name=_("Has been read?"),
        help_text=_("Indicates if an admin has reviewed this message.")
    )
    
    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True, 
        verbose_name=_("Received At")
    )
    responded_at = models.DateTimeField(
        null=True, 
        blank=True, 
        verbose_name=_("Responded At"),
        help_text=_("Automatically set when the message is first marked as read.")
    )
    responded_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL, # Don't delete the message if the user is deleted
        null=True, # this field can be empty if no admin has responded yet
        blank=True,
        related_name='handled_contact_messages',
        verbose_name=_("Responded By")
    )
    class Meta:
        # Default ordering puts the most important and newest messages at the top.
        ordering = ['-priority', '-created_at']
        verbose_name = _("Contact Message")
        verbose_name_plural = _("Contact Messages")

    def __str__(self):
        return f'Message from {self.name} - "{self.subject}"'===== ./contact/apps.py =====
from django.apps import AppConfig


class ContactConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'contact'
===== ./contact/admin.py =====
# contact/admin.py
import logging
from django.contrib import admin
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from .models import ContactMessage

logger = logging.getLogger(__name__)

@admin.register(ContactMessage)
class ContactMessageAdmin(admin.ModelAdmin):
    """ Admin options for the ContactMessage model. """
    list_display = ('subject', 'name', 'priority', 'is_read', 'responded_by', 'responded_at')
    list_filter = ('is_read', 'priority', 'created_at')
    search_fields = ('name', 'email', 'subject', 'message')
    list_editable = ('is_read', 'priority')
    readonly_fields = ('name', 'email', 'subject', 'message', 'created_at', 'responded_at', 'responded_by')

    def save_model(self, request, obj, form, change):
        """
        Custom save logic: sets 'responded_at' timestamp and 'responded_by' user
        when a message is first marked as read, and clears them if marked as unread.
        """
        # Check if 'is_read' is among the fields that have been changed in the form.
        if 'is_read' in form.changed_data:
            # Case 1: The message is being marked as READ.
            if obj.is_read:
                # We only set the data the first time it's marked as read.
                if not obj.responded_at:
                    obj.responded_at = timezone.now()
                    obj.responded_by = request.user
                    logger.info(
                        f"Admin user '{request.user.username}' (ID: {request.user.id}) marked "
                        f"contact message ID {obj.id} ('{obj.subject}') as READ."
                    )
            # Case 2: The message is being marked as UNREAD.
            else:
                obj.responded_at = None
                obj.responded_by = None
                logger.info(
                    f"Admin user '{request.user.username}' (ID: {request.user.id}) marked "
                    f"contact message ID {obj.id} as UNREAD."
                )
        # Call the original save_model method to continue the saving process.
        super().save_model(request, obj, form, change)===== ./contact/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./contact/templates/contact/contact_form.html =====
<!-- contact/templates/contact/contact_form.html -->
{% extends 'core/base.html' %}
{% load i18n %}

{# --- SEO and Browser Tab Title Blocks --- #}
{% block title %}{% translate "Contact Us" %}{% endblock %}
{% block seo_description %}{% translate "Get in touch with the Tavata team. We would love to hear about your project in Computer Vision or Natural Language Processing." %}{% endblock %}


{% block content %}
<div class="container mt-5">
    <div class="row">
        <div class="col-lg-8 mx-auto">
            
            {# --- Page Header --- #}
            <div class="contact-header text-center mb-5">
                <h1 class="display-4">{% translate "Get in Touch" %}</h1>
                <p class="lead text-muted">
                    {% translate "Have a question or a project in mind? We're here to help. Fill out the form below and we will get back to you as soon as possible." %}
                </p>
            </div>

            {# --- Contact Form --- #}
            {# We add an ID to this anchor point for the redirect #}
            <div class="card shadow-sm border-0" id="contact-form">
                <div class="card-body p-4 p-md-5">
                    
                    {# The form is rendered here. We will render it field-by-field for better control. #}
                    <form method="post" action="{% url 'contact:contact_form' %}">
                        {% csrf_token %}

                        {# Display non-field errors, if any (e.g., general form errors) #}
                        {% if form.non_field_errors %}
                            <div class="alert alert-danger" role="alert">
                                {{ form.non_field_errors }}
                            </div>
                        {% endif %}

                        {# Name Field #}
                        <div class="mb-3">
                            <label for="{{ form.name.id_for_label }}" class="form-label">{{ form.name.label }}</label>
                            {{ form.name }}
                            {% if form.name.errors %}
                                <div class="text-danger small mt-1">{{ form.name.errors }}</div>
                            {% endif %}
                        </div>

                        {# Email Field #}
                        <div class="mb-3">
                            <label for="{{ form.email.id_for_label }}" class="form-label">{{ form.email.label }}</label>
                            {{ form.email }}
                            {% if form.email.errors %}
                                <div class="text-danger small mt-1">{{ form.email.errors }}</div>
                            {% endif %}
                        </div>

                        {# Subject Field #}
                        <div class="mb-3">
                            <label for="{{ form.subject.id_for_label }}" class="form-label">{{ form.subject.label }}</label>
                            {{ form.subject }}
                            {% if form.subject.errors %}
                                <div class="text-danger small mt-1">{{ form.subject.errors }}</div>
                            {% endif %}
                        </div>

                        {# Message Field #}
                        <div class="mb-3">
                            <label for="{{ form.message.id_for_label }}" class="form-label">{{ form.message.label }}</label>
                            {{ form.message }}
                             {% if form.message.errors %}
                                <div class="text-danger small mt-1">{{ form.message.errors }}</div>
                            {% endif %}
                        </div>
                        
                        {# Submit Button #}
                        <div class="d-grid">
                            <button type="submit" class="btn btn-primary btn-lg">{% translate "Send Message" %}</button>
                        </div>

                    </form>
                </div>
            </div>
            
        </div>
    </div>
</div>
{% endblock %}===== ./contact/__init__.py =====
===== ./categories/signals.py =====
# File: categories/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.conf import settings
from .models import Category

@receiver([post_save, post_delete], sender=Category)
def clear_category_tree_cache(sender, instance, **kwargs):
    """
    Clears the cached category tree for all languages whenever a category
    is saved or deleted.
    """
    print("--- CATEGORY SIGNAL TRIGGERED: Clearing all category tree caches ---")
    for lang_code, _ in settings.LANGUAGES:
        cache_key = f'full_category_tree_nodes_{lang_code}_v1'
        cache.delete(cache_key)===== ./categories/views.py =====
# File: categories/views.py
from django.shortcuts import render
from .models import Category

def category_tree_view(request):
    """
    Provides the root nodes for rendering a full category tree.
    """
    # We fetch ONLY the top-level categories.
    root_nodes = Category.objects.filter(parent__isnull=True)

    context = {
        'categories': root_nodes,
    }
    return render(request, 'categories/category_tree.html', context)===== ./categories/translation.py =====
# File: categories/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Category

@register(Category)
class CategoryTranslationOptions(TranslationOptions):
    # ANTES: fields = ('name', 'slug', 'meta_title', 'meta_description')
    # AHORA:
    fields = ('name', 'slug', 'description', 'meta_title', 'meta_description')===== ./categories/urls.py =====
# File: categories/urls.py
from django.urls import path
from . import views

app_name = 'categories'

urlpatterns = [
    # La URL raíz de esta app mostrará el árbol de categorías
    path('', views.category_tree_view, name='category_list'),
]===== ./categories/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Category',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, verbose_name='Name')),
                ('name_es', models.CharField(max_length=100, null=True, verbose_name='Name')),
                ('name_en', models.CharField(max_length=100, null=True, verbose_name='Name')),
                ('name_ca', models.CharField(max_length=100, null=True, verbose_name='Name')),
                ('slug', models.SlugField(max_length=100, unique=True, verbose_name='Slug')),
                ('slug_es', models.SlugField(max_length=100, null=True, unique=True, verbose_name='Slug')),
                ('slug_en', models.SlugField(max_length=100, null=True, unique=True, verbose_name='Slug')),
                ('slug_ca', models.SlugField(max_length=100, null=True, unique=True, verbose_name='Slug')),
                ('description', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', verbose_name='Description')),
                ('description_es', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', null=True, verbose_name='Description')),
                ('description_en', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', null=True, verbose_name='Description')),
                ('description_ca', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', null=True, verbose_name='Description')),
                ('meta_title', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, verbose_name='Meta Title (SEO)')),
                ('meta_title_es', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_en', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_ca', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_description', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, verbose_name='Meta Description (SEO)')),
                ('meta_description_es', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_en', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_ca', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('lft', models.PositiveIntegerField(editable=False)),
                ('rght', models.PositiveIntegerField(editable=False)),
                ('tree_id', models.PositiveIntegerField(db_index=True, editable=False)),
                ('level', models.PositiveIntegerField(editable=False)),
                ('parent', mptt.fields.TreeForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='categories.category', verbose_name='Parent Category')),
            ],
            options={
                'verbose_name': 'Category',
                'verbose_name_plural': 'Categories',
            },
        ),
    ]
===== ./categories/migrations/0002_alter_category_options_alter_category_description_and_more.py =====
# Generated by Django 5.2.3 on 2025-06-19 21:04

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('categories', '0001_initial'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='category',
            options={'ordering': ['name'], 'verbose_name': 'Category', 'verbose_name_plural': 'Categories'},
        ),
        migrations.AlterField(
            model_name='category',
            name='description',
            field=models.TextField(blank=True, help_text='An optional description for the category.', verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='description_ca',
            field=models.TextField(blank=True, help_text='An optional description for the category.', null=True, verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='description_en',
            field=models.TextField(blank=True, help_text='An optional description for the category.', null=True, verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='description_es',
            field=models.TextField(blank=True, help_text='An optional description for the category.', null=True, verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='meta_description',
            field=models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)'),
        ),
        migrations.AlterField(
            model_name='category',
            name='meta_title',
            field=models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)'),
        ),
        migrations.AlterField(
            model_name='category',
            name='parent',
            field=mptt.fields.TreeForeignKey(blank=True, help_text='Select a parent to create a sub-category.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='categories.category', verbose_name='Parent Category'),
        ),
    ]
===== ./categories/migrations/__init__.py =====
===== ./categories/models.py =====
# File: categories/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from mptt.models import MPTTModel, TreeForeignKey

class Category(MPTTModel):
    """
    A universal, hierarchical category model using a simple self-referencing
    ForeignKey to handle nesting.
    """
    # Basic category fields
    name = models.CharField(
        max_length=100, 
        verbose_name=_("Name")
    )
    slug = models.SlugField(
        max_length=100, 
        unique=True, 
        verbose_name=_("Slug")
    )
    
    # Simple hierarchy field
    parent = TreeForeignKey(
        'self', 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True, 
        related_name='children',
        verbose_name=_("Parent Category"),
        help_text=_("Select a parent to create a sub-category.")
    )
    
    # Optional descriptive fields
    description = models.TextField(
        blank=True, 
        verbose_name=_("Description"),
        help_text=_("An optional description for the category.")
    )
    
    # SEO Fields
    meta_title = models.CharField(
        max_length=70, 
        blank=True, null=True,
        verbose_name=_("Meta Title (SEO)"),
        help_text=_("A precise title for search engine results (max 70 chars).")
    )
    meta_description = models.CharField(
        max_length=160, 
        blank=True, null=True,
        verbose_name=_("Meta Description (SEO)"),
        help_text=_("A short description for search engine previews (max 160 chars).")
    )

    class Meta:
        """ Standard Django model metadata. """
        verbose_name = _("Category")
        verbose_name_plural = _("Categories")
        # Order alphabetically by default in the admin and queries.
        ordering = ['name']

    def __str__(self):
        """ Provides a clear representation in the admin, showing hierarchy. """
        if self.parent:
            return f"{self.parent.name} -> {self.name}"
        return self.name
    
    @property
    def is_blog_category(self):
        """ Checks if this category is used for blog posts. """
        return hasattr(self, 'blog_posts') and self.blog_posts.exists()

    def get_absolute_url(self):
        """
        Generates the correct URL for the category's list page.
        """
        if self.is_blog_category:
            return reverse('blog:posts_by_category', args=[self.slug])
        else:
            # Fallback to the pages category list view
            return reverse('pages:pages_by_category', args=[self.slug])===== ./categories/apps.py =====
# File: categories/apps.py
from django.apps import AppConfig

class CategoriesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'categories'

    def ready(self):
        # This imports the signals so they are connected when Django starts.
        import categories.signals===== ./categories/admin.py =====
# File: categories/admin.py
import logging
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from django.conf import settings 

# Third-party imports
from mptt.admin import DraggableMPTTAdmin 
from modeltranslation.admin import TabbedTranslationAdmin
from modeltranslation.translator import translator 

# Local application imports (ensure this model exists in categories.models)
from .models import Category


logger = logging.getLogger(__name__)


# Helper function to dynamically generate prepopulated_fields for multi-language slugs.
def get_language_aware_prepopulated_fields(model_kls):
    prepopulated_fields_dict = {}
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except translator.NotRegistered:
        logger.warning(f"Model {model_kls.__name__} not registered for translation. "
                       f"Dynamic prepopulated_fields might be incomplete.")
        return prepopulated_fields_dict 

    has_slug = hasattr(model_kls, 'slug')
    has_translatable_name = 'name' in trans_opts.fields if trans_opts else False

    if has_slug and has_translatable_name:
        for lang_code, _ in settings.LANGUAGES:
            prepopulated_fields_dict[f'slug_{lang_code}'] = (f'name_{lang_code}',)
                
    return prepopulated_fields_dict


# Helper function to dynamically generate search_fields for translatable models.
def get_language_aware_search_fields(model_kls):
    """
    Generates a tuple of search fields for a model in all configured languages.
    Assumes 'name' and 'description' are common translatable text fields.
    """
    search_fields_list = []
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except translator.NotRegistered:
        return tuple() 

    for lang_code, _ in settings.LANGUAGES:
        if 'name' in trans_opts.fields:
            search_fields_list.append(f'name_{lang_code}')
        if 'description' in trans_opts.fields: # Assuming description is also a common searchable field
            search_fields_list.append(f'description_{lang_code}')

    return tuple(search_fields_list)


@admin.register(Category)
class CategoryAdmin(TabbedTranslationAdmin, DraggableMPTTAdmin):
    """
    Admin options for the universal Category model.
    It combines TabbedTranslationAdmin for multilingual fields
    and DraggableMPTTAdmin for intuitive drag-and-drop hierarchy management.
    """
    
    # --- MPTT Configuration ---
    list_display = (
        'tree_actions',    
        'indented_title',  
        'slug',            
        # --- REMOVE THIS LINE ---
        # get_language_aware_search_fields.description # This line caused the error!
    )
    list_display_links = ('indented_title',) 

    mptt_level_indent = 20 

    # --- ModelTranslation Configuration ---
    prepopulated_fields = get_language_aware_prepopulated_fields(Category)
    
    # --- Standard Django Admin Configuration ---
    search_fields = get_language_aware_search_fields(Category)
    
    # --- Optional: Custom field for post count (ensure blog_posts is defined in models.py) ---
    # @admin.display(description=_("Post Count"))
    # def post_count_display(self, obj):
    #     return obj.blog_posts.count() if hasattr(obj, 'blog_posts') else 0
    # list_display = list_display + ('post_count_display',) # Add to list_display if you uncomment===== ./categories/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./categories/templatetags/category_tags.py =====
# File: categories/templatetags/category_tags.py
import logging
from django import template
from django.core.cache import cache
from django.conf import settings
from ..models import Category

# Get a logger instance for this module
logger = logging.getLogger(__name__)

# This is necessary for Django to discover our custom tags
register = template.Library()


@register.inclusion_tag('core/partials/_tree_node_component.html', takes_context=True)
def render_category_tree(context):
    """
    Fetches and renders the entire category tree.

    This tag is highly optimized:
    1. It's language-aware, caching a separate tree for each active language.
    2. It uses a configurable cache timeout, managed from the SiteConfiguration model.
    3. The cache is automatically invalidated by signals when a category is changed.
    """
    # 1. Get the current language from the template context to build a unique cache key.
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'full_category_tree_nodes_{language_code}_v1'
    
    # 2. Try to fetch the full list of category nodes from the cache.
    nodes = cache.get(cache_key)
    
    # 3. If it's a "cache miss" (nodes is None), we query the database.
    if nodes is None:
        # We only log the DB query if caching was actually attempted (will be on a miss).
        logger.info(f"CACHE MISS for category tree (lang: {language_code}). Querying database.")
        
        # For `recursetree` to work efficiently, we fetch all nodes at once.
        # MPTT ensures they are correctly ordered for tree construction.
        nodes = Category.objects.all()
        
        # Evaluate to a list before caching to store the results, not the lazy queryset.
        nodes = list(nodes)

        # Get the cache timeout setting from our global site configuration.
        try:
            from site_settings.models import SiteConfiguration
            timeout = SiteConfiguration.get_solo().category_tree_cache_timeout
        except ImportError:
             logger.error("Could not import SiteConfiguration. Is the app in INSTALLED_APPS?")
             timeout = 3600 # Fallback to 1 hour
        except SiteConfiguration.DoesNotExist:
            logger.warning("SiteConfiguration not found. Using default cache timeout of 1 hour.")
            timeout = 3600 # Fallback to 1 hour
        
        # 4. Store the result in the cache if caching is enabled (timeout > 0).
        if timeout > 0:
            cache.set(cache_key, nodes, timeout)
            logger.debug(f"Cached category tree for {timeout} seconds.")
    else:
        logger.debug(f"CACHE HIT for category tree (lang: {language_code}). Serving from cache.")
            
    return {'nodes': nodes}===== ./categories/templatetags/__init__.py =====
===== ./categories/templates/categories/category_tree.html =====
<!-- File: categories/templates/categories/category_tree.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load category_tags %} {# 1. Load our new custom template tags #}

{% block title %}{% translate "All Categories" %}{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-lg-10">
            
            <div class="text-center mb-5">
                <i class="fas fa-sitemap fa-3x text-primary mb-3"></i>
                <h1 class="display-4">{% translate "Explore Our Topics" %}</h1>
                <p class="lead text-muted">{% translate "Navigate through our content organized by category." %}</p>
            </div>

            {# 2. Simply call our universal and cached template tag #}
            {# It handles everything: fetching data, caching, and rendering the tree. #}
            {% render_category_tree %}
            
        </div>
    </div>
</div>
{% endblock %}===== ./categories/templates/categories/partials/_category_tree_recursive.html =====
<!-- File: categories/templates/categories/partials/_category_tree_recursive.html -->
{% load i18n %}

{# This template snippet receives a 'nodes' variable and renders them. #}
{# It's designed to be called recursively. #}

{% for node in nodes %}
    {# Render the current category item #}
    <a href="{{ node.get_absolute_url }}" 
       class="list-group-item list-group-item-action"
       {# We need to manually calculate the indent level #}
       style="padding-left: {{ padding|default:1 }}rem;">
        {{ node.name }}
    </a>

    {# --- THE RECURSION --- #}
    {# Check if the current node has children #}
    {% with children=node.children.all %}
        {% if children %}
            {# If it has children, include this VERY SAME TEMPLATE again, #}
            {# passing the list of children to it. #}
            {% include "categories/partials/_category_tree_recursive.html" with nodes=children padding=padding|add:1.5 %}
        {% endif %}
    {% endwith %}

{% endfor %}

{# Note: The 'padding' variable is used to control the indentation level of child categories. #}
{# It should be passed from the parent template or view when this snippet is included. #}   ===== ./categories/__init__.py =====
===== ./menus/signals.py =====
# File: menus/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from .models import MenuItem, Menu

@receiver([post_save, post_delete], sender=MenuItem)
def clear_menu_cache(sender, instance, **kwargs):
    """
    Clears the relevant menu cache whenever a MenuItem is saved or deleted.
    """
    # We need to clear the cache for all languages
    from django.conf import settings
    if instance.menu:
        for lang_code, lang_name in settings.LANGUAGES:
            cache_key = f'menu_items_{instance.menu.slug}_{lang_code}_v1'
            cache.delete(cache_key)
        print(f"Cache cleared for menu '{instance.menu.slug}'")===== ./menus/views.py =====
# File: menus/views.py
from django.shortcuts import render
from .models import Menu

def menu_view(request):
    # La plantilla ahora se encargará de llamar al tag
    return render(request, 'menus/menu_page.html')
===== ./menus/translation.py =====
# menus/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Menu, MenuItem

# ==============================================================================
# 1. Register the Menu model for translation.
#    This makes the 'title' field multilingual.
# ==============================================================================
@register(Menu)
class MenuTranslationOptions(TranslationOptions):
    """ Translation options for the Menu model. """
    fields = ('title',)


# ==============================================================================
# 2. Register the MenuItem model for translation.
#    This makes the 'title' field of each link multilingual.
# ==============================================================================
@register(MenuItem)
class MenuItemTranslationOptions(TranslationOptions):
    """ Translation options for the MenuItem model. """
    fields = ('title',)===== ./menus/urls.py =====
from django.urls import path
from . import views

app_name = 'menus'

urlpatterns = [
    path('test/', views.menu_view, name='menu_test'),
]===== ./menus/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 22:24

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('pages', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Menu',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100, unique=True, verbose_name='Menu Title')),
                ('title_es', models.CharField(max_length=100, null=True, unique=True, verbose_name='Menu Title')),
                ('title_en', models.CharField(max_length=100, null=True, unique=True, verbose_name='Menu Title')),
                ('title_ca', models.CharField(max_length=100, null=True, unique=True, verbose_name='Menu Title')),
                ('slug', models.SlugField(max_length=100, unique=True, verbose_name='Slug')),
            ],
            options={
                'verbose_name': 'Menu',
                'verbose_name_plural': 'Menus',
            },
        ),
        migrations.CreateModel(
            name='MenuItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100, verbose_name='Link Text')),
                ('title_es', models.CharField(max_length=100, null=True, verbose_name='Link Text')),
                ('title_en', models.CharField(max_length=100, null=True, verbose_name='Link Text')),
                ('title_ca', models.CharField(max_length=100, null=True, verbose_name='Link Text')),
                ('order', models.PositiveIntegerField(default=0, verbose_name='Display Order')),
                ('link_type', models.CharField(choices=[('url', 'Manual URL'), ('page', 'Single Page'), ('all_blog_categories', 'Blog Categories Tree (Dropdown)'), ('important_pages', 'Important Pages List (Dropdown)')], default='url', max_length=50, verbose_name='Link Type')),
                ('link_url', models.CharField(blank=True, max_length=255, verbose_name='Manual URL')),
                ('icon_class', models.CharField(blank=True, max_length=100, verbose_name='Icon Class')),
                ('lft', models.PositiveIntegerField(editable=False)),
                ('rght', models.PositiveIntegerField(editable=False)),
                ('tree_id', models.PositiveIntegerField(db_index=True, editable=False)),
                ('level', models.PositiveIntegerField(editable=False)),
                ('link_page', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='pages.page', verbose_name='Page Link')),
                ('menu', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='items', to='menus.menu', verbose_name='Menu')),
                ('parent', mptt.fields.TreeForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='menus.menuitem', verbose_name='Parent Menu Item')),
            ],
            options={
                'verbose_name': 'Menu Item',
                'verbose_name_plural': 'Menu Items',
            },
        ),
    ]
===== ./menus/migrations/0002_alter_menuitem_options_alter_menuitem_icon_class_and_more.py =====
# Generated by Django 5.2.3 on 2025-06-21 16:07

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('menus', '0001_initial'),
        ('pages', '0002_page_featured_image'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='menuitem',
            options={'ordering': ['order'], 'verbose_name': 'Menu Item', 'verbose_name_plural': 'Menu Items'},
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='icon_class',
            field=models.CharField(blank=True, help_text="FontAwesome class (e.g., 'fas fa-home') to display an icon next to the link.", max_length=100, verbose_name='Icon Class'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='link_page',
            field=models.ForeignKey(blank=True, help_text="Link to a specific internal page. Only used if Link Type is 'Single Page'.", null=True, on_delete=django.db.models.deletion.SET_NULL, to='pages.page', verbose_name='Page Link'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='link_type',
            field=models.CharField(choices=[('url', 'Manual URL'), ('page', 'Single Page'), ('all_blog_categories', 'Blog Categories Tree (Dropdown)'), ('important_pages', 'Important Pages List (Dropdown)')], default='url', help_text='Determines how this menu item behaves: a direct link, or a dynamic content generator.', max_length=50, verbose_name='Link Type'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='link_url',
            field=models.CharField(blank=True, help_text="Use for external URLs (e.g., 'https://google.com') or custom internal paths (e.g., '/blog/'). Only used if Link Type is 'Manual URL'.", max_length=255, verbose_name='Manual URL'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='parent',
            field=mptt.fields.TreeForeignKey(blank=True, help_text='Select a parent item to nest this menu item within it.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='menus.menuitem', verbose_name='Parent Menu Item'),
        ),
    ]
===== ./menus/migrations/__init__.py =====
===== ./menus/models.py =====
# File: menus/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

# Third-party imports
from mptt.models import MPTTModel, TreeForeignKey

# Local application imports (ensure these models exist in pages.models and categories.models)
from pages.models import Page # For linking to specific internal pages
# from categories.models import Category # If Category is needed for direct link types


class Menu(models.Model):
    """
    Represents a container for menu items, defining a specific menu location.
    Examples: 'Main Menu', 'Footer Menu', 'Social Media Links'.
    """
    title = models.CharField(max_length=100, unique=True, verbose_name=_("Menu Title"))
    slug = models.SlugField(max_length=100, unique=True, verbose_name=_("Slug"))

    class Meta:
        verbose_name = _("Menu")
        verbose_name_plural = _("Menus")

    def __str__(self):
        # Modeltranslation automatically provides the translated title.
        return self.title


class MenuItem(MPTTModel):
    """
    Represents a single, hierarchical item within a specific Menu.
    It can be a simple link, or a dynamic placeholder that generates sub-items
    (e.g., a "Blog Categories" dropdown).
    """

    # Enum for defining the type of link this menu item represents.
    class LinkType(models.TextChoices):
        URL = 'url', _('Manual URL')
        PAGE = 'page', _('Single Page')
        # These types are placeholders for dynamic content generation in the frontend.
        ALL_BLOG_CATEGORIES = 'all_blog_categories', _('Blog Categories Tree (Dropdown)')
        IMPORTANT_PAGES = 'important_pages', _('Important Pages List (Dropdown)')

    # --- Core Relationships ---
    # The Menu container this item belongs to.
    menu = models.ForeignKey(
        Menu, 
        on_delete=models.CASCADE, 
        related_name="items", 
        verbose_name=_("Menu")
    )
    
    # The 'parent' field enables hierarchical (nested) menu structures,
    # provided by django-mptt.
    parent = TreeForeignKey(
        'self', # Refers to the MenuItem model itself.
        on_delete=models.CASCADE, 
        null=True, 
        blank=True, 
        related_name='children', 
        db_index=True, # For efficient lookups.
        verbose_name=_("Parent Menu Item"),
        help_text=_("Select a parent item to nest this menu item within it.")
    )
    
    # --- Item Content and Order ---
    title = models.CharField(max_length=100, verbose_name=_("Link Text"))
    order = models.PositiveIntegerField(default=0, verbose_name=_("Display Order"))

    # --- Link Configuration ---
    # Specifies how the menu item will generate its URL or dynamic content.
    link_type = models.CharField(
        max_length=50, # Sufficient for all TextChoices values.
        choices=LinkType.choices,
        default=LinkType.URL,
        verbose_name=_("Link Type"),
        help_text=_("Determines how this menu item behaves: a direct link, or a dynamic content generator.")
    )

    # Conditional link fields. Only one of these should typically be filled.
    link_page = models.ForeignKey(
        Page, 
        on_delete=models.SET_NULL, # If the page is deleted, the menu item link becomes null.
        null=True, 
        blank=True, 
        verbose_name=_("Page Link"),
        help_text=_("Link to a specific internal page. Only used if Link Type is 'Single Page'.")
    )
    link_url = models.CharField(
        max_length=255, 
        blank=True, 
        verbose_name=_("Manual URL"),
        help_text=_("Use for external URLs (e.g., 'https://google.com') or custom internal paths (e.g., '/blog/'). Only used if Link Type is 'Manual URL'.")
    )
    icon_class = models.CharField(
        max_length=100, 
        blank=True, 
        verbose_name=_("Icon Class"),
        help_text=_("FontAwesome class (e.g., 'fas fa-home') to display an icon next to the link.")
    )

    class MPTTMeta:
        """ MPTT specific options for ordering nodes within the tree. """
        order_insertion_by = ['order'] # Orders items by their 'order' field.

    class Meta:
        """ Standard Django model metadata. """
        verbose_name = _("Menu Item")
        verbose_name_plural = _("Menu Items")
        # Ensure consistent display order for all queries by default.
        ordering = ['order'] 

    def __str__(self):
        """ Returns an indented string representation useful for admin display. """
        # 'self.level' is automatically provided by django-mptt.
        return f"{'--' * self.level} {self.title}"

    def get_url(self):
        """
        Generates the actual URL for the menu item based on its link_type.
        Returns a placeholder '#' if no valid URL is configured.
        """
        if self.link_type == self.LinkType.PAGE and self.link_page:
            return self.link_page.get_absolute_url()
        elif self.link_type == self.LinkType.URL and self.link_url:
            return self.link_url
        # For dynamic link types (like ALL_BLOG_CATEGORIES) the URL is often '#'
        # as clicking the top-level item expands the dropdown, not navigates.
        return "#"
===== ./menus/apps.py =====
# File: menus/apps.py
from django.apps import AppConfig

class MenusConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'menus'

    def ready(self):
        # This line is crucial. It tells Django to connect the signals
        # defined in menus/signals.py when the application starts.
        import menus.signals ===== ./menus/admin.py =====
# File: menus/admin.py
import logging
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from django.conf import settings # Required for dynamically accessing LANGUAGE_CODE

# Third-party imports
from mptt.admin import DraggableMPTTAdmin 
from modeltranslation.admin import TabbedTranslationAdmin
from modeltranslation.translator import translator, NotRegistered # NotRegistered is for helper function

# Local application imports
from .models import Menu, MenuItem # Ensure these models are defined in menus/models.py


logger = logging.getLogger(__name__)


# --- Helper functions for dynamic admin fields ---
# This helper is self-contained within this admin file for now.
# Ideally, for broader reuse across admin files, it could be moved to a shared utility module (e.g., core/admin_helpers.py).

def get_translated_fieldnames(field_base, model_kls=None):
    """
    Dynamically generates a list of translated field names (e.g., 'title_en', 'title_es', 'title_ca')
    for a given base field name (e.g., 'title'), based on Django project's LANGUAGES settings.

    Args:
        field_base (str): The base name of the field (e.g., 'title', 'content', 'description').
        model_kls (Model, optional): The model class to check if the field_base is
                                    actually translatable for that model. If not provided,
                                    it assumes the field could be translatable.
    Returns:
        tuple: A tuple of generated field names (e.g., ('title_en', 'title_es')).
    """
    generated_field_names = []
    
    # Check if the model_kls is provided and the field_base is indeed translatable for it.
    if model_kls:
        try:
            trans_opts = translator.get_options_for_model(model_kls)
            if field_base not in trans_opts.fields:
                # If the field is not registered for translation for this model,
                # return just the base field name as a single-element tuple.
                # This ensures backward compatibility if a non-translatable field is passed.
                return (field_base,) 
        except NotRegistered:
            # If the model itself is not registered for translation, return the base field.
            return (field_base,)

    # Generate translated field names for all configured languages.
    for lang_code, _ in settings.LANGUAGES:
        generated_field_names.append(f"{field_base}_{lang_code}")
    
    return tuple(generated_field_names)


# --- ADMIN FOR MAIN MENU CONTAINERS ---
@admin.register(Menu)
class MenuAdmin(TabbedTranslationAdmin):
    """
    Admin options for the main Menu containers (e.g., 'Main Menu', 'Footer Menu').
    This class handles the creation and top-level management of Menu objects.
    """
    list_display = ('title', 'slug') # 'title' is translatable, 'slug' is not.
    
    prepopulated_fields = {
        # The 'slug' field of the Menu model is NOT translatable, but its 'title' IS.
        # We prepopulate the non-translatable 'slug' from the 'title' field of the default language.
        'slug': (f'title_{settings.LANGUAGE_CODE}',)
    }

    # Search functionality over translated title fields.
    search_fields = get_translated_fieldnames('title', model_kls=Menu)

    # Note: MenuItem inline management is done via MenuItemAdmin directly for hierarchy.


# --- ADMIN FOR HIERARCHICAL MENU ITEMS ---
@admin.register(MenuItem)
class MenuItemAdmin(DraggableMPTTAdmin, TabbedTranslationAdmin):
    """
    Admin options for the hierarchical MenuItem model.
    This combines DraggableMPTTAdmin for intuitive drag-and-drop hierarchy management
    and TabbedTranslationAdmin for multilingual fields (like 'title').
    """
    # Fields to display in the tree view list of menu items.
    list_display = (
        'tree_actions',    # Provided by DraggableMPPTAAdmin for drag-and-drop handles.
        'indented_title',  # Provided by DraggableMPPTAAdmin to show indented title.
        'link_type',       # Displays the chosen link type (e.g., 'Page', 'Manual URL').
        'menu',            # Indicates which parent Menu container this item belongs to.
        'order',           # Display order to aid initial sorting or when not dragging.
    )
    
    # Makes the indented title clickable to go to the change form for the item.
    list_display_links = ('indented_title',)

    # Allows filtering menu items by their parent Menu container or link type.
    list_filter = ('menu', 'link_type',)
    
    # Fields that can be edited directly from the list view (for quick changes).
    list_editable = ('order', 'menu', 'link_type',)
    
    # MPTT-specific setting for the indentation width in the admin tree view.
    mptt_level_indent = 25 

    # Search functionality over translated title fields.
    search_fields = get_translated_fieldnames('title', model_kls=MenuItem)

    # Note: MenuItem model does not have a 'slug' field, so prepopulated_fields should not be set.
    # If a translable slug field existed on MenuItem, the implementation would be:
    # prepopulated_fields = get_translated_fieldnames('slug', model_kls=MenuItem)

    # Fields to display in the detailed change form for a single menu item.
    # This list should include all fields from the MenuItem model for editing.
    fields = (
        'menu',           # The parent Menu container.
        'parent',         # The parent MenuItem for nested hierarchy.
        'title',          # The translatable link text.
        'order',          # Display order.
        'link_type',      # Type of link (e.g., Page, Manual URL).
        'link_page',      # Conditional: linked Page object.
        'link_url',       # Conditional: manual URL string.
        'icon_class',     # Optional: FontAwesome icon class.
    )
===== ./menus/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./menus/templatetags/__init__.py =====
===== ./menus/templatetags/menu_tags.py =====
# File: menus/templatetags/menu_tags.py
import logging
from django import template
from django.core.cache import cache
from django.conf import settings # Needed for settings.LANGUAGES and settings.LANGUAGE_CODE
from django.db.models import Count, Q # Needed for dynamic children queries

# Import necessary models for the dynamic logic
from ..models import Menu, MenuItem # Relative import for models within the same app
from pages.models import Page # For Important Pages list
from categories.models import Category # For Blog Categories list

logger = logging.getLogger(__name__)

# Import SiteConfiguration for cache timeout settings (handle potential ImportError or DoesNotExist)
try:
    from site_settings.models import SiteConfiguration
except ImportError:
    logger.error("Could not import SiteConfiguration. Ensure 'site_settings' app is in INSTALLED_APPS.")
    SiteConfiguration = None # Fallback for type hinting / future handling

logger = logging.getLogger(__name__) # Get logger specific to this module
register = template.Library() # Register this as a Django template library


@register.inclusion_tag('menus/partials/_navbar_main_level.html', takes_context=True)
def show_menu(context, menu_slug):
    """
    Fetches and renders the top-level menu items for a main navigation bar.
    Handles caching and prepares dynamic sub-items.
    """
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'menu_nodes_main_level_{menu_slug}_{language_code}_v1'
    
    # Try getting the top-level nodes (with attached dynamic_children) from cache
    top_level_nodes = cache.get(cache_key)

    if top_level_nodes is None:
        logger.info(f"CACHE MISS for main level menu '{menu_slug}' (lang: {language_code}). Building.")
        try:
            menu = Menu.objects.get(slug=menu_slug)
            
            # Fetch ALL menu items for this menu. 
            # We need them all to attach dynamic children to parents properly.
            all_menu_items = list(menu.items.all().order_by('tree_id', 'lft'))
            
            # --- ATTACH DYNAMIC CHILDREN LOGIC ---
            # This loop attaches 'dynamic_children' to the relevant parent MenuItem instances,
            # which will be used by the template during rendering.
            for item_obj in all_menu_items: 
                item_obj.dynamic_children = [] # Initialize for all items

                blog_cat_limit = getattr(SiteConfiguration.get_solo(), 'blog_items_per_page', 9) if SiteConfiguration else 9
                important_pages_limit = getattr(SiteConfiguration.get_solo(), 'search_importance_limit', 3) if SiteConfiguration else 3

                if item_obj.link_type == MenuItem.LinkType.ALL_BLOG_CATEGORIES:
                    blog_categories = Category.objects.annotate(
                        num_blog_posts=Count('blog_posts', filter=Q(blog_posts__status='published'))
                    ).filter(num_blog_posts__gt=0).order_by('tree_id', 'lft')
                    item_obj.dynamic_children = list(blog_categories[:blog_cat_limit])

                elif item_obj.link_type == MenuItem.LinkType.IMPORTANT_PAGES:
                    important_pages_qs = Page.objects.filter(
                        status='published', 
                        importance_order__lt=99
                    ).order_by('importance_order', 'title')
                    item_obj.dynamic_children = list(important_pages_qs[:important_pages_limit])

            # Now, filter for only the top-level nodes (level 0) for the main navbar.
            # The children will be accessed in the template using .children.all() and .dynamic_children
            # on these top-level nodes.
            raw_top_level_nodes = [item for item in all_menu_items if item.level == 0]

            # Get cache timeout and set cache.
            try:
                config = SiteConfiguration.get_solo()
                timeout = config.menu_cache_timeout
            except SiteConfiguration.DoesNotExist:
                timeout = 3600
            
            cache.set(cache_key, raw_top_level_nodes, timeout) # Cache only top-level nodes for efficiency
            top_level_nodes = raw_top_level_nodes
            
        except Menu.DoesNotExist:
            logger.warning(f"Menu with slug '{menu_slug}' does not exist.")
            top_level_nodes = [] # Return empty list if menu does not exist
    else:
        logger.debug(f"CACHE HIT for main level menu '{menu_slug}' (lang: {language_code}). Serving from cache.")
            
    return {'nodes': top_level_nodes} # Pass only top-level nodes to _navbar_main_level.html



# --- show_social_links_menu ---
@register.inclusion_tag('menus/partials/_social_links_partial.html', takes_context=True)
def show_social_links_menu(context):
    """
    Renders the social media links menu.
    It's a simplified version of show_menu for a fixed slug 'social-links'.
    """
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'social_links_menu_{language_code}_v1'
    
    menu_items_processed = cache.get(cache_key)

    if menu_items_processed is None:
        logger.info(f"CACHE MISS for 'social-links' menu (lang: {language_code}). Querying database.")
        
        try:
            from site_settings.models import SiteConfiguration # Import here
            timeout = SiteConfiguration.get_solo().menu_cache_timeout
        except (ImportError, SiteConfiguration.DoesNotExist):
            timeout = 3600 # Fallback

        try:
            menu = Menu.objects.get(slug='social-links')
            menu_items_processed = list(menu.items.all()) # Simple list of items for social links

            if timeout > 0:
                cache.set(cache_key, menu_items_processed, timeout)

        except Menu.DoesNotExist:
            logger.warning("Menu with slug 'social-links' does not exist. Cannot display social media icons.")
            menu_items_processed = []
    else:
        logger.debug(f"CACHE HIT for 'social-links' menu (lang: {language_code}). Serving from cache.")

    return {'nodes': menu_items_processed}===== ./menus/templates/menus/menu_page.html =====
<!-- File: menus/templates/menus/menu_page.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load menu_tags %}

{% block title %}Menu Test Page{% endblock %}

{% block content %}
    <h1>Visualización del Menú Principal</h1>
    {% render_menu_tree 'main-menu' %}
{% endblock %}===== ./menus/templates/menus/partials/_navbar_menu_children.html =====
<!-- File: menus/templates/menus/partials/_navbar_menu_children.html -->
{% for node in nodes %}
    {% with children=node.children.all %}
        {% if children %}
            <li class="dropend">
                <a class="dropdown-item dropdown-toggle" href="#" id="submenu-{{ node.id }}" data-bs-toggle="dropdown" aria-expanded="false">{{ node.title }}</a>
                <ul class="dropdown-menu" aria-labelledby="submenu-{{ node.id }}">
                    {# Recursion! #}
                    {% include "menus/partials/_navbar_menu_children.html" with nodes=children %}
                </ul>
            </li>
        {% else %}
            <li><a class="dropdown-item" href="{{ node.get_url }}">{{ node.title }}</a></li>
        {% endif %}
    {% endwith %}
{% endfor %}===== ./menus/templates/menus/partials/_social_links_partial.html =====
<!-- File: menus/templates/menus/partials/_social_links_partial.html -->
{% load i18n %}

{# This partial renders a list of social media links without dropdowns #}
{% for node in nodes %}
    <a href="{{ node.get_url }}" target="_blank" rel="noopener noreferrer" class="text-secondary fs-5 mx-2" title="{{ node.title }}">
        {% if node.icon_class %}
            <i class="{{ node.icon_class }}"></i>
        {% else %}
            {# Fallback to title if no icon is specified #}
            {{ node.title }} 
        {% endif %}
    </a>
{% endfor %}===== ./menus/templates/menus/partials/_navbar_recursive.html =====
<!-- File: menus/templates/menus/partials/_navbar_recursive.html -->
{% load i18n %}
{% load mptt_tags %} {# Needed for recursetree #}

{% recursetree nodes %}
    {# Check if this item IS a dropdown (has static children OR dynamic children) #}
    {% with has_children=not node.is_leaf_node or node.dynamic_children %}

        {% if has_children %}
            {# This node is a dropdown (has direct MPTT children or dynamic children) #}
            <li class="{% if node.level == 0 %}dropdown{% else %}dropend{% endif %}">
                <a class="dropdown-item {% if not node.parent %}nav-link{% endif %} dropdown-toggle" 
                   href="#" 
                   id="{% if node.level == 0 %}navbar-item-{% else %}submenu-item-{% endif %}{{ node.id }}" 
                   role="button" data-bs-toggle="dropdown" aria-expanded="false">
                    {% if note.icon_class %}<i class="{{ node.icon_class }} me-1"></i>{% endif %}
                    {{ node.title }}
                </a>
                <ul class="dropdown-menu {% if node.level > 0 %}dropdown-submenu{% endif %}" 
                    aria-labelledby="{% if node.level == 0 %}navbar-item-{% else %}submenu-item-{% endif %}{{ node.id %}">
                    
                    {# Render STATIC MPTT Children #}
                    {# {{ children }} is provided by recursetree for MPTT children #}
                    {{ children }}

                    {# Render DYNAMIC Children #}
                    {% for dynamic_child in node.dynamic_children %}
                        <li><a class="dropdown-item" href="{{ dynamic_child.get_absolute_url }}">{{ dynamic_child.name|default:dynamic_child.title }}</a></li>
                    {% endfor %}
                </ul>
            </li>
        {% else %}
            {# This node is a simple link (no children) #}
            <li>
                <a class="dropdown-item" href="{{ node.get_url }}">
                    {% if node.icon_class %}<i class="{{ node.icon_class }} me-1"></i>{% endif %}
                    {{ node.title }}
                </a>
            </li>
        {% endif %}
    {% endwith %}
{% endfor %}===== ./menus/templates/menus/partials/_navbar_main_level.html =====
<!-- File: menus/templates/menus/partials/_navbar_main_level.html -->
{% load menu_tags %} 
{% load i18n %}

{# This template receives 'nodes' which are ONLY the top-level (level=0) MenuItem objects. #}
{# It renders the initial <li> containers for the main navbar. #}

{% for node in nodes %}
    {% if node.level == 0 %} {# Process only top-level items in this template #}
        {# Direct evaluation of conditions for dropdown type #}
        {% if not node.is_leaf_node or node.dynamic_children %} {# <--- CORREGIDO #}
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" id="navbar-item-{{ node.id }}" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                    {% if node.icon_class %}<i class="{{ node.icon_class }} me-1"></i>{% endif %}
                    {{ node.title }}
                </a>
                <ul class="dropdown-menu" aria-labelledby="navbar-item-{{ node.id }}">
                    {# Render static children #}
                    {% if not node.is_leaf_node %} {# <--- Use this condition #}
                        {% include "menus/partials/_navbar_recursive_children.html" with parent_node=node %}
                    {% endif %}
                    {# Render dynamic children #}
                    {% for dynamic_child in node.dynamic_children %}
                        <li><a class="dropdown-item" href="{{ dynamic_child.get_absolute_url }}">{{ dynamic_child.name|default:dynamic_child.title }}</a></li>
                    {% endfor %}
                </ul>
            </li>
        {% else %}
            {# Simple link for top-level item with no children #}
            <li class="nav-item">
                <a class="nav-link" href="{{ node.get_url }}">
                    {% if node.icon_class %}<i class="{{ node.icon_class }} me-1"></i>{% endif %}
                    {{ node.title }}
                </a>
            </li>
        {% endif %}
    {% endif %} {# End if node.level == 0 #}
{% endfor %}===== ./menus/templates/menus/partials/_navbar_recursive_children.html =====
<!-- File: menus/templates/menus/partials/_navbar_recursive_children.html -->
{% load menu_tags %} 
{% load i18n %}

{# This partial renders the *immediate children* of 'parent_node' within a dropdown menu. #}
{# It's designed to be called recursively for deeper levels. #}
{% for node in parent_node.children.all %}
    {# Check if this child node also has children (static MPTT children OR dynamic children) #}
    {% if not node.is_leaf_node or node.dynamic_children %} {# <--- CORREGIDO #}
        <li class="dropend"> 
            <a class="dropdown-item dropdown-toggle" href="#" id="submenu-item-{{ node.id }}" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                {% if node.icon_class %}<i class="{{ node.icon_class }} me-1"></i>{% endif %}
                {{ node.title }}
            </a>
            <ul class="dropdown-menu dropdown-submenu" aria-labelledby="submenu-item-{{ node.id }}">
                {# RECURSION: Call this same partial again for this node's children #}
                {% if not node.is_leaf_node %} {# <--- Use this condition #}
                    {% include "menus/partials/_navbar_recursive_children.html" with parent_node=node %}
                {% endif %}
                {% for dynamic_child in node.dynamic_children %}
                    <li><a class="dropdown-item" href="{{ dynamic_child.get_absolute_url }}">{{ dynamic_child.name|default:dynamic_child.title }}</a></li>
                {% endfor %}
            </ul>
        </li>
    {% else %}
        {# Simple link within a dropdown #}
        <li>
            <a class="dropdown-item" href="{{ node.get_url }}">
                {% if node.icon_class %}<i class="{{ node.icon_class }} me-1"></i>{% endif %}
                {{ node.title }}
            </a>
        </li>
    {% endif %}
{% endfor %}

{# Render Dynamic Children after static ones #}
{% for dynamic_child in parent_node.dynamic_children %}
    <li><a class="dropdown-item" href="{{ dynamic_child.get_absolute_url }}">{{ dynamic_child.name|default:dynamic_child.title }}</a></li>
{% endfor %}===== ./menus/templates/menus/social_links_menu.html =====
<!-- File: menus/templates/menus/social_links_menu.html -->
{% for item in menu_items %}
    <a href="{{ item.get_url }}" target="_blank" rel="noopener noreferrer" class="text-secondary fs-5 mx-2" title="{{ item.title }}">
        {% if item.icon_class %}
            <i class="{{ item.icon_class }}"></i>
        {% else %}
            {{ item.title }} {# Fallback por si no hay icono #}
        {% endif %}
    </a>
{% endfor %}===== ./menus/__init__.py =====
===== ./blog/signals.py =====
# File: blog/signals.py
import logging
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.contrib.auth.models import User # For promoting trusted commenters
from django.conf import settings 

from .models import Post, Comment # Import Post and Comment for sender
from site_settings.models import SiteConfiguration # For cache timeouts and threshold from SiteConfiguration


logger = logging.getLogger(__name__)


# --- Signal to clear Widget caches on Post changes ---
@receiver([post_save, post_delete], sender=Post)
def clear_widget_caches_on_post_change(sender, instance, **kwargs):
    """
    Clears all widget caches related to posts whenever a Post is saved or deleted.
    This ensures that 'Recent Posts', 'Most Viewed', 'Editor's Picks' widgets are updated.
    """
    # Import Widget model specifically here to avoid circular dependency issues at startup
    from widgets.models import Widget 
    num_widgets_cleared = 0
    # A simple but effective strategy: clear ALL widget caches.
    # We iterate over all widgets that deal with posts.
    relevant_widget_types = ['recent_posts', 'tag_cloud_widget', 'most_viewed_posts', 'most_commented_posts', 'editor_picks_posts'] # Add other post-related widgets
    
    for widget in Widget.objects.filter(widget_type__in=relevant_widget_types): # Filter to relevant ones
        for lang_code, _ in settings.LANGUAGES: # Clear for each language
            cache_key = f'widget_items_{widget.id}_{lang_code}_v1' # Use 'v1'
            cache.delete(cache_key)
            num_widgets_cleared += 1
    logger.info(f"Cleared {num_widgets_cleared} widget caches due to Post change (ID: {instance.id}).")


# --- Signal for User Promotion to Trusted Commenter ---
@receiver(post_save, sender=Comment)
def promote_user_on_comment_approval(sender, instance, created, **kwargs):
    """
    Promotes a user to 'Trusted Commenter' status if they reach the configured
    threshold of approved comments. This signal runs when a Comment is saved.
    """
    # Only proceed if the comment is approved AND it's made by a registered user.
    if instance.is_approved and instance.user:
        try:
            # We import User's Profile here to avoid circular dependency at startup
            from accounts.models import Profile 
            user_profile = Profile.objects.get(user=instance.user)
            
            # Only promote if the user is not already trusted.
            if not user_profile.is_trusted_commenter:

                site_config = SiteConfiguration.get_solo()
                approval_threshold = getattr(site_config, 'trusted_commenter_threshold', 10) # Fallback to 10


                # Count all approved comments by this user.
                approved_comment_count = Comment.objects.filter(
                    user=instance.user, 
                    is_approved=True
                ).count()
                
                if approved_comment_count >= approval_threshold:
                    user_profile.is_trusted_commenter = True
                    user_profile.save(update_fields=['is_trusted_commenter'])
                    logger.info(f"User '{instance.user.username}' auto-promoted to Trusted Commenter (threshold: {approval_threshold} comments).")
        
        except Profile.DoesNotExist:
            logger.warning(f"Comment from user '{instance.user.username}' (ID: {instance.user.id}) has no associated Profile. Cannot check trusted status.")
        except Exception as e:
            logger.error(f"Unexpected error in promote_user_on_comment_approval for user '{instance.user.username}': {e}", exc_info=True)===== ./blog/views.py =====
import logging
from django.contrib import messages
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.db.models import F
from django.http import HttpResponseRedirect
from django.shortcuts import render, get_object_or_404
from django.utils.translation import gettext

from .forms import CommentForm
from .models import Post, Comment
from categories.models import Category
from site_settings.models import SiteConfiguration
from taggit.models import Tag

logger = logging.getLogger(__name__)

def posts_by_tag_view(request, tag_slug):
    """
    Displays a paginated list of published posts associated with a specific tag.
    """
    # 1. Get the Tag object by slug, or return a 404
    tag = get_object_or_404(Tag, slug=tag_slug)

    # 2. Get all published posts associated with this tag
    all_posts_by_tag = Post.objects.filter(
        status='published', tags__slug=tag_slug
    ).order_by('-published_date')

    # 3. Get pagination settings
    try:
        site_config = SiteConfiguration.get_solo()
        posts_per_page = site_config.blog_items_per_page
    except SiteConfiguration.DoesNotExist:
        posts_per_page = 6
        logger.warning("SiteConfiguration not found. Using default tag pagination.")

    # 4. Apply pagination
    paginator = Paginator(all_posts_by_tag, posts_per_page)
    page_number = request.GET.get('page')

    try:
        posts = paginator.get_page(page_number)
    except PageNotAnInteger:
        posts = paginator.get_page(1)
    except EmptyPage:
        if paginator.num_pages > 0:
            posts = paginator.get_page(paginator.num_pages)
        else:
            posts = []

    logger.info(f"Posts by tag view accessed for tag '{tag_slug}'. Showing page {getattr(posts, 'number', 0)} of {getattr(posts, 'paginator.num_pages', 0)} posts.")

    context = {
        'tag': tag,
        'posts': posts,
    }
    return render(request, 'blog/post_list_by_tag.html', context)

def post_list_view(request):
    """
    Displays a list of published blog posts, paginated.
    """
    # 1. Retrieve the full, ordered list of all published posts.
    all_posts = Post.objects.filter(status='published').order_by('-published_date')

    # 2. Create a Paginator instance.
    #    We'll show 6 posts per page. This number can be changed easily.
    try:
        config = SiteConfiguration.get_solo()
        posts_per_page = config.blog_items_per_page
    except SiteConfiguration.DoesNotExist:
        logger.warning(
                "SiteConfiguration does not exist. Using default indentation."
            )
        posts_per_page = 6  # Fallback
    paginator = Paginator(all_posts, posts_per_page)

    # 3. Get the page number from the URL's GET parameters (e.g., /blog/?page=2).
    page_number = request.GET.get('page')

    # 4. Get the specific Page object for the requested page number.
    #    This includes robust error handling.
    try:
        posts = paginator.page(page_number)
    except PageNotAnInteger:
        logger.info(
                "If the 'page' parameter is not an integer, deliver the first page."
            )
        posts = paginator.page(1)
    except EmptyPage:
        logger.isEnabledFor(
                "If the page number is out of range (e.g., 999), deliver the last page."
            )
        posts = paginator.page(paginator.num_pages)

    # 5. Prepare the context to be passed to the template.
    #    The 'posts' variable is now a Paginator's Page object, not a simple list.
    context = {
        'posts': posts,
    }

    # 6. Render the template with the provided context.
    return render(request, 'blog/post_list.html', context)

def post_detail_view(request, year, month, day, slug):
    """
    Displays a single blog post and handles the entire comment submission process,
    including view counting, smart comment approval, and user association.
    """
    # 1. Retrieve the Post and Site Configuration objects.
    # ----------------------------------------------------
    post = get_object_or_404(Post,
                             status='published',
                             published_date__year=year,
                             published_date__month=month,
                             published_date__day=day,
                             slug=slug)

    try:
        site_config = SiteConfiguration.get_solo()
    except SiteConfiguration.DoesNotExist:
        logger.error("CRITICAL: SiteConfiguration object not found. Site may not function correctly.")
        # Create a fallback object to prevent crashes.
        class FallbackConfig:
            auto_approve_comments = False
        site_config = FallbackConfig()

    # 2. Increment the View Count.
    # ---------------------------------
    post.views_count = F('views_count') + 1
    post.save(update_fields=['views_count'])
    post.refresh_from_db()

    # 3. Handle Comment Submission and Retrieval.
    # -------------------------------------------
    comments = post.comments.filter(is_approved=True)

    if request.method == 'POST':
        comment_form = CommentForm(request.POST, user=request.user)
        if comment_form.is_valid():
            new_comment = comment_form.save(commit=False)
            new_comment.post = post
            
            # --- Smart Approval Logic ---
            is_trusted = False
            if request.user.is_authenticated:
                new_comment.user = request.user
                new_comment.author_name = request.user.profile.get_display_name()
                new_comment.author_email = request.user.email
                # Check if the user has been promoted to 'Trusted'.
                is_trusted = request.user.profile.is_trusted_commenter
            
            # Approve the comment if global auto-approval is ON, OR if the specific user is trusted.
            if site_config.auto_approve_comments or is_trusted:
                new_comment.is_approved = True
                success_message = gettext("Thank you! Your comment has been published.")
                if is_trusted and not site_config.auto_approve_comments:
                    logger.info(f"Comment from trusted user '{request.user.username}' was auto-approved.")
            else:
                new_comment.is_approved = False
                success_message = gettext("Thank you! Your comment has been submitted and is awaiting moderation.")

            new_comment.save()
            messages.success(request, success_message)
            
            # Redirect using the Post/Redirect/Get pattern.
            post_url = post.get_absolute_url()
            redirect_url = f"{post_url}#comments-section"
            return HttpResponseRedirect(redirect_url)
        else:
            logger.warning(f"Invalid comment submission on post '{post.slug}'. Errors: {comment_form.errors.as_json()}")
    else:
        # For a GET request, create a blank form instance.
        comment_form = CommentForm(user=request.user)

    # 4. Prepare the final context for the template.
    # ----------------------------------------------------
    context = {
        'post': post,
        'comments': comments,
        'comment_form': comment_form,
        'translatable_object': post,
    }
    return render(request, 'blog/post_detail.html', context)

def posts_by_category_view(request, category_slug):
    """
    Filters and displays a paginated list of published posts
    belonging to a specific blog category.
    """
    # --- 1. Get Base Data ---
    category = get_object_or_404(Category, slug=category_slug)
    all_posts_in_category = category.blog_posts.filter(status='published').order_by('-published_date')

    # --- 2. Get Pagination Settings ---
    try:
        config = SiteConfiguration.get_solo()
        posts_per_page = config.blog_items_per_page
    except SiteConfiguration.DoesNotExist:
        logger.warning(
            "SiteConfiguration does not exist. Using default pagination settings."
        )
        posts_per_page = 6  # Fallback

    # --- 3. Apply Pagination ---
    paginator = Paginator(all_posts_in_category, posts_per_page)
    page_number = request.GET.get('page')

    try:
        posts = paginator.page(page_number)
    except PageNotAnInteger:
        # If the 'page' parameter is not an integer, deliver the first page.
        logger.info("Page number is not an integer, delivering the first page.")
        posts = paginator.page(1)
    except EmptyPage:
        # If the page number is out of range (e.g., 999), deliver the last page.
        logger.info("Page number is out of range, delivering the last page.")
        posts = paginator.page(paginator.num_pages)

    # --- 4. Prepare Context and Render ---
    context = {
        'category': category,
        'posts': posts,  # Pass the paginated 'posts' object
    }
    return render(request, 'blog/post_list_by_category.html', context)

===== ./blog/translation.py =====
# File: blog/translation.py
from modeltranslation.translator import register, TranslationOptions
# Solo importamos los modelos que SÍ existen en blog.models
from .models import Post, Comment 
from taggit.models import Tag 

# La clase para PostCategory ha sido eliminada.

@register(Post)
class PostTranslationOptions(TranslationOptions):
    fields = ('title', 'slug', 'content', 'meta_title', 'meta_description')

@register(Comment)
class CommentTranslationOptions(TranslationOptions):
    fields = ('content',)

@register(Tag)
class TagTranslationOptions(TranslationOptions):
    """
    Registers django-taggit's Tag model for translation,
    making tag names multilingual.
    """
    fields = ('name',)===== ./blog/urls.py =====
# blog/urls.py
from django.urls import path
from . import views

# Esto es importante para evitar colisiones de nombres de URL con otras apps
app_name = 'blog'

urlpatterns = [
    # 1. La URL raíz del blog, que mostrará la lista de posts
    # Ejemplo: /blog/
    path('', views.post_list_view, name='post_list'),

    # ¡NUEVA RUTA! Para listar posts de una categoría específica
    # Ejemplo: /blog/category/desarrollo-web/
    path('category/<slug:category_slug>/', views.posts_by_category_view, name='posts_by_category'),
    path('tag/<slug:tag_slug>/', views.posts_by_tag_view, name='posts_by_tag'),
    # 2. La URL para un post individual, usando año, mes, día y slug
    # Ejemplo: /blog/2025/06/15/mi-primer-post/
    path('<int:year>/<int:month>/<int:day>/<slug:slug>/', views.post_detail_view, name='post_detail'),
]===== ./blog/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
import django.utils.timezone
import mptt.fields
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('categories', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Post',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=250, verbose_name='Title')),
                ('title_es', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_en', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_ca', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('slug', models.SlugField(max_length=250, unique_for_date='published_date', verbose_name='Slug')),
                ('slug_es', models.SlugField(max_length=250, null=True, unique_for_date='published_date', verbose_name='Slug')),
                ('slug_en', models.SlugField(max_length=250, null=True, unique_for_date='published_date', verbose_name='Slug')),
                ('slug_ca', models.SlugField(max_length=250, null=True, unique_for_date='published_date', verbose_name='Slug')),
                ('content', models.TextField(verbose_name='Content')),
                ('content_es', models.TextField(null=True, verbose_name='Content')),
                ('content_en', models.TextField(null=True, verbose_name='Content')),
                ('content_ca', models.TextField(null=True, verbose_name='Content')),
                ('featured_image', models.ImageField(blank=True, null=True, upload_to='blog/featured/%Y/%m/%d/', verbose_name='Featured Image')),
                ('published_date', models.DateTimeField(default=django.utils.timezone.now, verbose_name='Published Date')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('published', 'Published')], default='draft', max_length=10, verbose_name='Status')),
                ('meta_title', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_es', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_en', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_ca', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_description', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_es', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_en', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_ca', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('views_count', models.PositiveIntegerField(default=0, verbose_name='View Count')),
                ('editor_rating', models.PositiveIntegerField(default=0, help_text='A score from 0-100 to feature this post. Higher numbers appear first.', verbose_name="Editor's Rating")),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='blog_posts', to=settings.AUTH_USER_MODEL, verbose_name='Author')),
                ('categories', models.ManyToManyField(blank=True, related_name='blog_posts', to='categories.category', verbose_name='Categories')),
            ],
            options={
                'verbose_name': 'blog post',
                'verbose_name_plural': 'blog posts',
                'ordering': ('-published_date',),
            },
        ),
        migrations.CreateModel(
            name='Comment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('author_name', models.CharField(blank=True, max_length=100, verbose_name='Author Name')),
                ('author_email', models.EmailField(blank=True, max_length=254, verbose_name='Author Email')),
                ('content', models.TextField(verbose_name='Content')),
                ('content_es', models.TextField(null=True, verbose_name='Content')),
                ('content_en', models.TextField(null=True, verbose_name='Content')),
                ('content_ca', models.TextField(null=True, verbose_name='Content')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Created At')),
                ('is_approved', models.BooleanField(default=False, verbose_name='Is Approved?')),
                ('lft', models.PositiveIntegerField(editable=False)),
                ('rght', models.PositiveIntegerField(editable=False)),
                ('tree_id', models.PositiveIntegerField(db_index=True, editable=False)),
                ('level', models.PositiveIntegerField(editable=False)),
                ('parent', mptt.fields.TreeForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='blog.comment', verbose_name='Parent Comment')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='comments_made', to=settings.AUTH_USER_MODEL, verbose_name='User')),
                ('post', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='comments', to='blog.post', verbose_name='Post')),
            ],
            options={
                'verbose_name': 'comment',
                'verbose_name_plural': 'comments',
            },
        ),
    ]
===== ./blog/migrations/0002_post_tags.py =====
# Generated by Django 5.2.3 on 2025-06-22 13:21

import taggit.managers
from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('blog', '0001_initial'),
        ('taggit', '0006_rename_taggeditem_content_type_object_id_taggit_tagg_content_8fc721_idx'),
    ]

    operations = [
        migrations.AddField(
            model_name='post',
            name='tags',
            field=taggit.managers.TaggableManager(blank=True, help_text='A comma-separated list of tags.', through='taggit.TaggedItem', to='taggit.Tag', verbose_name='Tags'),
        ),
    ]
===== ./blog/migrations/__init__.py =====
===== ./blog/forms.py =====
# File: blog/forms.py
import logging
from django import forms
from django.utils.translation import gettext_lazy as _
from .models import Comment

# Get a logger instance for this module
logger = logging.getLogger(__name__)

class CommentForm(forms.ModelForm):
    """
    A form for users to submit comments.
    It dynamically adjusts fields based on whether the user is authenticated.
    """

    class Meta:
        model = Comment
        # The user will fill out these fields.
        # 'parent' is for handling replies and will be a hidden field.
        # 'user' and 'post' will be assigned in the view.
        fields = ['content', 'parent', 'author_name', 'author_email']
        
        # We use a HiddenInput for the 'parent' field. Its value will be set by JavaScript.
        widgets = {
            'parent': forms.HiddenInput(),
        }


    def __init__(self, *args, **kwargs):
        # We pop the 'user' object passed from the view.
        # It will be None if the user is not authenticated.
        self.user = kwargs.pop('user', None)
        super().__init__(*args, **kwargs)

        # --- Customize fields with Bootstrap classes and placeholders ---
        self.fields['content'].widget = forms.Textarea(attrs={
            'class': 'form-control', 
            'rows': 4,
            'placeholder': _('Write your comment here...')
        })
        self.fields['author_name'].widget = forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': _('Your Name (required)')
        })
        self.fields['author_email'].widget = forms.EmailInput(attrs={
            'class': 'form-control',
            'placeholder': _('Your Email (required, not published)')
        })
        
        # --- Dynamic field logic based on user authentication ---
        if self.user and self.user.is_authenticated:
            # If the user is logged in, we don't need them to enter their name and email.
            # We hide these fields and make them not required.
            self.fields['author_name'].required = False
            self.fields['author_email'].required = False
            
            # Instead of removing them, we turn them into hidden fields.
            # This way, the view can still populate them with the user's data for consistency.
            self.fields['author_name'].widget = forms.HiddenInput()
            self.fields['author_email'].widget = forms.HiddenInput()
            
            # Log that we are customizing the form for a logged-in user.
            logger.debug(f"Customizing CommentForm for authenticated user: {self.user.username}")


    def clean(self):
        # We log form errors to help with debugging validation issues.
        if self.errors:
            logger.warning(f"CommentForm validation failed. Errors: {self.errors.as_json()}")
        return super().clean()===== ./blog/models.py =====
# File: blog/models.py
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from mptt.models import MPTTModel, TreeForeignKey
from categories.models import Category 
from taggit.managers import TaggableManager
from django.utils.translation import override 

class Post(models.Model):
    """ Represents a single blog post. """

    class Status(models.TextChoices):
        DRAFT = 'draft', _('Draft')
        PUBLISHED = 'published', _('Published')
        
    title = models.CharField(max_length=250, verbose_name=_("Title"))
    slug = models.SlugField(max_length=250, unique_for_date='published_date', verbose_name=_("Slug"))
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='blog_posts', verbose_name=_("Author"))
    
    content = models.TextField(verbose_name=_("Content"))
    featured_image = models.ImageField(
        upload_to='blog/featured/%Y/%m/%d/', 
        blank=True, 
        null=True, 
        verbose_name=_("Featured Image")
    )
    
    published_date = models.DateTimeField(default=timezone.now, verbose_name=_("Published Date"))
    status = models.CharField(max_length=10, choices=Status.choices, default=Status.DRAFT, verbose_name=_("Status"))
    
    # --- CORRECTED CATEGORY RELATIONSHIP ---
    # Using a ManyToManyField is simpler and more efficient for querying than GenericRelation.
    categories = models.ManyToManyField(
        Category,
        blank=True,
        verbose_name=_("Categories"),
        related_name="blog_posts"
    )

    # --- SEO and Curation Fields ---
    meta_title = models.CharField(max_length=70, blank=True, null=True, verbose_name=_("Meta Title (SEO)"))
    meta_description = models.CharField(max_length=160, blank=True, null=True, verbose_name=_("Meta Description (SEO)"))
    views_count = models.PositiveIntegerField(default=0, verbose_name=_("View Count"))
    editor_rating = models.PositiveIntegerField(
        default=0,
        verbose_name=_("Editor's Rating"),
        help_text=_("A score from 0-100 to feature this post. Higher numbers appear first.")
    )

    # --- Timestamps ---
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    tags = TaggableManager(
        verbose_name=_("Tags"),
        help_text=_("A comma-separated list of tags."),
        blank=True # Allows posts to have no tags
    )

    class Meta:
        ordering = ('-published_date',)
        verbose_name = _("blog post")
        verbose_name_plural = _("blog posts")

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse('blog:post_detail', args=[
            self.published_date.year,
            self.published_date.month,
            self.published_date.day,
            self.slug
        ])
    
    def get_absolute_url_for_language(self, language_code):
        with override(language_code):
            # 'self.slug' automáticamente devuelve el slug para el idioma del contexto que acabamos de setear con override.
            return reverse('blog:post_detail', args=[
                self.published_date.year,
                self.published_date.month,
                self.published_date.day,
                self.slug
            ])


class Comment(MPTTModel):
    """ Represents a single, nestable comment on a blog post. """
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments', verbose_name=_("Post"))
    parent = TreeForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, related_name='children', db_index=True, verbose_name=_("Parent Comment"))
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='comments_made', verbose_name=_("User"))
    author_name = models.CharField(max_length=100, blank=True, verbose_name=_("Author Name"))
    author_email = models.EmailField(blank=True, verbose_name=_("Author Email"))
    content = models.TextField(verbose_name=_("Content"))
    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Created At"))
    is_approved = models.BooleanField(default=False, verbose_name=_("Is Approved?"))

    class MPTTMeta:
        order_insertion_by = ['created_at']

    class Meta:
        verbose_name = _("comment")
        verbose_name_plural = _("comments")

    def __str__(self):
        return f"{'--' * self.level} Comment by {self.get_author_name()}"
    
    def get_author_name(self):
        if self.user:
            return self.user.profile.get_display_name()
        return self.author_name

    def get_author_avatar_url(self):
        from django.templatetags.static import static
        if self.user and hasattr(self.user, 'profile') and self.user.profile.avatar:
            default_paths = [c[0] for c in self.user.profile.AvatarChoice.choices]
            if self.user.profile.avatar.name not in default_paths:
                return self.user.profile.avatar.url
            return static(self.user.profile.default_avatar_choice)
        
        return static('images/avatars/default_anonymous.png')===== ./blog/apps.py =====
# File: blog/apps.py
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class BlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'blog'

    def ready(self):
        """
        Connects signals and explicitly registers ModelAdmins for third-party apps.
        """
        import blog.signals # Connects blog signals
        
        # --- Explicitly register our custom TagAdmin. ---
        try:
            from django.contrib import admin
            from taggit.models import Tag
            from .admin import TagAdmin # Import our custom TagAdmin from blog/admin.py

            # Check if default TagAdmin is already registered (it normally is by taggit).
            if admin.site.is_registered(Tag): 
                admin.site.unregister(Tag) # Unregister the default one.
                logger.info("Unregistered default Taggit TagAdmin.")
            
            # Register our custom TagAdmin.
            admin.site.register(Tag, TagAdmin) 
            logger.debug("Successfully registered custom Blog app's TagAdmin.")

        except Exception as e:
            logger.error(f"Error registering custom TagAdmin: {e}", exc_info=True)
            # Log the error but don't re-raise, so Django can continue loading other apps.
            # If this becomes a problem, consider re-raising.===== ./blog/admin.py =====
# File: blog/admin.py
import logging
from django.contrib import admin
from django.db.models import Count # Required for Count() in CommentAdmin's save_model
from django.utils.translation import gettext_lazy as _
from django.conf import settings # Required for dynamically generating search fields

# Third-party imports (ensure these are installed and in INSTALLED_APPS)
from django_summernote.admin import SummernoteModelAdmin # For WYSIWYG editor on Post
from modeltranslation.admin import TabbedTranslationAdmin # For multilingual admin
from mptt.admin import MPTTModelAdmin # For tree display on Comment
from modeltranslation.translator import translator, NotRegistered # For dynamic admin fields

# Local application imports (ensure these models exist)
from .models import Post, Comment # PostCategory is no longer in blog.models
from categories.models import Category # Universal Category model
from site_settings.models import SiteConfiguration # For configurable settings

# Import the Tag model, needed for custom TagAdmin setup
from taggit.models import Tag


logger = logging.getLogger(__name__)

# --- Helper functions for dynamic admin fields ---
# These functions are defined here to be self-contained within blog/admin.py.
# If they are used across many admin files, it's better to move them to a shared utility file (e.g., core/admin_helpers.py)
# and import them from there.

def get_language_aware_prepopulated_fields(model_kls):
    """
    Dynamically generates the prepopulated_fields dictionary for a ModelAdmin,
    considering translatable slug and title/name fields for all configured languages.
    """
    prepopulated_fields_dict = {}
    
    # Get translation options for the given model
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except NotRegistered:
        logger.warning(f"Model {model_kls.__name__} not registered for translation. "
                       f"Dynamic prepopulated_fields might be incomplete.")
        return prepopulated_fields_dict # Return empty dict if not translatable

    # Check if the model has a 'slug' field and a 'title' or 'name' field that is translatable
    has_slug = hasattr(model_kls, 'slug')
    has_translatable_title = 'title' in trans_opts.fields if trans_opts else False
    has_translatable_name = 'name' in trans_opts.fields if trans_opts else False

    if has_slug and (has_translatable_title or has_translatable_name):
        source_field_name = 'title' if has_translatable_title else 'name'
        for lang_code, _ in settings.LANGUAGES:
            # For each language, link the slug field (e.g., 'slug_en')
            # to the corresponding title/name field (e.g., 'title_en' or 'name_en').
            prepopulated_fields_dict[f'slug_{lang_code}'] = (f'{source_field_name}_{lang_code}',)
    
    # Special handling for `Menu` model where slug is not translatable but derived from a translatable title
    # This block is specific to the `Menu` model ONLY if it is included in this admin.
    # It would typically be in `menus/admin.py`, but leaving it here for completeness if needed elsewhere.
    if model_kls.__name__ == 'Menu' and has_slug and has_translatable_title:
        # Assuming 'Menu' model's slug is not translatable, but its 'title' is.
        # This will prepopulate the single 'slug' field from the title of the default language.
        prepopulated_fields_dict['slug'] = (f'title_{settings.LANGUAGE_CODE}',)

    return prepopulated_fields_dict


def get_language_aware_search_fields(model_kls, fields_to_include=None):
    """
    Dynamically generates a tuple of search fields for a model in all configured languages.
    Assumes common translatable text fields ('title', 'name', 'content', 'description').
    """
    search_fields_list = []
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except NotRegistered:
        # If the model is not registered for translation, return only basic non-translated fields if specified.
        # Or an empty tuple if no specific fields are requested.
        return (fields_to_include,) if fields_to_include else tuple()

    # Determine which translatable fields to use for search
    actual_fields_to_search = fields_to_include if fields_to_include else trans_opts.fields

    for lang_code, _ in settings.LANGUAGES:
        for field_name in actual_fields_to_search:
            if field_name in trans_opts.fields: # Ensure the field is actually translatable
                search_fields_list.append(f'{field_name}_{lang_code}')
            # If default non-translatable fields should also be included in search, add them here
            # For example: if 'id' or other non-translatable fields are in fields_to_include, add them directly.

    return tuple(search_fields_list)

class TagAdmin(TabbedTranslationAdmin): # <-- THIS IS KEY! Must inherit from TabbedTranslationAdmin
    """
    Custom Admin for Taggit's Tag model.
    It integrates modeltranslation to allow translation of tag names directly in the admin.
    """
    list_display = ('name',) # Display the 'name' field, which TabbedTranslationAdmin will handle
    list_display_links = ('name',) # Clickable by name
    ordering = ('name',) # Order by the currently active language's name

    # Search fields must target translated fields
    search_fields = get_language_aware_search_fields(Tag, fields_to_include=['name']) # Uses name_en, name_es, etc.
    
    # prepopulated_fields will use translated name fields for slug
    # Tag.slug is generally not translated, but derived from the name of the default language
    prepopulated_fields = {'slug': (f'name_{settings.LANGUAGE_CODE}',)}

    # Ensure 'name' and 'slug' fields appear in the form.
    # TabbedTranslationAdmin patches 'name' to show tabs automatically.
    fields = ('name', 'slug') # Only list 'name' and 'slug' here.


# --- ADMIN FOR BLOG POSTS ---
@admin.register(Post)
class PostAdmin(SummernoteModelAdmin, TabbedTranslationAdmin):
    """
    Admin options for the Post model, integrating Summernote for content,
    ModelTranslation for multilingual fields, and managing categories via ManyToMany.
    """
    list_display = ('title', 'author', 'status', 'published_date', 'views_count', 'editor_rating', 'display_categories_list')
    list_filter = ('status', 'published_date', 'author')
    date_hierarchy = 'published_date'
    ordering = ('status', '-published_date')
    list_editable = ('status', 'editor_rating')
    
    # Dynamically generate search_fields using the helper function for 'title' and 'content'
    search_fields = get_language_aware_search_fields(Post, fields_to_include=['title', 'content'])

    # Dynamically generate prepopulated_fields for slugs in all languages.
    # Assumes 'Post.slug' is translatable AND 'Post.title' is translatable.
    prepopulated_fields = get_language_aware_prepopulated_fields(Post)

    # Summernote fields must be specified for each language (e.g., 'content_en')
    summernote_fields = tuple([f'content_{lang_code}' for lang_code, _ in settings.LANGUAGES])
    
    # ManyToManyField for categories, uses a nice multi-selector interface
    filter_horizontal = ('categories',) 

    # Custom method to display categories in the list view
    @admin.display(description=_("Categories"))
    def display_categories_list(self, obj):
        return ", ".join([cat.name for cat in obj.categories.all()])


# --- ADMIN FOR COMMENTS ---
@admin.register(Comment)
class CommentAdmin(MPTTModelAdmin):
    """
    Admin options for the Comment model.
    Uses MPTTModelAdmin for tree display and includes logic for user promotion.
    """
    list_display = ('__str__', 'post', 'author_name', 'created_at', 'is_approved')
    list_display_links = ('__str__',)
    list_filter = ('is_approved', 'created_at', 'post')
    list_editable = ('is_approved',)
    search_fields = ('content', 'author_name', 'author_email') # These are typically not translatable
    readonly_fields = ('post', 'parent', 'user', 'author_name', 'author_email', 'content', 'created_at')
    
    @property
    def mptt_level_indent(self):
        try:
            return SiteConfiguration.get_solo().comment_indentation_pixels
        except SiteConfiguration.DoesNotExist:
            logger.warning("SiteConfiguration not found. Using default mptt_level_indent of 20.")
            return 20

    def save_model(self, request, obj, form, change):
        """
        Custom save logic to auto-promote users to 'Trusted Commenter' status
        when their comments are approved.
        """
        super().save_model(request, obj, form, change)
        
        if 'is_approved' in form.changed_data and obj.is_approved and obj.user:
            try:
                user_profile = obj.user.profile
                if not user_profile.is_trusted_commenter:
                    try:
                        config = SiteConfiguration.get_solo()
                        approval_threshold = config.trusted_commenter_threshold
                    except SiteConfiguration.DoesNotExist:
                        approval_threshold = 10 
                        logger.warning("SiteConfiguration not found. Using default commenter threshold of 10.")
                    
                    approved_comment_count = Comment.objects.filter(user=obj.user, is_approved=True).count()
                    
                    if approved_comment_count >= approval_threshold:
                        user_profile.is_trusted_commenter = True
                        user_profile.save(update_fields=['is_trusted_commenter'])
                        logger.info(f"User '{obj.user.username}' auto-promoted to Trusted Commenter.")
            except Exception as e:
                logger.error(f"Error during user promotion logic for user '{obj.user.username}': {e}", exc_info=True)===== ./blog/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./blog/templates/blog/post_list_by_category.html =====
{% extends 'core/base.html' %}
{% load i18n %}
{% load widget_tags %}

{# --- SEO and Browser Tab Title Blocks --- #}
{# Use the category's SEO fields, with its name as a fallback. #}
{% block seo_title %}{{ category.meta_title|default:category.name }}{% endblock %}
{% block seo_description %}{{ category.meta_description|default:"" }}{% endblock %}

{# This sets the browser tab's title. #}
{% block title %}{% blocktranslate %}Posts in {{ category.name }}{% endblocktranslate %}{% endblock %}


{% block content %}
<div class="container mt-5">
    
    {# --- Category Page Header --- #}
    <div class="category-header mb-5 text-center">
        <h1 class="display-4">
            {# The main visible title of the page, including the category name. #}
            {% blocktranslate %}
                Posts in category: <span class="text-primary">{{ category.name }}</span>
            {% endblocktranslate %}
        </h1>
        {# Display the category description if it exists (it's a multilingual field). #}
        {% if category.description %}
            <p class="lead text-muted">{{ category.description }}</p>
        {% endif %}
    </div>

    {# --- Grid of Posts --- #}
    <div class="row">
        {# Loop through the 'posts' object, which is a paginated list from the view. #}
        {% for post in posts %}
            <div class="col-md-6 col-lg-4 mb-4">
                <div class="card h-100 shadow-sm border-0">
                    {# Display the featured image, linking to the post detail view. #}
                    {% if post.featured_image %}
                        <a href="{{ post.get_absolute_url }}">
                            <img src="{{ post.featured_image.url }}" class="card-img-top" loading="lazy" alt="{{ post.title }}">
                        </a>
                    {% endif %}
                    <div class="card-body d-flex flex-column">
                        <h5 class="card-title">{{ post.title }}</h5>
                        <p class="card-text text-muted">
                            {# Post metadata line, fully internationalized. #}
                            {% firstof post.author.get_full_name post.author.username as author_name %}
                            <small>
                                {% blocktranslate with published_date=post.published_date|date:"DATE_FORMAT" author=author_name %}
                                    Published on {{ published_date }} by {{ author }}
                                {% endblocktranslate %}
                            </small>
                        </p>
                        {# "Read More" button linking to the post's detail view. #}
                        <a href="{{ post.get_absolute_url }}" class="btn btn-primary mt-auto">{% translate "Read More" %}</a>
                    </div>
                </div>
            </div>
        {% empty %}
            {# This message is displayed if no posts are found in this category. #}
            <div class="col">
                <div class="alert alert-info" role="alert">
                    {% translate "There are currently no published posts in this category." %}
                </div>
            </div>
        {% endfor %}
    </div>

    {# --- PAGINATION --- #}
    {# We include our single, centralized pagination component from the 'core' app. #}
    {# The component will automatically use '?page=' as the parameter name. #}
    {% include 'core/partials/_pagination.html' with page_obj=posts %}

</div>
{% endblock %}

{# Y si tienes sidebar izquierdo... #}
{% block sidebar_left %}
    <div class="sticky-top pt-5">
        {% show_widget_zone 'blog-sidebar-left' %}
    </div>
{% endblock %}

{% block sidebar_right %}
    <div class="sticky-top pt-5">
        {# Llamamos a la zona de widgets que hemos definido en el admin #}
        {% show_widget_zone 'blog-sidebar-right' %}
    </div>
{% endblock %}===== ./blog/templates/blog/post_detail.html =====
<!-- File: blog/templates/blog/post_detail.html -->
{% extends 'core/base.html' %}
{% load static %}
{% load i18n %}
{% load mptt_tags %}
{% load widget_tags %}

{# --- SEO and Browser Tab Title Blocks --- #}
{% block seo_title %}{{ post.meta_title|default:post.title }}{% endblock %}
{% block seo_description %}{{ post.meta_description|default:"" }}{% endblock %}
{% block title %}{{ post.title }}{% endblock %}

{# --- OVERRIDE GLOBAL MESSAGES BLOCK --- #}
{# This block is intentionally left empty to prevent messages from appearing at the top. #}
{% block messages %}{% endblock %}

{# --- Left Sidebar --- #}
{% block sidebar_left %}
    <div class="sticky-top pt-5">
        {% show_widget_zone 'blog-sidebar-left' %}
    </div>
{% endblock sidebar_left %}

{# --- Main Post Content --- #}
{% block content %}
    <div class="post-detail-container">
        <!-- 1. Post Header -->
        {% if post.featured_image %}
            <img src="{{ post.featured_image.url }}" class="img-fluid rounded mb-4 shadow" alt="{{ post.title }}">
        {% endif %}
        <h1 class="display-4 fw-bold">{{ post.title }}</h1>
        <p class="lead text-muted">
            <!-- Post Metadata -->
            {% firstof post.author.profile.get_display_name post.author.username as author_name %}
            {% blocktranslate with published_date=post.published_date|date:"DATE_FORMAT" author=author_name %}
                Published on {{ published_date }} by {{ author }}
            {% endblocktranslate %}
        </p>
        {% if post.categories.exists %}
            <div class="mb-3">
                <strong>{% translate "Categories" %}:</strong>
                {% for category in post.categories.all %}
                    <a href="{{ category.get_absolute_url }}" class="badge bg-primary text-dark text-decoration-none">
                        {{ category.name }}
                    </a>
                {% endfor %}
            </div>
        {% endif %}
        
        {% if post.tags.all %}
            <div class="mb-3">
                <strong>{% translate "Tags" %}:</strong>
                {% for tag in post.tags.all %}
                    <a href="{% url 'blog:posts_by_tag' tag.slug %}" class="badge bg-info text-white text-decoration-none">
                        {{ tag.name }}
                    </a>
                {% endfor %}
            </div>
        {% endif %}
        <hr class="my-4">
        <!-- 2. Post Body -->
        <div class="post-content fs-5">
            {{ post.content|safe }}
        </div>

        <!-- 3. Comments Section -->
        <hr class="my-5">
        <div class="comments-section">
            <h3 class="mb-4" id="comments-section">{% blocktranslate count count=comments.count %}{{ count }} Comment{% plural %}{{ count }} Comments{% endblocktranslate %}</h3>

            <ul class="list-unstyled">
                {% recursetree comments %}
                    <li class="comment-item mb-4" id="comment-{{ node.id }}">
                        <div class="d-flex">
                            <div class="flex-shrink-0">
                                <!-- DYNAMIC AVATAR -->
                                <img src="{{ node.get_author_avatar_url }}" 
                                     alt="{{ node.get_author_name }}'s Avatar"
                                     class="rounded-circle me-3" 
                                     style="width: 48px; height: 48px; object-fit: cover;">
                            </div>
                            <div class="flex-grow-1">
                                <!-- DYNAMIC AUTHOR NAME -->
                                <h6 class="mt-0 fw-bold">{{ node.get_author_name }}</h6>
                                <p class="mb-1">{{ node.content|linebreaks }}</p>
                                <small class="text-muted">
                                    {{ node.created_at|timesince }} {% translate "ago" %} - 
                                    <a href="#comment-form" class="reply-link text-decoration-none" data-comment-id="{{ node.id }}">{% translate "Reply" %}</a>
                                </small>
                            </div>
                        </div>

                        {% if not node.is_leaf_node %}
                            <ul class="list-unstyled ms-5 mt-3">
                                {{ children }}
                            </ul>
                        {% endif %}
                    </li>
                {% endrecursetree %}
            </ul>
        </div>
        
        <!-- 4. Comment Form Section -->
        <hr class="my-5">
        <div class="comment-form-section card shadow-sm border-0" id="comment-form">
            <div class="card-body p-4 p-md-5">
                <!-- Local Message Display Area -->
                {% if messages %}
                    <div class="local-messages-container mb-3">
                        {% for message in messages %}
                            <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                                {{ message }}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            </div>
                        {% endfor %}
                    </div>
                {% endif %}
                
                <h4 class="card-title" id="comment-form-title">{% translate "Leave a Comment" %}</h4>
                <form method="post" action="">
                    {% csrf_token %}
                    
                    <div class="mb-3">
                        {{ comment_form.content }}
                        {% if comment_form.content.errors %}<div class="invalid-feedback d-block">{{ comment_form.content.errors|striptags }}</div>{% endif %}
                    </div>
                    
                    <!-- Guest fields will be hidden by the form's __init__ method if the user is authenticated -->
                    <div class="row {% if user.is_authenticated %}d-none{% endif %}">
                        <div class="col-md-6 mb-3">
                            {{ comment_form.author_name }}
                            {% if comment_form.author_name.errors %}<div class="invalid-feedback d-block">{{ comment_form.author_name.errors|striptags }}</div>{% endif %}
                        </div>
                        <div class="col-md-6 mb-3">
                            {{ comment_form.author_email }}
                            {% if comment_form.author_email.errors %}<div class="invalid-feedback d-block">{{ comment_form.author_email.errors|striptags }}</div>{% endif %}
                        </div>
                    </div>
                    
                    {{ comment_form.parent }}
                    <button type="submit" class="btn btn-primary">{% translate "Submit Comment" %}</button>
                </form>
            </div>
        </div>
    </div>
{% endblock %}


{# --- Right Sidebar --- #}
{% block sidebar_right %}
    <div class="sticky-top pt-5">
        {% show_widget_zone 'blog-sidebar-right' %}
    </div>
{% endblock sidebar_right %}

{# --- Extra JavaScript for comment replies --- #}
{% block extra_js %}
<script>
    // ... [El mismo script de JavaScript que ya teníamos] ...
    document.addEventListener('DOMContentLoaded', function() {
        const replyLinks = document.querySelectorAll('.reply-link');
        const parentIdInput = document.querySelector('input[name="parent"]');
        const formTitle = document.getElementById('comment-form-title');
        const originalFormTitle = formTitle.textContent;
        const contentTextarea = document.getElementById('id_content');

        // Create the cancel button dynamically
        const cancelButton = document.createElement('button');
        cancelButton.type = 'button';
        cancelButton.id = 'cancel-reply';
        cancelButton.className = 'btn btn-sm btn-secondary ms-3';
        cancelButton.textContent = '{% translate "Cancel Reply" %}';

        replyLinks.forEach(link => {
            link.addEventListener('click', function(event) {
                event.preventDefault();
                const commentId = this.getAttribute('data-comment-id');
                const authorName = this.closest('.comment-item').querySelector('.fw-bold').textContent.trim();
                
                parentIdInput.value = commentId;
                formTitle.textContent = `{% translate "Reply to" %} ${authorName}`;
                if (!document.getElementById('cancel-reply')) {
                    formTitle.appendChild(cancelButton);
                }
                
                contentTextarea.focus();
            });
        });

        cancelButton.addEventListener('click', function() {
            parentIdInput.value = '';
            formTitle.textContent = originalFormTitle;
        });
    });
</script>
{% endblock extra_js %}===== ./blog/templates/blog/post_list.html =====
{% extends 'core/base.html' %}
{% load i18n %}
{% load widget_tags %}

{# --- SEO and Browser Tab Title Blocks --- #}
{% block seo_title %}{% translate "Our Blog" %} | Tavata.art{% endblock %}
{% block seo_description %}{% translate "Latest articles and updates on Computer Vision, Natural Language Processing, and more from the Tavata team." %}{% endblock %}
{% block title %}{% translate "Our Blog" %}{% endblock %}


{% block content %}
<div class="container mt-5">
    
    {# --- Blog Page Header --- #}
    <div class="blog-header pb-3 mb-5 text-center border-bottom">
        <h1 class="display-4">{% translate "Our Blog" %}</h1>
        <p class="lead text-muted">{% translate "News, articles, and insights from our team." %}</p>
    </div>

    {# --- Grid of Posts --- #}
    <div class="row">
        {# Loop through the 'posts' Page object from the view #}
        {% for post in posts %}
            <div class="col-md-6 col-lg-4 mb-4">
                <div class="card h-100 shadow-sm border-0">
                    {# Display the featured image if it exists #}
                    {% if post.featured_image %}
                        <a href="{{ post.get_absolute_url }}">
                            <img src="{{ post.featured_image.url }}" class="card-img-top" loading="lazy" alt="{{ post.title }}">
                        </a>
                    {% endif %}
                    <div class="card-body d-flex flex-column"> 
                        <h5 class="card-title">{{ post.title }}</h5>
                        <p class="card-text text-muted">
                            {# Post metadata, fully internationalized #}
                            {% firstof post.author.get_full_name post.author.username as author_name %}
                            <small>
                                {% blocktranslate with published_date=post.published_date|date:"DATE_FORMAT" author=author_name %}
                                    Published on {{ published_date }} by {{ author }}
                                {% endblocktranslate %}
                            </small>
                        </p>
                        <a href="{{ post.get_absolute_url }}" class="btn btn-primary mt-auto">{% translate "Read More" %}</a>
                    </div>
                </div>
            </div>
        {% empty %}
            {# This message is displayed if the 'posts' queryset is empty #}
            <div class="col">
                <div class="alert alert-info" role="alert">
                    {% translate "There are no blog posts yet. Come back soon!" %}
                </div>
            </div>
        {% endfor %}
    </div>

    {# --- PAGINATION --- #}
    {# We include our single, centralized pagination component. #}
    {# We pass the 'posts' object to the 'page_obj' variable that the component expects. #}
    {# Since this is a simple list, we don't need to pass a 'param_name'. It will default to 'page'. #}
    {% include 'core/partials/_pagination.html' with page_obj=posts %}

</div>
{% endblock %}


{# Y si tienes sidebar izquierdo... #}
{% block sidebar_left %}
    <div class="sticky-top pt-5">
        {% show_widget_zone 'blog-sidebar-left' %}
    </div>
{% endblock %}

{% block sidebar_right %}
    <div class="sticky-top pt-5">
        {# Llamamos a la zona de widgets que hemos definido en el admin #}
        {% show_widget_zone 'blog-sidebar-right' %}
    </div>
{% endblock %}===== ./blog/templates/blog/post_list_by_tag.html =====
<!-- File: blog/templates/blog/post_list_by_tag.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load static %}
{% load widget_tags %} {# For sidebars #}

{% block seo_title %}{% translate "Posts tagged with" %} "{{ tag.name }}" | Tavata.art{% endblock %}
{% block seo_description %}{% translate "Browse all blog posts related to" %} "{{ tag.name }}" {% translate "on Tavata CMS." %}{% endblock %}
{% block title %}{% translate "Posts by tag" %}: "{{ tag.name }}"{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="blog-header pb-3 mb-5 text-center border-bottom">
        <h1 class="display-4">{% translate "Posts Tagged With" %}: <span class="text-primary">{{ tag.name }}</span></h1>
        <p class="lead text-muted">{% translate "Explore content related to this tag." %}</p>
    </div>

    <div class="row">
        {% for post in posts %}
            <div class="col-md-6 col-lg-4 mb-4">
                <div class="card h-100 shadow-sm border-0">
                    {% if post.featured_image %}
                        <a href="{{ post.get_absolute_url }}">
                            <img src="{{ post.featured_image.url }}" class="card-img-top" loading="lazy" alt="{{ post.title }}" style="height: 180px; object-fit: cover;">
                        </a>
                    {% endif %}
                    <div class="card-body d-flex flex-column"> 
                        <h5 class="card-title">{{ post.title }}</h5>
                        <p class="card-text text-muted">
                            {% firstof post.author.profile.get_display_name post.author.username as author_name %}
                            <small>
                                {% blocktranslate with published_date=post.published_date|date:"DATE_FORMAT" author=author_name %}
                                    Published on {{ published_date }} by {{ author }}
                                {% endblocktranslate %}
                            </small>
                        </p>
                        <a href="{{ post.get_absolute_url }}" class="btn btn-primary mt-auto">{% translate "Read More" %}</a>
                    </div>
                </div>
            </div>
        {% empty %}
            <div class="col">
                <p class="text-center">{% translate "No posts found for this tag yet." %}</p>
            </div>
        {% endfor %}
    </div>

    {# --- PAGINATION --- #}
    {% include 'core/partials/_pagination.html' with page_obj=posts %}
</div>
{% endblock %}

{# Sidebars will be the same as blog list generally #}
{% block sidebar_left %}
    <div class="sticky-top pt-5">
        {% show_widget_zone 'blog-sidebar-left' %} 
    </div>
{% endblock sidebar_left %}

{% block sidebar_right %}
    <div class="sticky-top pt-5">
        {% show_widget_zone 'blog-sidebar-right' %} 
    </div>
{% endblock sidebar_right %}===== ./blog/__init__.py =====
===== ./create_superuser.py =====
import os
import django

# Configura el entorno Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')  # Asegúrate de que 'tvt' es el nombre correcto de tu proyecto
django.setup()

from django.contrib.auth import get_user_model
User = get_user_model()
User.objects.create_superuser(
    username='tavata', 
    email='tavata.art@gmail.com', 
    password='@ng3lBTeVeTD', 
    is_staff=True, 
    is_superuser=True
)===== ./templates/404.html =====
<!-- File: templates/404.html -->
{% extends 'core/base.html' %}
{% load i18n %}
{% load static %}

{% block title %}{% translate "Page Not Found" %}{% endblock %}

{# We don't need sidebars on the 404 page, so we override them to be empty #}
{% block sidebar_left %}{% endblock %}
{% block sidebar_right %}{% endblock %}


{% block content %}
<div class="container text-center py-5">
    <div class="row justify-content-center">
        <div class="col-lg-8">

            <!-- A large, friendly icon -->
            <i class="fas fa-ghost fa-5x text-warning mb-4"></i>

            <!-- The main error message -->
            <h1 class="display-1 fw-bold">404</h1>
            <h2 class="display-5">{% translate "Page Not Found" %}</h2>
            
            <!-- A helpful message for the user -->
            <p class="lead text-muted my-4">
                {% translate "Oops! It seems the page you were looking for doesn't exist or has been moved." %}
            </p>

            <!-- Action buttons to guide the user back -->
            <div class="d-grid gap-2 d-sm-flex justify-content-sm-center">
                <a href="{% url 'home' %}" class="btn btn-primary btn-lg px-4 gap-3">
                    <i class="fas fa-home me-2"></i> {% translate "Go to Homepage" %}
                </a>
                <a href="{% url 'contact:contact_form' %}" class="btn btn-outline-secondary btn-lg px-4">
                    <i class="fas fa-envelope me-2"></i> {% translate "Contact Us" %}
                </a>
            </div>

        </div>
    </div>
</div>
{% endblock %}===== ./widgets/signals.py =====
# widgets/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.conf import settings
from blog.models import Post # Importamos Post porque sus cambios afectan a los widgets
from .models import Widget

def clear_all_widget_caches():
    """
    A simple but effective strategy: clear ALL widget caches.
    A more granular approach is possible but much more complex.
    """
    # Obtenemos TODOS los widgets de la base de datos
    all_widgets = Widget.objects.all()
    # Para cada widget y cada idioma, construimos la clave y la borramos
    for widget in all_widgets:
        for lang_code, _ in settings.LANGUAGES:
            cache_key = f'widget_items_{widget.id}_{lang_code}_v1'
            cache.delete(cache_key)
    print("--- ALL WIDGET CACHES CLEARED ---")


# Si se guarda o borra un Widget
@receiver([post_save, post_delete], sender=Widget)
def on_widget_change(sender, instance, **kwargs):
    clear_all_widget_caches()

# ¡LA PARTE IMPORTANTE!
# Si se guarda o borra un Post, los widgets de "Recientes", "Vistos", etc.,
# deben actualizarse.
@receiver([post_save, post_delete], sender=Post)
def on_post_change(sender, instance, **kwargs):
    clear_all_widget_caches()

# En el futuro, podríamos añadir signals para Comments, Pages, etc.===== ./widgets/views.py =====
from django.shortcuts import render

# Create your views here.
===== ./widgets/translation.py =====
# widgets/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Widget

@register(Widget)
class WidgetTranslationOptions(TranslationOptions):
    fields = ('title',)===== ./widgets/widgets.py =====
# File: widgets/widgets.py
from django import forms

class CustomClearableFileInput(forms.ClearableFileInput):
    """
    A custom file input widget that uses a specific template
    to provide full control over its HTML rendering.
    """
    # This tells Django to use our custom HTML file to render this widget.
    template_name = 'widgets/custom_clearable_file_input.html'===== ./widgets/migrations/0001_initial.py =====
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('categories', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='WidgetZone',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, verbose_name='Zone Name')),
                ('slug', models.SlugField(max_length=100, unique=True, verbose_name='Slug (used in templates)')),
            ],
            options={
                'verbose_name': 'Widget Zone',
                'verbose_name_plural': 'Widget Zones',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Widget',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('widget_type', models.CharField(choices=[('recent_posts', 'Recent Blog Posts'), ('most_viewed_posts', 'Most Viewed Blog Posts'), ('most_commented_posts', 'Most Commented Blog Posts'), ('blog_categories', 'Blog Category List'), ('editor_picks_posts', "Editor's Picks (Blog Posts)")], max_length=50, verbose_name='Widget Type')),
                ('title', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, verbose_name='Widget Title')),
                ('title_es', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, null=True, verbose_name='Widget Title')),
                ('title_en', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, null=True, verbose_name='Widget Title')),
                ('title_ca', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, null=True, verbose_name='Widget Title')),
                ('order', models.PositiveIntegerField(default=0, verbose_name='Display Order')),
                ('item_count', models.PositiveIntegerField(default=5, help_text="Used by widgets that display a list of items, like 'Recent Posts' or 'Blog Categories'.", verbose_name='Number of items to show')),
                ('cache_timeout', models.PositiveIntegerField(default=900, help_text='How long the results of this widget should be stored in cache. 0 to disable caching for this widget.', verbose_name='Cache Timeout (in seconds)')),
                ('category_filter', models.ForeignKey(blank=True, help_text='If selected, the widget will only show items from this specific category.', null=True, on_delete=django.db.models.deletion.SET_NULL, to='categories.category', verbose_name='Filter by Category (optional)')),
                ('zone', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='widgets', to='widgets.widgetzone', verbose_name='Widget Zone')),
            ],
            options={
                'verbose_name': 'Widget',
                'verbose_name_plural': 'Widgets',
                'ordering': ['zone', 'order'],
            },
        ),
    ]
===== ./widgets/migrations/0002_widget_column_count_widget_section_title_and_more.py =====
# Generated by Django 5.2.3 on 2025-06-21 20:02

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('widgets', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='widget',
            name='column_count',
            field=models.PositiveIntegerField(default=3, help_text='Number of columns for grid display (e.g., 2, 3, 4).', verbose_name='Column Count'),
        ),
        migrations.AddField(
            model_name='widget',
            name='section_title',
            field=models.CharField(blank=True, help_text="A main title for this grid section (e.g., 'Latest Posts', 'Our Bestsellers').", max_length=200, null=True, verbose_name='Section Title (Optional)'),
        ),
        migrations.AddField(
            model_name='widget',
            name='view_all_link_text',
            field=models.CharField(blank=True, help_text="Text for the 'View All' link below the grid (e.g., 'View All Posts').", max_length=100, null=True, verbose_name='View All Link Text'),
        ),
        migrations.AddField(
            model_name='widget',
            name='view_all_link_url',
            field=models.CharField(blank=True, help_text="URL for the 'View All' link (e.g., '/blog/').", max_length=255, null=True, verbose_name='View All Link URL'),
        ),
        migrations.AlterField(
            model_name='widget',
            name='widget_type',
            field=models.CharField(choices=[('recent_posts', 'Recent Blog Posts'), ('most_viewed_posts', 'Most Viewed Blog Posts'), ('most_commented_posts', 'Most Commented Blog Posts'), ('blog_categories', 'Blog Category List'), ('editor_picks_posts', "Editor's Picks (Blog Posts)"), ('post_grid_recent', 'Post Grid: Recent Posts'), ('post_grid_popular', 'Post Grid: Most Viewed'), ('post_grid_commented', 'Post Grid: Most Commented'), ('post_grid_editor', "Post Grid: Editor's Picks")], max_length=50, verbose_name='Widget Type'),
        ),
    ]
===== ./widgets/migrations/0003_widget_carousel_interval_ms_alter_widget_widget_type.py =====
# Generated by Django 5.2.3 on 2025-06-22 11:34

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('widgets', '0002_widget_column_count_widget_section_title_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='widget',
            name='carousel_interval_ms',
            field=models.PositiveIntegerField(default=5000, help_text="Time in milliseconds between slides for 'Post Carousel' widget.", verbose_name='Carousel Interval (ms)'),
        ),
        migrations.AlterField(
            model_name='widget',
            name='widget_type',
            field=models.CharField(choices=[('recent_posts', 'Recent Blog Posts'), ('most_viewed_posts', 'Most Viewed Blog Posts'), ('most_commented_posts', 'Most Commented Blog Posts'), ('blog_categories', 'Blog Category List'), ('editor_picks_posts', "Editor's Picks (Blog Posts)"), ('post_grid_recent', 'Post Grid: Recent Posts'), ('post_grid_popular', 'Post Grid: Most Viewed'), ('post_grid_commented', 'Post Grid: Most Commented'), ('post_grid_editor', "Post Grid: Editor's Picks"), ('post_carousel', 'Post Carousel')], max_length=50, verbose_name='Widget Type'),
        ),
    ]
===== ./widgets/migrations/__init__.py =====
===== ./widgets/models.py =====
# widgets/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _
from categories.models import Category

class WidgetZone(models.Model):
    """
    Defines a specific area in a template where widgets can be placed.
    e.g., 'Blog Sidebar', 'Footer Column 1', 'Homepage Sidebar'.
    """
    name = models.CharField(max_length=100, verbose_name=_("Zone Name"))
    slug = models.SlugField(max_length=100, unique=True, verbose_name=_("Slug (used in templates)"))

    class Meta:
        verbose_name = _("Widget Zone")
        verbose_name_plural = _("Widget Zones")
        ordering = ['name']

    def __str__(self):
        return self.name


class Widget(models.Model):
    """
    Represents a single, configurable widget that can be placed in a WidgetZone.
    """
    class WidgetType(models.TextChoices):
        RECENT_POSTS = 'recent_posts', _('Recent Blog Posts')
        MOST_VIEWED_POSTS = 'most_viewed_posts', _('Most Viewed Blog Posts')
        MOST_COMMENTED_POSTS = 'most_commented_posts', _('Most Commented Blog Posts')
        BLOG_CATEGORIES = 'blog_categories', _('Blog Category List')
        EDITOR_PICKS_POSTS = 'editor_picks_posts', _("Editor's Picks (Blog Posts)")
        
        # --- NEW WIDGET TYPES FOR FLEXIBLE POST GRIDS ---
        POST_GRID_RECENT = 'post_grid_recent', _("Post Grid: Recent Posts")
        POST_GRID_POPULAR = 'post_grid_popular', _("Post Grid: Most Viewed")
        POST_GRID_COMMENTED = 'post_grid_commented', _("Post Grid: Most Commented")
        POST_GRID_EDITOR = 'post_grid_editor', _("Post Grid: Editor's Picks")

        POST_CAROUSEL = 'post_carousel', _("Post Carousel")
        # We can easily add more types in the future:
        # PAGE_LIST = 'page_list', _('List of Pages')
        # HTML_CONTENT = 'html_content', _('Custom HTML Content')

    zone = models.ForeignKey(
        WidgetZone, 
        on_delete=models.CASCADE, 
        related_name="widgets", 
        verbose_name=_("Widget Zone")
    )
    widget_type = models.CharField(
        max_length=50, 
        choices=WidgetType.choices, 
        verbose_name=_("Widget Type")
    )
    title = models.CharField(
        max_length=100, 
        verbose_name=_("Widget Title"),
        help_text=_("The title that will be displayed above the widget.")
    )
    order = models.PositiveIntegerField(
        default=0, 
        verbose_name=_("Display Order")
    )
    
    # --- Configuration Fields (optional, used by specific widget types) ---
    item_count = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Number of items to show"),
        # Texto mejorado para reflejar su uso dual
        help_text=_("Used by widgets that display a list of items, like 'Recent Posts' or 'Blog Categories'.")
    )
    
    cache_timeout = models.PositiveIntegerField(
        default=900, # Default to 15 minutes (900 seconds)
        verbose_name=_("Cache Timeout (in seconds)"),
        help_text=_("How long the results of this widget should be stored in cache. 0 to disable caching for this widget.")
    )
    
    category_filter = models.ForeignKey(
        Category,
        null=True, blank=True,
        on_delete=models.SET_NULL,
        verbose_name=_("Filter by Category (optional)"),
        help_text=_("If selected, the widget will only show items from this specific category.")
    )

    # --- NEW: Grid/Column Configuration ---
    column_count = models.PositiveIntegerField(
        default=3,
        verbose_name=_("Column Count"),
        help_text=_("Number of columns for grid display (e.g., 2, 3, 4).")
    )
    
    # --- NEW: Section Title (optional, if widget contains its own section title) ---
    section_title = models.CharField(
        max_length=200,
        blank=True, null=True,
        verbose_name=_("Section Title (Optional)"),
        help_text=_("A main title for this grid section (e.g., 'Latest Posts', 'Our Bestsellers').")
    )

    # --- NEW: Text for 'View All' link for the grid ---
    view_all_link_text = models.CharField(
        max_length=100,
        blank=True, null=True,
        verbose_name=_("View All Link Text"),
        help_text=_("Text for the 'View All' link below the grid (e.g., 'View All Posts').")
    )
    view_all_link_url = models.CharField( # Storing as CharField to allow direct URLs or URL names
        max_length=255,
        blank=True, null=True,
        verbose_name=_("View All Link URL"),
        help_text=_("URL for the 'View All' link (e.g., '/blog/').")
    )
    # --- NEW: Grid/Column Configuration ---
    column_count = models.PositiveIntegerField(
        default=3,
        verbose_name=_("Column Count"),
        help_text=_("Number of columns for grid display (e.g., 2, 3, 4).")
    )
    
    # --- NEW: Section Title (optional, if widget contains its own section title) ---
    section_title = models.CharField(
        max_length=200,
        blank=True, null=True,
        verbose_name=_("Section Title (Optional)"),
        help_text=_("A main title for this grid section (e.g., 'Latest Posts', 'Our Bestsellers').")
    )

    # --- NEW: Text for 'View All' link for the grid ---
    view_all_link_text = models.CharField(
        max_length=100,
        blank=True, null=True,
        verbose_name=_("View All Link Text"),
        help_text=_("Text for the 'View All' link below the grid (e.g., 'View All Posts').")
    )
    view_all_link_url = models.CharField( # Storing as CharField to allow direct URLs or URL names
        max_length=255,
        blank=True, null=True,
        verbose_name=_("View All Link URL"),
        help_text=_("URL for the 'View All' link (e.g., '/blog/').")
    )
    carousel_interval_ms = models.PositiveIntegerField(
        default=5000, # 5 seconds in milliseconds
        verbose_name=_("Carousel Interval (ms)"),
        help_text=_("Time in milliseconds between slides for 'Post Carousel' widget.")
    )
    
    class Meta:
        ordering = ['zone', 'order']
        verbose_name = _("Widget")
        verbose_name_plural = _("Widgets")

    def __str__(self):
        return f"{self.title} ({self.get_widget_type_display()}) in {self.zone.name}"

# Create your models here.
===== ./widgets/apps.py =====
from django.apps import AppConfig


class WidgetsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'widgets'

    def ready(self):
        import widgets.signals  # Import the signals module to ensure it is registered
        # This will automatically connect the signals defined in widgets/signals.py
        # when the app is ready, allowing us to handle post_save and post_delete events.

        # Note: No need to import widget_tags here; they are loaded by Django's template system
        # when the template tags are used in templates.
        # The import here is only for signals, which handle cache invalidation.

        # If you have any other initialization code, you can add it here.
        # For example, you might want to register custom template tags or filters.
        # However, in this case, we are only concerned with signals for cache management.===== ./widgets/admin.py =====
# File: widgets/admin.py
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from .models import WidgetZone, Widget
from modeltranslation.admin import TabbedTranslationAdmin

class WidgetInline(admin.TabularInline):
    """
    Defines the editor for Widgets when they are managed 'inline'
    within a WidgetZone.
    """
    model = Widget
    # We now use the single, universal 'category_filter' field.
    fields = ('title', 'widget_type', 'order', 'item_count', 'cache_timeout', 'category_filter')
    extra = 1
    ordering = ['order']
    # Adding a class to make the inline editor more compact
    classes = ('collapse',)


@admin.register(WidgetZone)
class WidgetZoneAdmin(admin.ModelAdmin):
    """ Admin options for the WidgetZone model. """
    list_display = ('name', 'slug', 'widget_count')
    search_fields = ('name', 'slug')
    prepopulated_fields = {'slug': ('name',)}
    inlines = [WidgetInline]

    @admin.display(description=_("Number of Widgets"))
    def widget_count(self, obj):
        """Calculates the number of widgets in this zone."""
        return obj.widgets.count()


@admin.register(Widget)
class WidgetAdmin(TabbedTranslationAdmin):
    """ 
    A global list view for all Widgets, allowing for quick edits and
    re-assignment across different zones.
    """
    list_display = ('title', 'zone', 'widget_type', 'order', 'cache_timeout', 'column_count', 'section_title', 'view_all_link_text', 'view_all_link_url', 'carousel_interval_ms')
    list_filter = ('zone', 'widget_type')
    list_editable = ('order', 'zone', 'cache_timeout')
    search_fields = ('title',)
    
    # We update the fields for the detail edit form as well.
    fields = ('title', 'zone', 'widget_type', 'order', 'item_count', 'cache_timeout', 'category_filter')

    ordering = ('zone', 'order')
===== ./widgets/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./widgets/templatetags/widget_tags.py =====
# File: widgets/templatetags/widget_tags.py
import logging
from django import template
from django.db.models import Count, Q
from django.core.cache import cache
from django.conf import settings # Needed for settings.LANGUAGES and settings.LANGUAGE_CODE

# Import all needed models at the top
from blog.models import Post 
from categories.models import Category # Universal Category model
from widgets.models import Widget, WidgetZone

# Ensure static is imported from Django's template tags
from django.templatetags.static import static 

logger = logging.getLogger(__name__)
register = template.Library()

# --- HELPER FUNCTION: GET THUMBNAIL URL ---
def _get_thumbnail_url(obj):
    """
    Returns the URL for the thumbnail of a given object.
    Currently supports Post objects with 'featured_image'.
    """
    if isinstance(obj, Post) and obj.featured_image:
        return obj.featured_image.url
    
    # Fallback to a default placeholder image if no specific image is found.
    # You MUST ensure 'static/images/placeholders/default_thumbnail.png' exists.
    return static('images/placeholders/default_thumbnail.png')

@register.inclusion_tag('widgets/render_zone.html', takes_context=True)
def show_widget_zone(context, zone_slug):
    """
    Renders all widgets for a specific zone, utilizing a configurable cache
    for each widget to optimize performance.
    """
    try:
        zone = WidgetZone.objects.prefetch_related('widgets').get(slug=zone_slug)
        widgets_queryset = zone.widgets.all()
    except WidgetZone.DoesNotExist:
        logger.warning(f"Widget zone with slug '{zone_slug}' not found.")
        return {'processed_widgets': []} # Return empty if zone doesn't exist

    processed_widgets = [] # Initialize this list here, outside the loop

    # Iterate through each widget configured for this zone
    for widget_instance in widgets_queryset: # Renamed to widget_instance for clarity
        language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
        cache_key = f'widget_items_{widget_instance.id}_{language_code}_v1'
        
        items_to_cache = None # Initialize variable that will hold items for caching
        
        # 1. Try to get items from cache if caching is enabled for this widget.
        if widget_instance.cache_timeout > 0:
            items_to_cache = cache.get(cache_key)

        # 2. If it's a cache miss, query the database and process.
        if items_to_cache is None:
            if widget_instance.cache_timeout > 0: # Log only if caching was attempted
                logger.info(f"CACHE MISS for widget '{widget_instance.title}' (ID: {widget_instance.id}). Querying database.")
            
            # --- WIDGET LOGIC DISPATCHER (match/case) ---
            # This 'items_container' will hold the list of items from the DB query.
            items_container = [] # Initialize for the match/case block

            match widget_instance.widget_type:
                case 'recent_posts':
                    items_qs = Post.objects.filter(status='published').order_by('-published_date')
                    items_container = list(items_qs[:widget_instance.item_count]) # Evaluate QuerySet
                
                case 'most_viewed_posts':
                    items_qs = Post.objects.filter(status='published').order_by('-views_count', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case 'most_commented_posts':
                    items_qs = Post.objects.filter(status='published') \
                                           .annotate(num_comments=Count('comments', filter=Q(comments__is_approved=True))) \
                                           .filter(num_comments__gt=0) \
                                           .order_by('-num_comments', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                
                case 'editor_picks_posts':
                    items_qs = Post.objects.filter(status='published', editor_rating__gt=0) \
                                           .order_by('-editor_rating', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                
                case 'blog_categories':
                    categories_qs = Category.objects.annotate(
                        num_blog_posts=Count('blog_posts', filter=Q(blog_posts__status='published'))
                    ).filter(num_blog_posts__gt=0).order_by('-num_blog_posts', 'name')
                    items_container = list(categories_qs[:widget_instance.item_count])
                
                # --- NEW CASES FOR POST GRIDS ---
                case 'post_grid_recent':
                    items_qs = Post.objects.filter(status='published').order_by('-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                    # No new thumbnail_url required here, as the template will handle it dynamically.

                case 'post_grid_popular':
                    items_qs = Post.objects.filter(status='published').order_by('-views_count', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case 'post_grid_commented':
                    items_qs = Post.objects.filter(status='published') \
                                           .annotate(num_comments=Count('comments', filter=Q(comments__is_approved=True))) \
                                           .filter(num_comments__gt=0) \
                                           .order_by('-num_comments', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                
                case 'post_grid_editor':
                    items_qs = Post.objects.filter(status='published', editor_rating__gt=0) \
                                           .order_by('-editor_rating', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case 'post_carousel':
                    # You can configure which posts go into the carousel.
                    # For simplicity, let's use a "top N" most recent posts or highly rated posts.
                    # This example uses editor_rating > 0.
                    items_qs = Post.objects.filter(status='published', editor_rating__gt=0) \
                                           .order_by('-editor_rating', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case _: # Unrecognized widget type
                    logger.warning(f"Unrecognized widget type '{widget_instance.widget_type}' for widget '{widget_instance.title}'.")
                    items_container = [] # Empty list for safety.
            
            # --- Common Post-based Processing (Applies only to Post items) ---
            # Attach thumbnail_url to Post objects. This runs once per item on cache miss.
            # This should not run for categories.
            if widget_instance.widget_type in ['recent_posts', 'most_viewed_posts', 'most_commented_posts', 'editor_picks_posts', 'post_grid_recent', 'post_grid_popular', 'post_grid_commented', 'post_grid_editor', 'post_carousel']:
                for post_obj in items_container: 
                    # post_obj is already a Post instance here (from items_container)
                    post_obj.thumbnail_url = _get_thumbnail_url(post_obj)
            
            items_to_cache = items_container # Assign the processed list for caching

            # 3. Store result in cache if timeout is set.
            if widget_instance.cache_timeout > 0: # Only cache if timeout > 0
                cache.set(cache_key, items_to_cache, widget_instance.cache_timeout)
                logger.info(f"CACHE SET for widget '{widget_instance.title}' (ID: {widget_instance.id}) for {widget_instance.cache_timeout} seconds.")
        else: # Cache HIT
            logger.info(f"CACHE HIT for widget '{widget_instance.title}' (ID: {widget_instance.id}). Serving from cache.")

        # --- IMPORTANT: Append to processed_widgets list outside the `if items_to_cache is None` block ---
        # `items_to_cache` will hold either the cached value or the newly fetched value.
        processed_widgets.append({'widget': widget_instance, 'items': items_to_cache})
        
    return {'processed_widgets': processed_widgets, 'request': context['request']}===== ./widgets/templatetags/__init__.py =====
===== ./widgets/templates/widgets/custom_clearable_file_input.html =====
<!-- File: templates/widgets/custom_clearable_file_input.html -->

{# We no longer render the default "Clear" checkbox. #}
{# Our logic of choosing a default avatar serves the same purpose. #}
{% if widget.is_initial %}
    {# <input class="form-check-input" type="checkbox" name="{{ widget.clear_checkbox_name }}" id="{{ widget.clear_checkbox_id }}"> #}
    <label class="form-label small text-muted">{{ widget.input_text }}:</label>
{% endif %}

{# This renders the actual <input type="file" ...> button. #}
<input type="{{ widget.type }}" 
       name="{{ widget.name }}" 
       class="form-control" 
       {% include "django/forms/widgets/attrs.html" %}>===== ./widgets/templates/widgets/render_zone.html =====
{% load i18n %}
{# File: widgets/templates/widgets/render_zone.html #}
{# This template acts as a dispatcher. It receives the processed widget data #}
{# and decides which partial template to include based on the widget's type. #}

{% for data in processed_widgets %}

    {# --- WIDGET TYPE DISPATCHER --- #}

    {# Case 1: The widget is any type that displays a list of posts #}
    {% if data.widget.widget_type == 'recent_posts' or data.widget.widget_type == 'most_viewed_posts' or data.widget.widget_type == 'most_commented_posts' or data.widget.widget_type == 'editor_picks_posts' %}
        
        {% include 'widgets/partials/_posts_widget.html' with widget=data.widget items=data.items request=request %}

    {# Case 2: The widget is for displaying blog categories #}
    {% elif data.widget.widget_type == 'blog_categories' %}
        
        {% include 'widgets/partials/_blog_categories_widget.html' with widget=data.widget items=data.items request=request %}
    
    {# --- WXISTING CASES FOR POST GRIDS --- #}
    {% elif data.widget.widget_type == 'post_grid_recent' or data.widget.widget_type == 'post_grid_popular' or data.widget.widget_type == 'post_grid_commented' or data.widget.widget_type == 'post_grid_editor' %}
        {% include 'widgets/partials/_post_grid.html' with widget=data.widget items=data.items request=request %}
    
    {# --- NEW CASE FOR POST CAROUSEL --- #}
    {% elif data.widget.widget_type == 'post_carousel' %}
        {% include 'widgets/partials/_post_carousel.html' with widget=data.widget items=data.items request=request %}

    {# You can add more 'elif' blocks here for future widget types, like 'page_list', etc. #}
    {# Default Case: If the widget type is not recognized, show a helpful debug message. #}
    {% else %}
        <div class="alert alert-warning small">
            {% blocktranslate with widget_type=data.widget.widget_type %}
                <strong>Widget Error:</strong> Template for widget type "{{ widget_type }}" not found in the dispatcher.
            {% endblocktranslate %}
        </div>
    {% endif %}
    
    {# --- END WIDGET TYPE DISPATCHER --- #}

{% endfor %}===== ./widgets/templates/widgets/_post_carousel.html =====
<!-- File: widgets/templates/widgets/partials/_post_carousel.html -->
{% load i18n %}
{% load static %}

{# This partial renders a responsive carousel of blog posts. #}
{# It is designed to be highly configurable via the Widget model. #}

{# Container for the entire carousel section #}
<div class="post-carousel-section">
    {# Optional: Section Title #}
    {% if widget.section_title %}
        <h2 class="mb-4 text-center">{% translate widget.section_title %}</h2>
    {% endif %}

    {# Ensure there are items to prevent Bootstrap carousel errors #}
    {% if items %}
        <div id="carousel-{{ widget.id }}" class="carousel slide" data-bs-ride="carousel" data-bs-interval="{{ widget.carousel_interval_ms|default:5000 }}">
            {# Carousel Indicators #}
            <div class="carousel-indicators">
                {% for forloop_item in items %}
                    <button type="button" data-bs-target="#carousel-{{ widget.id }}" data-bs-slide-to="{{ forloop.counter0 }}" {% if forloop.first %}class="active" aria-current="true"{% endif %} aria-label="Slide {{ forloop.counter }}"></button>
                {% endfor %}
            </div>

            {# Carousel Inner #}
            <div class="carousel-inner">
                {% for item in items %}
                    <div class="carousel-item {% if forloop.first %}active{% endif %}">
                        <img src="{{ item.featured_image.url }}" class="d-block w-100 carousel-img" alt="{{ item.title }}" style="height: 400px; object-fit: cover;">
                        <div class="carousel-caption d-none d-md-block">
                            <h5>{{ item.title }}</h5>
                            <p>{{ item.content|striptags|truncatechars:100 }}</p>
                            <a href="{{ item.get_absolute_url }}" class="btn btn-sm btn-light">{% translate "Read More" %}</a>
                        </div>
                    </div>
                {% endfor %}
            </div>

            {# Carousel Controls #}
            <button class="carousel-control-prev" type="button" data-bs-target="#carousel-{{ widget.id }}" data-bs-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="visually-hidden">{% translate "Previous" %}</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#carousel-{{ widget.id }}" data-bs-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="visually-hidden">{% translate "Next" %}</span>
            </button>
        </div>
    {% else %}
        <div class="alert alert-info text-center">{% translate "No posts available for the carousel." %}</div>
    {% endif %}
</div>===== ./widgets/templates/widgets/partials/_blog_categories_widget.html =====
{% load i18n %}

{# This is the partial template for the Blog Categories widget. #}
<div class="card mb-4 shadow-sm border-0">
    <h5 class="card-header p-0">
        {# The button acts as a clickable header for the collapsible content. #}
        <button class="btn btn-light w-100 text-start d-flex justify-content-between align-items-center"
                type="button" 
                data-bs-toggle="collapse" 
                data-bs-target="#collapse-widget-{{ widget.id }}" {# Uses the unique widget ID #}
                aria-expanded="true" 
                aria-controls="collapse-widget-{{ widget.id }}">
            
            <span>
                {# The title is dynamic, coming from the widget object in the database. #}
                {{ widget.title }}
            </span>
            
            {# The single chevron icon that will be rotated by our CSS. #}
            <i class="fas fa-chevron-down TAVATA-collapse-icon"></i>
        </button>
    </h5>

    {# The collapsible content area. It starts closed by default. #}
    <div class="collapse show" id="collapse-widget-{{ widget.id }}">
        <div class="list-group list-group-flush">
            {# We loop through the 'items' list (which contains categories) passed from the templatetag. #}
            {% for category in items %}
                <a href="{{ category.get_absolute_url }}" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center">
                    {# Display the category name. #}
                    {{ category.name }}
                    {# 'num_posts' is the field we created with .annotate() in the templatetag. #}
                    <span class="badge bg-primary rounded-pill">{{ category.num_posts }}</span>
                </a>
            {% empty %}
                {# This message is displayed if the 'items' list is empty. #}
                <span class="list-group-item">{% translate "No categories with posts available." %}</span>
            {% endfor %}
        </div>
    </div>
</div>===== ./widgets/templates/widgets/partials/_posts_widget.html =====
<!-- File: widgets/templates/widgets/partials/_posts_widget.html -->
{% load i18n %}
{% load static %} {# Make sure static is loaded for the default_thumbnail.png #}

<div class="card mb-4 shadow-sm border-0">
    <h5 class="card-header p-0">
        <button class="btn btn-light w-100 text-start d-flex justify-content-between align-items-center collapsed"
                type="button" 
                data-bs-toggle="collapse" 
                data-bs-target="#collapse-widget-{{ widget.id }}" 
                aria-expanded="false" 
                aria-controls="collapse-widget-{{ widget.id }}">
            <span>{{ widget.title }}</span>
            <i class="fas fa-chevron-down TAVATA-collapse-icon"></i>
        </button>
    </h5>

    <div class="collapse show" id="collapse-widget-{{ widget.id }}">
        <div class="list-group list-group-flush">
            {% for item in items %}
                {# The entire list item is a link (d-flex for alignment) #}
                <a href="{{ item.get_absolute_url }}" class="list-group-item list-group-item-action d-flex align-items-center">
                    {# --- NEW: Thumbnail Image --- #}
                    <img src="{{ item.thumbnail_url }}" 
                         alt="{{ item.title|default:'Thumbnail' }}" 
                         class="rounded me-2" 
                         style="width: 40px; height: 40px; object-fit: cover;">
                    {# --- END NEW --- #}

                    {{ item.title }}
                </a>
            {% empty %}
                <span class="list-group-item">{% translate "No items to display." %}</span>
            {% endfor %}
        </div>
    </div>
</div>===== ./widgets/templates/widgets/partials/_post_carousel.html =====
<!-- File: widgets/templates/widgets/partials/_post_carousel.html -->
{% load i18n %}
{% load static %}

{# This partial renders a responsive carousel of blog posts. #}
{# It is designed to be highly configurable via the Widget model. #}

{# Container for the entire carousel section #}
<div class="post-carousel-section">
    {# Optional: Section Title #}
    {% if widget.section_title %}
        <h2 class="mb-4 text-center">{% translate widget.section_title %}</h2>
    {% endif %}

    {# Ensure there are items to prevent Bootstrap carousel errors #}
    {% if items %}
        <div id="carousel-{{ widget.id }}" class="carousel slide" data-bs-ride="carousel" data-bs-interval="{{ widget.carousel_interval_ms|default:5000 }}">
            {# Carousel Indicators #}
            <div class="carousel-indicators">
                {% for forloop_item in items %}
                    <button type="button" data-bs-target="#carousel-{{ widget.id }}" data-bs-slide-to="{{ forloop.counter0 }}" {% if forloop.first %}class="active" aria-current="true"{% endif %} aria-label="Slide {{ forloop.counter }}"></button>
                {% endfor %}
            </div>

            {# Carousel Inner #}
            <div class="carousel-inner">
                {% for item in items %}
                    <div class="carousel-item {% if forloop.first %}active{% endif %}">
                        {# Assuming 'item' is a Post object and has 'featured_image.url' and 'title' #}
                        {# You might need to adjust 'item_obj.featured_image' to 'item.featured_image' #}
                        <img src="{{ item.featured_image.url }}" class="d-block w-100 carousel-img" alt="{{ item.title }}" style="height: 400px; object-fit: cover;">
                        <div class="carousel-caption d-none d-md-block">
                            <h5>{{ item.title }}</h5>
                            <p>{{ item.content|striptags|truncatechars:100 }}</p>
                            <a href="{{ item.get_absolute_url }}" class="btn btn-sm btn-light">{% translate "Read More" %}</a>
                        </div>
                    </div>
                {% empty %}
                    {# This empty block is generally not reached if 'items' check above is successful #}
                {% endfor %}
            </div>

            {# Carousel Controls #}
            <button class="carousel-control-prev" type="button" data-bs-target="#carousel-{{ widget.id }}" data-bs-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="visually-hidden">{% translate "Previous" %}</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#carousel-{{ widget.id }}" data-bs-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="visually-hidden">{% translate "Next" %}</span>
            </button>
        </div>
    {% else %}
        <div class="alert alert-info text-center">{% translate "No posts available for the carousel." %}</div>
    {% endif %}
</div>===== ./widgets/templates/widgets/partials/_post_grid.html =====
<!-- File: widgets/templates/widgets/partials/_post_grid.html -->
{% load i18n %}
{% load static %}

{# This partial renders a responsive grid of blog posts. #}
{# It is designed to be highly configurable via the Widget model. #}

{# Container for the entire grid #}
<div class="post-grid-section">
    {# Optional: Section Title #}
    {% if widget.section_title %}
        <h2 class="mb-4 text-center">{% translate widget.section_title %}</h2>
    {% endif %}

    {# Grid of Posts #}
    <div class="row row-cols-1 row-cols-sm-2 {% if widget.column_count == 3 %}row-cols-md-3{% elif widget.column_count == 4 %}row-cols-md-4{% elif widget.column_count == 2 %}row-cols-md-2{% else %}row-cols-md-3{% endif %} g-4">
        {% for item in items %}
            <div class="col">
                <div class="card h-100 shadow-sm border-0">
                    {% if item.featured_image %}
                        <a href="{{ item.get_absolute_url }}">
                            <img src="{{ item.featured_image.url }}" class="card-img-top" alt="{{ item.title }}" style="height: 180px; object-fit: cover;" loading="lazy">
                        </a>
                    {% endif %}
                    <div class="card-body d-flex flex-column">
                        <h5 class="card-title">{{ item.title }}</h5>
                        <p class="card-text text-muted small">
                            {% blocktranslate with date=item.published_date|date:"DATE_FORMAT" %}
                                Published on {{ date }}
                            {% endblocktranslate %}
                        </p>
                        <p class="card-text">{{ item.content|striptags|truncatechars:100 }}</p>
                        <a href="{{ item.get_absolute_url }}" class="btn btn-sm btn-primary mt-auto">{% translate "Read More" %}</a>
                    </div>
                </div>
            </div>
        {% endfor %}
    </div>

    {# Optional: "View All" Link #}
    {% if widget.view_all_link_text and widget.view_all_link_url %}
        <div class="text-center mt-4">
            <a href="{{ widget.view_all_link_url }}" class="btn btn-outline-secondary">{% translate widget.view_all_link_text %}</a>
        </div>
    {% endif %}

    {# Note: Pagination for grids is often handled differently. If this widget is paginated, #}
    {# it would need to receive a paginated object directly, not a list of items. #}
    {# For now, this is a simple grid displaying up to widget.item_count items. #}
</div>===== ./widgets/__init__.py =====
===== ./manage.py =====
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
===== ./core/views.py =====
# core/views.py
import logging
from django.shortcuts import render
from pages.models import Page

# Get a logger instance for this module.
logger = logging.getLogger(__name__)

def home(request):
    """
    Finds the page marked as the 'homepage' in the database and renders it.
    If no homepage is set, it displays a default view.
    """
    logger.info(f"Homepage requested by user: {request.user.username or 'Anonymous'}")

    homepage = None
    try:
        homepage = Page.objects.filter(is_homepage=True, status='published').latest('updated_at')
        logger.debug(f"Serving homepage: '{homepage.title}' (ID: {homepage.id})")

    except Page.DoesNotExist:
        # This is a configuration warning, not an error. The site still works.
        logger.warning("No published page has been configured as the homepage. Serving a placeholder.")
        # The template itself handles displaying a user-friendly message.
        
    except Exception as e:
        # Catch any other unexpected database or logic errors.
        logger.error(
            f"An unexpected error occurred while fetching the homepage.",
            exc_info=True # Include the full traceback for debugging.
        )
        # In this case, homepage remains None, and the template will show a message.
        # A more robust solution might render a 500 error page.

    context = {
        'page': homepage,
    }

    return render(request, 'pages/page_detail.html', context)===== ./core/urls.py =====
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]===== ./core/migrations/__init__.py =====
===== ./core/models.py =====
from django.db import models

# Create your models here.
===== ./core/apps.py =====
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'===== ./core/admin.py =====
from django.contrib import admin

# Register your models here.
===== ./core/tests.py =====
from django.test import TestCase

# Create your tests here.
===== ./core/templatetags/url_utils.py =====
# core/templatetags/url_utils.py
from django import template

register = template.Library()

@register.simple_tag
def get_translated_url(obj, language_code):
    """
    Calls the get_absolute_url_for_language method on a given object
    and returns its result.
    Assumes the object has a method named 'get_absolute_url_for_language'.
    """
    if hasattr(obj, 'get_absolute_url_for_language'):
        return obj.get_absolute_url_for_language(language_code)
    # Fallback to current object's URL if method not found
    return obj.get_absolute_url() if hasattr(obj, 'get_absolute_url') else '#'===== ./core/templates/core/base.html =====
{% load static %}
<!doctype html>
{# The language code is dynamically set by Django's LocaleMiddleware #}
<html lang="{{ LANGUAGE_CODE }}">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    {# --- SEO and Browser Tab Title Blocks --- #}
    {# These blocks can be overridden by child templates for specific pages. #}
    <title>{% block seo_title %}{% block title %}Tavata.art{% endblock %}{% endblock seo_title %}</title>
    <meta name="description" content="{% block seo_description %}Default site description. Provide a more specific one for better SEO.{% endblock %}">

    {# --- CSS Stylesheets --- #}
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="{% static 'css/theme.css' %}">
    
    {# Block for extra, page-specific CSS #}
    {% block extra_css %}{% endblock %}
</head>

{# These body classes use Flexbox to ensure the footer sticks to the bottom on short pages #}
<body class="d-flex flex-column min-vh-100 bg-light">

    {# --- TOP BAR FOR BRANDING AND SOCIALS --- #}
    {# This is the new top section for the site's main identity. #}
    {% include 'core/partials/_topbar.html' %}
    {# --- END TOP BAR --- #}

    {# --- MAIN HEADER / NAVBAR --- #}
    {# This includes the main navigation menu. #}
    {% include 'core/partials/_header.html' %}
    {# --- END MAIN HEADER --- #}

    {# --- NEW: LANGUAGE SELECTOR BAR --- #}
    {% include 'core/partials/_language_selector_bar.html' %}
    {# --- END NEW --- #}

    {# --- MAIN CONTENT AREA --- #}
    <main class="container-fluid flex-grow-1 py-4">
        <div class="row">

            {# Left Sidebar: Hidden on small screens, appears on medium and larger screens #}
            <aside class="col-lg-3 col-md-3 d-none d-md-block">
                {% block sidebar_left %}{% endblock sidebar_left %}
            </aside>

            {# Central Content Column: This is where the main content of each page will go #}
            <div class="col-lg-6 col-md-9 col-sm-12">
                
                {# --- FLASH MESSAGES BLOCK --- #}
                {% block messages %}
                    {% if messages %}
                        <div class="messages-container">
                            {% for message in messages %}
                                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                                    {{ message }}
                                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endblock messages %}
                
                {# Breadcrumbs block for navigation context on inner pages #}
                {% block breadcrumbs %}{% endblock breadcrumbs %}
                
                {# Main content block, which child templates will override #}
                <div class="mt-4">
                    {% block content %}{% endblock content %}
                </div>
            </div>

            {# Right Sidebar: Hidden on small/medium screens, appears on large screens #}
            <aside class="col-lg-3 d-none d-lg-block">
                {% block sidebar_right %}{% endblock sidebar_right %}
            </aside>

        </div>
    </main>

    
    {# --- FOOTER --- #}
    {% include 'core/partials/_footer.html' %}
    {# --- END FOOTER --- #}
    

    {# --- JAVASCRIPTS --- #}
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    
    {# Block for extra, page-specific JavaScript #}
    {% block extra_js %}{% endblock %}

</body>
</html>===== ./core/templates/core/partials/_header.html =====
<!-- File: core/templates/core/partials/_header.html -->
{% load i18n %}
{% load static %}
{% load menu_tags %}

<header>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">

            <!-- Site Brand/Logo -->
            <a class="navbar-brand" href="{% url 'home' %}">
                <i class="fas fa-bee"></i> TAVATA
            </a>

            <!-- Mobile Navigation Toggle Button -->
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Collapsible Navigation Container -->
            <div class="collapse navbar-collapse" id="navbarNav">
                
                <!-- Main Menu (Dynamically rendered) -->
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    {% show_menu 'main-menu' %}
                </ul>

                <!-- Search Form -->
                <form class="d-flex" role="search" action="{% url 'search:search_results' %}" method="get">
                    <input class="form-control me-2" type="search" name="q" value="{{ request.GET.q|default:'' }}" placeholder="{% translate 'Search...' %}" aria-label="Search">
                    <button class="btn btn-primary" type="submit">{% translate "Search" %}</button>
                </form>

                <!-- --- USER AUTHENTICATION BLOCK --- -->
                <div class="d-flex align-items-center ms-lg-3">
                    {% if user.is_authenticated %}
                        <!-- If user is logged in, show their avatar, name, and a logout form -->

                        <!-- User Avatar (links to profile edit page) -->
                        <a href="{% url 'accounts:profile_edit' %}" title="{% translate 'Edit Profile' %}">
                            {# We simply call our new smart method. It will return the correct URL. #}
                            <img src="{{ user.profile.get_avatar_url }}" 
                                alt="{{ user.username }}'s Avatar"
                                class="rounded-circle" style="width: 32px; height: 32px; object-fit: cover;">
                        </a>

                        <!-- User Greeting (Reinstated) -->
                        <span class="navbar-text ms-2 me-3">
                            {% blocktranslate with user_name=user.profile.get_display_name %}Hello, {{ user_name }}{% endblocktranslate %}
                        </span>

                        <!-- Logout Form -->
                        <form id="logout-form" action="{% url 'logout' %}" method="post">
                            {% csrf_token %}
                            <button type="submit" class="btn btn-outline-warning btn-sm">{% translate "Log Out" %}</button>
                        </form>

                    {% else %}
                        <!-- If user is anonymous, show a login link -->
                        <a class="nav-link text-white" href="{% url 'login' %}">{% translate "Log In" %}</a>
                    {% endif %}
                </div>
                <!-- --- END USER AUTHENTICATION BLOCK --- -->
                
            </div>
        </div>
    </nav>
</header>===== ./core/templates/core/partials/_topbar.html =====
<!-- File: core/templates/core/partials/_topbar.html -->
{% load static %}
{% load i18n %}
{% load settings_tags %}
{% load menu_tags %} 

{% get_site_config as site_config %}

<div class="top-bar bg-tavata-primary py-2 shadow-sm">
    <div class="container d-flex justify-content-between align-items-center">

        <!-- Left Side: Logo and Slogan -->
        <div class="brand-identity me-auto d-flex align-items-center">
            <a href="{% url 'home' %}" class="text-decoration-none d-flex align-items-center">
                {# Display custom logo if available, otherwise display bee icon as fallback #}
                {% if site_config.site_logo and site_config.site_logo.url %}
                    {# Increase height, keep img-fluid and object-fit #}
                    <img src="{{ site_config.site_logo.url }}" alt="{% translate 'Site Logo' %}" class="img-fluid me-2" style="height: 50px; object-fit: contain;">
                {% else %}
                    {# Increase the size of the Font Awesome bee icon with fa-4x #}
                    <i class="fas fa-bee text-dark fa-4x me-2"></i> 
                {% endif %}
                <div>
                    {# Display slogan only if it's provided in site settings #}
                    {% if site_config.site_slogan %}
                        {# Use fs-3 for a larger text, and fw-normal to ensure it's not bold #}
                        <span class="d-block text-dark fs-3 fw-normal">
                            {{ site_config.site_slogan }}
                        </span>
                    {% endif %}
                </div>
            </a>
        </div>

        <!-- Center: Banner/Ad (optional) -->
        <div class="top-bar-banner mx-lg-auto me-3 me-lg-0"> 
            {% if site_config.top_bar_banner_image and site_config.top_bar_banner_image.url %}
                {% if site_config.top_bar_banner_link %}
                    <a href="{{ site_config.top_bar_banner_link }}" target="_blank" rel="noopener noreferrer">
                        {# Also increase banner height proportionally #}
                        <img src="{{ site_config.top_bar_banner_image.url }}" alt="{% translate 'Advertisement' %}" class="img-fluid" style="max-height: 50px; object-fit: contain;">
                    </a>
                {% else %}
                    <img src="{{ site_config.top_bar_banner_image.url }}" alt="{% translate 'Advertisement' %}" class="img-fluid" style="max-height: 50px; object-fit: contain;">
                {% endif %}
            {% endif %}
        </div>

        <!-- Right Side: Social Media Links -->
        <div class="social-links ms-auto d-flex align-items-center">
            {% show_social_links_menu %}
        </div>

    </div>
</div>

<hr class="my-0">===== ./core/templates/core/partials/_pagination.html =====
<!-- Archivo: core/templates/core/partials/_pagination.html -->
{% load i18n %}

{% if page_obj.has_other_pages %}
<nav aria-label="Page navigation" class="mt-5">
    <ul class="pagination justify-content-center">
        
        {# We define the parameter name. Default to 'page' if not provided. #}
        {% with p_name=param_name|default:'page' %}

            <!-- Previous Button -->
            {% if page_obj.has_previous %}
                <li class="page-item"><a class="page-link" href="?{{ p_name }}={{ page_obj.previous_page_number }}{% for key, value in request.GET.items %}{% if key != p_name %}&{{ key }}={{ value }}{% endif %}{% endfor %}">{% translate "Previous" %}</a></li>
            {% else %}
                <li class="page-item disabled"><span class="page-link">{% translate "Previous" %}</span></li>
            {% endif %}

            <!-- Page Numbers -->
            {% for i in page_obj.paginator.page_range %}
                {% if page_obj.number == i %}
                    <li class="page-item active"><span class="page-link">{{ i }}</span></li>
                {% else %}
                    <li class="page-item"><a class="page-link" href="?{{ p_name }}={{ i }}{% for key, value in request.GET.items %}{% if key != p_name %}&{{ key }}={{ value }}{% endif %}{% endfor %}">{{ i }}</a></li>
                {% endif %}
            {% endfor %}
            
            <!-- Next Button -->
            {% if page_obj.has_next %}
                <li class="page-item"><a class="page-link" href="?{{ p_name }}={{ page_obj.next_page_number }}{% for key, value in request.GET.items %}{% if key != p_name %}&{{ key }}={{ value }}{% endif %}{% endfor %}">{% translate "Next" %}</a></li>
            {% else %}
                <li class="page-item disabled"><span class="page-link">{% translate "Next" %}</span></li>
            {% endif %}

        {% endwith %}
    </ul>
</nav>
{% endif %}===== ./core/templates/core/partials/_tree_node_component.html =====
<!-- File: core/templates/core/partials/_tree_node_component.html -->
{% load mptt_tags %}

<div class="list-group list-group-flush">
    {% recursetree nodes %}
        <div class="list-group-item border-0" style="padding-left: calc(0.5rem + {{ node.level }} * 1.5rem);">

            <div class="d-flex align-items-center">
                {% if not node.is_leaf_node %}
                    <a class="btn btn-link text-decoration-none text-body p-0 me-2" data-bs-toggle="collapse" href="#node-children-{{ node.id }}" ...>
                        <i class="fas fa-chevron-down TAVATA-collapse-icon"></i>
                    </a>
                {% else %}
                    <span class="me-2" style="width: 1.2rem;"></span>
                {% endif %}

                <a href="{{ node.get_absolute_url }}" class="text-decoration-none text-body flex-grow-1">
                    <i class="far fa-folder me-2 text-primary"></i>
                    {# Usamos el __str__ del objeto, que ya está formateado #}
                    {{ node }}
                </a>
            </div>
        </div>

        {% if not node.is_leaf_node %}
            <div class="collapse" id="node-children-{{ node.id }}">
                {{ children }}
            </div>
        {% endif %}
    {% endrecursetree %}
</div>===== ./core/templates/core/partials/_language_selector_bar.html =====
<!-- File: core/templates/core/partials/_language_selector_bar.html -->
{% load i18n %}
{% load url_utils %} {# Asegúrate de que este cargado si lo necesitas para translatable_object #}

<div class="language-bar bg-light py-2 shadow-sm">
    <div class="container d-flex justify-content-end align-items-center">
        
        {# --- LANGUAGE SELECTOR: BUTTONS WITH FONT AWESOME ICONS (GENERIC) --- #}
        <div class="btn-group" role="group" aria-label="Language selector">
            
            {# Botón para Español #}
            <form action="{% url 'set_language' %}" method="post" class="d-inline-block me-2"> 
                {% csrf_token %}
                {# Lógica para el 'next' URL (mantener si usas translatable_object) #}
                {% if translatable_object %}
                    {% get_translated_url translatable_object 'es' as translated_url %}
                    <input type="hidden" name="next" value="{{ translated_url }}">
                {% else %}
                    <input type="hidden" name="next" value="{{ request.get_full_path }}">
                {% endif %}
                {# Fin lógica para el 'next' URL #}
                <button type="submit" name="language" value="es"
                        class="btn btn-sm {% if LANGUAGE_CODE == 'es' %}btn-primary{% else %}btn-outline-secondary{% endif %}">
                    <i class="fas fa-globe flag-icon-fa"></i> ES
                </button>
            </form>

            {# Botón para Inglés #}
            <form action="{% url 'set_language' %}" method="post" class="d-inline-block me-2">
                {% csrf_token %}
                {# Lógica para el 'next' URL #}
                {% if translatable_object %}
                    {% get_translated_url translatable_object 'en' as translated_url %}
                    <input type="hidden" name="next" value="{{ translated_url }}">
                {% else %}
                    <input type="hidden" name="next" value="{{ request.get_full_path }}">
                {% endif %}
                {# Fin lógica para el 'next' URL #}
                <button type="submit" name="language" value="en"
                        class="btn btn-sm {% if LANGUAGE_CODE == 'en' %}btn-primary{% else %}btn-outline-secondary{% endif %}">
                    <i class="fas fa-globe flag-icon-fa"></i> EN
                </button>
            </form>

            {# Botón para Catalán #}
            <form action="{% url 'set_language' %}" method="post" class="d-inline-block">
                {% csrf_token %}
                {# Lógica para el 'next' URL #}
                {% if translatable_object %}
                    {% get_translated_url translatable_object 'ca' as translated_url %}
                    <input type="hidden" name="next" value="{{ translated_url }}">
                {% else %}
                    <input type="hidden" name="next" value="{{ request.get_full_path }}">
                {% endif %}
                {# Fin lógica para el 'next' URL #}
                <button type="submit" name="language" value="ca"
                        class="btn btn-sm {% if LANGUAGE_CODE == 'ca' %}btn-primary{% else %}btn-outline-secondary{% endif %}">
                    <i class="fas fa-globe flag-icon-fa"></i> CA
                </button>
            </form>
        </div>
        {# --- END LANGUAGE SELECTOR --- #}

    </div>
</div>===== ./core/templates/core/partials/_footer.html =====
{# Loads the custom template tags for i18n and menus #}
{% load i18n %}
{% load menu_tags %}
 
<footer class="bg-dark text-white text-center p-3 mt-auto">
    {# Copyright notice. The 'year' variable is passed to the translation block. #}
    <p class="mb-0">
        {% now "Y" as year %}
        {% blocktranslate with year=year trimmed %}
            &copy; {{ year }} Tavata.art - Built with Django and <i class="fas fa-bee"></i> by Gustavo and Tavata.
        {% endblocktranslate %}
    </p>

    {# This section calls our custom template tag to render the footer menu. #}
    {# The menu content is managed in the Django admin via the 'footer-menu' slug. #}
    <p class="mb-0">
        {% show_menu 'footer-menu' %}
    </p>
</footer>===== ./core/__init__.py =====
./blog/views.py
# --- ./blog/views.py ---
import logging
from django.contrib import messages
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.db.models import F
from django.http import HttpResponseRedirect
from django.shortcuts import render, get_object_or_404
from django.utils.translation import gettext

from .forms import CommentForm
from .models import Post, Comment
from categories.models import Category
from site_settings.models import SiteConfiguration
from taggit.models import Tag

logger = logging.getLogger(__name__)

def posts_by_tag_view(request, tag_slug):
    """
    Displays a paginated list of published posts associated with a specific tag.
    """
    # 1. Get the Tag object by slug, or return a 404
    tag = get_object_or_404(Tag, slug=tag_slug)

    # 2. Get all published posts associated with this tag
    all_posts_by_tag = Post.objects.filter(
        status='published', tags__slug=tag_slug
    ).order_by('-published_date')

    # 3. Get pagination settings
    try:
        site_config = SiteConfiguration.get_solo()
        posts_per_page = site_config.blog_items_per_page
    except SiteConfiguration.DoesNotExist:
        posts_per_page = 6
        logger.warning("SiteConfiguration not found. Using default tag pagination.")

    # 4. Apply pagination
    paginator = Paginator(all_posts_by_tag, posts_per_page)
    page_number = request.GET.get('page')

    try:
        posts = paginator.get_page(page_number)
    except PageNotAnInteger:
        posts = paginator.get_page(1)
    except EmptyPage:
        if paginator.num_pages > 0:
            posts = paginator.get_page(paginator.num_pages)
        else:
            posts = []

    logger.info(f"Posts by tag view accessed for tag '{tag_slug}'. Showing page {getattr(posts, 'number', 0)} of {getattr(posts, 'paginator.num_pages', 0)} posts.")

    context = {
        'tag': tag,
        'posts': posts,
    }
    return render(request, 'blog/post_list_by_tag.html', context)

def post_list_view(request):
    """
    Displays a list of published blog posts, paginated.
    """
    # 1. Retrieve the full, ordered list of all published posts.
    all_posts = Post.objects.filter(status='published').order_by('-published_date')

    # 2. Create a Paginator instance.
    #    We'll show 6 posts per page. This number can be changed easily.
    try:
        config = SiteConfiguration.get_solo()
        posts_per_page = config.blog_items_per_page
    except SiteConfiguration.DoesNotExist:
        logger.warning(
                "SiteConfiguration does not exist. Using default indentation."
            )
        posts_per_page = 6  # Fallback
    paginator = Paginator(all_posts, posts_per_page)

    # 3. Get the page number from the URL's GET parameters (e.g., /blog/?page=2).
    page_number = request.GET.get('page')

    # 4. Get the specific Page object for the requested page number.
    #    This includes robust error handling.
    try:
        posts = paginator.page(page_number)
    except PageNotAnInteger:
        logger.info(
                "If the 'page' parameter is not an integer, deliver the first page."
            )
        posts = paginator.page(1)
    except EmptyPage:
        logger.isEnabledFor(
                "If the page number is out of range (e.g., 999), deliver the last page."
            )
        posts = paginator.page(paginator.num_pages)

    # 5. Prepare the context to be passed to the template.
    #    The 'posts' variable is now a Paginator's Page object, not a simple list.
    context = {
        'posts': posts,
    }

    # 6. Render the template with the provided context.
    return render(request, 'blog/post_list.html', context)

def post_detail_view(request, year, month, day, slug):
    """
    Displays a single blog post and handles the entire comment submission process,
    including view counting, smart comment approval, and user association.
    """
    # 1. Retrieve the Post and Site Configuration objects.
    # ----------------------------------------------------
    post = get_object_or_404(Post,
                             status='published',
                             published_date__year=year,
                             published_date__month=month,
                             published_date__day=day,
                             slug=slug)

    try:
        site_config = SiteConfiguration.get_solo()
    except SiteConfiguration.DoesNotExist:
        logger.error("CRITICAL: SiteConfiguration object not found. Site may not function correctly.")
        # Create a fallback object to prevent crashes.
        class FallbackConfig:
            auto_approve_comments = False
        site_config = FallbackConfig()

    # 2. Increment the View Count.
    # ---------------------------------
    post.views_count = F('views_count') + 1
    post.save(update_fields=['views_count'])
    post.refresh_from_db()

    # 3. Handle Comment Submission and Retrieval.
    # -------------------------------------------
    comments = post.comments.filter(is_approved=True)

    if request.method == 'POST':
        comment_form = CommentForm(request.POST, user=request.user)
        if comment_form.is_valid():
            new_comment = comment_form.save(commit=False)
            new_comment.post = post
            
            # --- Smart Approval Logic ---
            is_trusted = False
            if request.user.is_authenticated:
                new_comment.user = request.user
                new_comment.author_name = request.user.profile.get_display_name()
                new_comment.author_email = request.user.email
                # Check if the user has been promoted to 'Trusted'.
                is_trusted = request.user.profile.is_trusted_commenter
            
            # Approve the comment if global auto-approval is ON, OR if the specific user is trusted.
            if site_config.auto_approve_comments or is_trusted:
                new_comment.is_approved = True
                success_message = gettext("Thank you! Your comment has been published.")
                if is_trusted and not site_config.auto_approve_comments:
                    logger.info(f"Comment from trusted user '{request.user.username}' was auto-approved.")
            else:
                new_comment.is_approved = False
                success_message = gettext("Thank you! Your comment has been submitted and is awaiting moderation.")

            new_comment.save()
            messages.success(request, success_message)
            
            # Redirect using the Post/Redirect/Get pattern.
            post_url = post.get_absolute_url()
            redirect_url = f"{post_url}#comments-section"
            return HttpResponseRedirect(redirect_url)
        else:
            logger.warning(f"Invalid comment submission on post '{post.slug}'. Errors: {comment_form.errors.as_json()}")
    else:
        # For a GET request, create a blank form instance.
        comment_form = CommentForm(user=request.user)

    # 4. Prepare the final context for the template.
    # ----------------------------------------------------
    context = {
        'post': post,
        'comments': comments,
        'comment_form': comment_form,
        'translatable_object': post,
    }
    return render(request, 'blog/post_detail.html', context)

def posts_by_category_view(request, category_slug):
    """
    Filters and displays a paginated list of published posts
    belonging to a specific blog category.
    """
    # --- 1. Get Base Data ---
    category = get_object_or_404(Category, slug=category_slug)
    all_posts_in_category = category.blog_posts.filter(status='published').order_by('-published_date')

    # --- 2. Get Pagination Settings ---
    try:
        config = SiteConfiguration.get_solo()
        posts_per_page = config.blog_items_per_page
    except SiteConfiguration.DoesNotExist:
        logger.warning(
            "SiteConfiguration does not exist. Using default pagination settings."
        )
        posts_per_page = 6  # Fallback

    # --- 3. Apply Pagination ---
    paginator = Paginator(all_posts_in_category, posts_per_page)
    page_number = request.GET.get('page')

    try:
        posts = paginator.page(page_number)
    except PageNotAnInteger:
        # If the 'page' parameter is not an integer, deliver the first page.
        logger.info("Page number is not an integer, delivering the first page.")
        posts = paginator.page(1)
    except EmptyPage:
        # If the page number is out of range (e.g., 999), deliver the last page.
        logger.info("Page number is out of range, delivering the last page.")
        posts = paginator.page(paginator.num_pages)

    # --- 4. Prepare Context and Render ---
    context = {
        'category': category,
        'posts': posts,  # Pass the paginated 'posts' object
    }
    return render(request, 'blog/post_list_by_category.html', context)

./blog/forms.py
# --- ./blog/forms.py ---
# File: blog/forms.py
import logging
from django import forms
from django.utils.translation import gettext_lazy as _
from .models import Comment

# Get a logger instance for this module
logger = logging.getLogger(__name__)

class CommentForm(forms.ModelForm):
    """
    A form for users to submit comments.
    It dynamically adjusts fields based on whether the user is authenticated.
    """

    class Meta:
        model = Comment
        # The user will fill out these fields.
        # 'parent' is for handling replies and will be a hidden field.
        # 'user' and 'post' will be assigned in the view.
        fields = ['content', 'parent', 'author_name', 'author_email']
        
        # We use a HiddenInput for the 'parent' field. Its value will be set by JavaScript.
        widgets = {
            'parent': forms.HiddenInput(),
        }


    def __init__(self, *args, **kwargs):
        # We pop the 'user' object passed from the view.
        # It will be None if the user is not authenticated.
        self.user = kwargs.pop('user', None)
        super().__init__(*args, **kwargs)

        # --- Customize fields with Bootstrap classes and placeholders ---
        self.fields['content'].widget = forms.Textarea(attrs={
            'class': 'form-control', 
            'rows': 4,
            'placeholder': _('Write your comment here...')
        })
        self.fields['author_name'].widget = forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': _('Your Name (required)')
        })
        self.fields['author_email'].widget = forms.EmailInput(attrs={
            'class': 'form-control',
            'placeholder': _('Your Email (required, not published)')
        })
        
        # --- Dynamic field logic based on user authentication ---
        if self.user and self.user.is_authenticated:
            # If the user is logged in, we don't need them to enter their name and email.
            # We hide these fields and make them not required.
            self.fields['author_name'].required = False
            self.fields['author_email'].required = False
            
            # Instead of removing them, we turn them into hidden fields.
            # This way, the view can still populate them with the user's data for consistency.
            self.fields['author_name'].widget = forms.HiddenInput()
            self.fields['author_email'].widget = forms.HiddenInput()
            
            # Log that we are customizing the form for a logged-in user.
            logger.debug(f"Customizing CommentForm for authenticated user: {self.user.username}")


    def clean(self):
        # We log form errors to help with debugging validation issues.
        if self.errors:
            logger.warning(f"CommentForm validation failed. Errors: {self.errors.as_json()}")
        return super().clean()./blog/migrations/0002_post_tags.py
# --- ./blog/migrations/0002_post_tags.py ---
# Generated by Django 5.2.3 on 2025-06-22 13:21

import taggit.managers
from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('blog', '0001_initial'),
        ('taggit', '0006_rename_taggeditem_content_type_object_id_taggit_tagg_content_8fc721_idx'),
    ]

    operations = [
        migrations.AddField(
            model_name='post',
            name='tags',
            field=taggit.managers.TaggableManager(blank=True, help_text='A comma-separated list of tags.', through='taggit.TaggedItem', to='taggit.Tag', verbose_name='Tags'),
        ),
    ]
./blog/migrations/0001_initial.py
# --- ./blog/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
import django.utils.timezone
import mptt.fields
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('categories', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Post',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=250, verbose_name='Title')),
                ('title_es', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_en', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_ca', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('slug', models.SlugField(max_length=250, unique_for_date='published_date', verbose_name='Slug')),
                ('slug_es', models.SlugField(max_length=250, null=True, unique_for_date='published_date', verbose_name='Slug')),
                ('slug_en', models.SlugField(max_length=250, null=True, unique_for_date='published_date', verbose_name='Slug')),
                ('slug_ca', models.SlugField(max_length=250, null=True, unique_for_date='published_date', verbose_name='Slug')),
                ('content', models.TextField(verbose_name='Content')),
                ('content_es', models.TextField(null=True, verbose_name='Content')),
                ('content_en', models.TextField(null=True, verbose_name='Content')),
                ('content_ca', models.TextField(null=True, verbose_name='Content')),
                ('featured_image', models.ImageField(blank=True, null=True, upload_to='blog/featured/%Y/%m/%d/', verbose_name='Featured Image')),
                ('published_date', models.DateTimeField(default=django.utils.timezone.now, verbose_name='Published Date')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('published', 'Published')], default='draft', max_length=10, verbose_name='Status')),
                ('meta_title', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_es', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_en', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_ca', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_description', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_es', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_en', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_ca', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('views_count', models.PositiveIntegerField(default=0, verbose_name='View Count')),
                ('editor_rating', models.PositiveIntegerField(default=0, help_text='A score from 0-100 to feature this post. Higher numbers appear first.', verbose_name="Editor's Rating")),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='blog_posts', to=settings.AUTH_USER_MODEL, verbose_name='Author')),
                ('categories', models.ManyToManyField(blank=True, related_name='blog_posts', to='categories.category', verbose_name='Categories')),
            ],
            options={
                'verbose_name': 'blog post',
                'verbose_name_plural': 'blog posts',
                'ordering': ('-published_date',),
            },
        ),
        migrations.CreateModel(
            name='Comment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('author_name', models.CharField(blank=True, max_length=100, verbose_name='Author Name')),
                ('author_email', models.EmailField(blank=True, max_length=254, verbose_name='Author Email')),
                ('content', models.TextField(verbose_name='Content')),
                ('content_es', models.TextField(null=True, verbose_name='Content')),
                ('content_en', models.TextField(null=True, verbose_name='Content')),
                ('content_ca', models.TextField(null=True, verbose_name='Content')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Created At')),
                ('is_approved', models.BooleanField(default=False, verbose_name='Is Approved?')),
                ('lft', models.PositiveIntegerField(editable=False)),
                ('rght', models.PositiveIntegerField(editable=False)),
                ('tree_id', models.PositiveIntegerField(db_index=True, editable=False)),
                ('level', models.PositiveIntegerField(editable=False)),
                ('parent', mptt.fields.TreeForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='blog.comment', verbose_name='Parent Comment')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='comments_made', to=settings.AUTH_USER_MODEL, verbose_name='User')),
                ('post', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='comments', to='blog.post', verbose_name='Post')),
            ],
            options={
                'verbose_name': 'comment',
                'verbose_name_plural': 'comments',
            },
        ),
    ]
./blog/migrations/__init__.py
# --- ./blog/migrations/__init__.py ---
./blog/admin.py
# --- ./blog/admin.py ---
# File: blog/admin.py
import logging
from django.contrib import admin
from django.db.models import Count # Required for Count() in CommentAdmin's save_model
from django.utils.translation import gettext_lazy as _
from django.conf import settings # Required for dynamically generating search fields

# Third-party imports (ensure these are installed and in INSTALLED_APPS)
from django_summernote.admin import SummernoteModelAdmin # For WYSIWYG editor on Post
from modeltranslation.admin import TabbedTranslationAdmin # For multilingual admin
from mptt.admin import MPTTModelAdmin # For tree display on Comment
from modeltranslation.translator import translator, NotRegistered # For dynamic admin fields

# Local application imports (ensure these models exist)
from .models import Post, Comment # PostCategory is no longer in blog.models
from categories.models import Category # Universal Category model
from site_settings.models import SiteConfiguration # For configurable settings

# Import the Tag model, needed for custom TagAdmin setup
from taggit.models import Tag


logger = logging.getLogger(__name__)

# --- Helper functions for dynamic admin fields ---
# These functions are defined here to be self-contained within blog/admin.py.
# If they are used across many admin files, it's better to move them to a shared utility file (e.g., core/admin_helpers.py)
# and import them from there.

def get_language_aware_prepopulated_fields(model_kls):
    """
    Dynamically generates the prepopulated_fields dictionary for a ModelAdmin,
    considering translatable slug and title/name fields for all configured languages.
    """
    prepopulated_fields_dict = {}
    
    # Get translation options for the given model
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except NotRegistered:
        logger.warning(f"Model {model_kls.__name__} not registered for translation. "
                       f"Dynamic prepopulated_fields might be incomplete.")
        return prepopulated_fields_dict # Return empty dict if not translatable

    # Check if the model has a 'slug' field and a 'title' or 'name' field that is translatable
    has_slug = hasattr(model_kls, 'slug')
    has_translatable_title = 'title' in trans_opts.fields if trans_opts else False
    has_translatable_name = 'name' in trans_opts.fields if trans_opts else False

    if has_slug and (has_translatable_title or has_translatable_name):
        source_field_name = 'title' if has_translatable_title else 'name'
        for lang_code, _ in settings.LANGUAGES:
            # For each language, link the slug field (e.g., 'slug_en')
            # to the corresponding title/name field (e.g., 'title_en' or 'name_en').
            prepopulated_fields_dict[f'slug_{lang_code}'] = (f'{source_field_name}_{lang_code}',)
    
    # Special handling for `Menu` model where slug is not translatable but derived from a translatable title
    # This block is specific to the `Menu` model ONLY if it is included in this admin.
    # It would typically be in `menus/admin.py`, but leaving it here for completeness if needed elsewhere.
    if model_kls.__name__ == 'Menu' and has_slug and has_translatable_title:
        # Assuming 'Menu' model's slug is not translatable, but its 'title' is.
        # This will prepopulate the single 'slug' field from the title of the default language.
        prepopulated_fields_dict['slug'] = (f'title_{settings.LANGUAGE_CODE}',)

    return prepopulated_fields_dict


def get_language_aware_search_fields(model_kls, fields_to_include=None):
    """
    Dynamically generates a tuple of search fields for a model in all configured languages.
    Assumes common translatable text fields ('title', 'name', 'content', 'description').
    """
    search_fields_list = []
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except NotRegistered:
        # If the model is not registered for translation, return only basic non-translated fields if specified.
        # Or an empty tuple if no specific fields are requested.
        return (fields_to_include,) if fields_to_include else tuple()

    # Determine which translatable fields to use for search
    actual_fields_to_search = fields_to_include if fields_to_include else trans_opts.fields

    for lang_code, _ in settings.LANGUAGES:
        for field_name in actual_fields_to_search:
            if field_name in trans_opts.fields: # Ensure the field is actually translatable
                search_fields_list.append(f'{field_name}_{lang_code}')
            # If default non-translatable fields should also be included in search, add them here
            # For example: if 'id' or other non-translatable fields are in fields_to_include, add them directly.

    return tuple(search_fields_list)

class TagAdmin(TabbedTranslationAdmin): # <-- THIS IS KEY! Must inherit from TabbedTranslationAdmin
    """
    Custom Admin for Taggit's Tag model.
    It integrates modeltranslation to allow translation of tag names directly in the admin.
    """
    list_display = ('name',) # Display the 'name' field, which TabbedTranslationAdmin will handle
    list_display_links = ('name',) # Clickable by name
    ordering = ('name',) # Order by the currently active language's name

    # Search fields must target translated fields
    search_fields = get_language_aware_search_fields(Tag, fields_to_include=['name']) # Uses name_en, name_es, etc.
    
    # prepopulated_fields will use translated name fields for slug
    # Tag.slug is generally not translated, but derived from the name of the default language
    prepopulated_fields = {'slug': (f'name_{settings.LANGUAGE_CODE}',)}

    # Ensure 'name' and 'slug' fields appear in the form.
    # TabbedTranslationAdmin patches 'name' to show tabs automatically.
    fields = ('name', 'slug') # Only list 'name' and 'slug' here.


# --- ADMIN FOR BLOG POSTS ---
@admin.register(Post)
class PostAdmin(SummernoteModelAdmin, TabbedTranslationAdmin):
    """
    Admin options for the Post model, integrating Summernote for content,
    ModelTranslation for multilingual fields, and managing categories via ManyToMany.
    """
    list_display = ('title', 'author', 'status', 'published_date', 'views_count', 'editor_rating', 'display_categories_list')
    list_filter = ('status', 'published_date', 'author')
    date_hierarchy = 'published_date'
    ordering = ('status', '-published_date')
    list_editable = ('status', 'editor_rating')
    
    # Dynamically generate search_fields using the helper function for 'title' and 'content'
    search_fields = get_language_aware_search_fields(Post, fields_to_include=['title', 'content'])

    # Dynamically generate prepopulated_fields for slugs in all languages.
    # Assumes 'Post.slug' is translatable AND 'Post.title' is translatable.
    prepopulated_fields = get_language_aware_prepopulated_fields(Post)

    # Summernote fields must be specified for each language (e.g., 'content_en')
    summernote_fields = tuple([f'content_{lang_code}' for lang_code, _ in settings.LANGUAGES])
    
    # ManyToManyField for categories, uses a nice multi-selector interface
    filter_horizontal = ('categories',) 

    # Custom method to display categories in the list view
    @admin.display(description=_("Categories"))
    def display_categories_list(self, obj):
        return ", ".join([cat.name for cat in obj.categories.all()])


# --- ADMIN FOR COMMENTS ---
@admin.register(Comment)
class CommentAdmin(MPTTModelAdmin):
    """
    Admin options for the Comment model.
    Uses MPTTModelAdmin for tree display and includes logic for user promotion.
    """
    list_display = ('__str__', 'post', 'author_name', 'created_at', 'is_approved')
    list_display_links = ('__str__',)
    list_filter = ('is_approved', 'created_at', 'post')
    list_editable = ('is_approved',)
    search_fields = ('content', 'author_name', 'author_email') # These are typically not translatable
    readonly_fields = ('post', 'parent', 'user', 'author_name', 'author_email', 'content', 'created_at')
    
    @property
    def mptt_level_indent(self):
        try:
            return SiteConfiguration.get_solo().comment_indentation_pixels
        except SiteConfiguration.DoesNotExist:
            logger.warning("SiteConfiguration not found. Using default mptt_level_indent of 20.")
            return 20

    def save_model(self, request, obj, form, change):
        """
        Custom save logic to auto-promote users to 'Trusted Commenter' status
        when their comments are approved.
        """
        super().save_model(request, obj, form, change)
        
        if 'is_approved' in form.changed_data and obj.is_approved and obj.user:
            try:
                user_profile = obj.user.profile
                if not user_profile.is_trusted_commenter:
                    try:
                        config = SiteConfiguration.get_solo()
                        approval_threshold = config.trusted_commenter_threshold
                    except SiteConfiguration.DoesNotExist:
                        approval_threshold = 10 
                        logger.warning("SiteConfiguration not found. Using default commenter threshold of 10.")
                    
                    approved_comment_count = Comment.objects.filter(user=obj.user, is_approved=True).count()
                    
                    if approved_comment_count >= approval_threshold:
                        user_profile.is_trusted_commenter = True
                        user_profile.save(update_fields=['is_trusted_commenter'])
                        logger.info(f"User '{obj.user.username}' auto-promoted to Trusted Commenter.")
            except Exception as e:
                logger.error(f"Error during user promotion logic for user '{obj.user.username}': {e}", exc_info=True)./blog/urls.py
# --- ./blog/urls.py ---
# blog/urls.py
from django.urls import path
from . import views

# Esto es importante para evitar colisiones de nombres de URL con otras apps
app_name = 'blog'

urlpatterns = [
    # 1. La URL raíz del blog, que mostrará la lista de posts
    # Ejemplo: /blog/
    path('', views.post_list_view, name='post_list'),

    # ¡NUEVA RUTA! Para listar posts de una categoría específica
    # Ejemplo: /blog/category/desarrollo-web/
    path('category/<slug:category_slug>/', views.posts_by_category_view, name='posts_by_category'),
    path('tag/<slug:tag_slug>/', views.posts_by_tag_view, name='posts_by_tag'),
    # 2. La URL para un post individual, usando año, mes, día y slug
    # Ejemplo: /blog/2025/06/15/mi-primer-post/
    path('<int:year>/<int:month>/<int:day>/<slug:slug>/', views.post_detail_view, name='post_detail'),
]./blog/translation.py
# --- ./blog/translation.py ---
# File: blog/translation.py
from modeltranslation.translator import register, TranslationOptions
# Solo importamos los modelos que SÍ existen en blog.models
from .models import Post, Comment 
from taggit.models import Tag 

# La clase para PostCategory ha sido eliminada.

@register(Post)
class PostTranslationOptions(TranslationOptions):
    fields = ('title', 'slug', 'content', 'meta_title', 'meta_description')

@register(Comment)
class CommentTranslationOptions(TranslationOptions):
    fields = ('content',)

@register(Tag)
class TagTranslationOptions(TranslationOptions):
    """
    Registers django-taggit's Tag model for translation,
    making tag names multilingual.
    """
    fields = ('name',)./blog/signals.py
# --- ./blog/signals.py ---
# File: blog/signals.py
import logging
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.contrib.auth.models import User # For promoting trusted commenters
from django.conf import settings 

from .models import Post, Comment # Import Post and Comment for sender
from site_settings.models import SiteConfiguration # For cache timeouts and threshold from SiteConfiguration


logger = logging.getLogger(__name__)


# --- Signal to clear Widget caches on Post changes ---
@receiver([post_save, post_delete], sender=Post)
def clear_widget_caches_on_post_change(sender, instance, **kwargs):
    """
    Clears all widget caches related to posts whenever a Post is saved or deleted.
    This ensures that 'Recent Posts', 'Most Viewed', 'Editor's Picks' widgets are updated.
    """
    # Import Widget model specifically here to avoid circular dependency issues at startup
    from widgets.models import Widget 
    num_widgets_cleared = 0
    # A simple but effective strategy: clear ALL widget caches.
    # We iterate over all widgets that deal with posts.
    relevant_widget_types = ['recent_posts', 'tag_cloud_widget', 'most_viewed_posts', 'most_commented_posts', 'editor_picks_posts'] # Add other post-related widgets
    
    for widget in Widget.objects.filter(widget_type__in=relevant_widget_types): # Filter to relevant ones
        for lang_code, _ in settings.LANGUAGES: # Clear for each language
            cache_key = f'widget_items_{widget.id}_{lang_code}_v1' # Use 'v1'
            cache.delete(cache_key)
            num_widgets_cleared += 1
    logger.info(f"Cleared {num_widgets_cleared} widget caches due to Post change (ID: {instance.id}).")


# --- Signal for User Promotion to Trusted Commenter ---
@receiver(post_save, sender=Comment)
def promote_user_on_comment_approval(sender, instance, created, **kwargs):
    """
    Promotes a user to 'Trusted Commenter' status if they reach the configured
    threshold of approved comments. This signal runs when a Comment is saved.
    """
    # Only proceed if the comment is approved AND it's made by a registered user.
    if instance.is_approved and instance.user:
        try:
            # We import User's Profile here to avoid circular dependency at startup
            from accounts.models import Profile 
            user_profile = Profile.objects.get(user=instance.user)
            
            # Only promote if the user is not already trusted.
            if not user_profile.is_trusted_commenter:

                site_config = SiteConfiguration.get_solo()
                approval_threshold = getattr(site_config, 'trusted_commenter_threshold', 10) # Fallback to 10


                # Count all approved comments by this user.
                approved_comment_count = Comment.objects.filter(
                    user=instance.user, 
                    is_approved=True
                ).count()
                
                if approved_comment_count >= approval_threshold:
                    user_profile.is_trusted_commenter = True
                    user_profile.save(update_fields=['is_trusted_commenter'])
                    logger.info(f"User '{instance.user.username}' auto-promoted to Trusted Commenter (threshold: {approval_threshold} comments).")
        
        except Profile.DoesNotExist:
            logger.warning(f"Comment from user '{instance.user.username}' (ID: {instance.user.id}) has no associated Profile. Cannot check trusted status.")
        except Exception as e:
            logger.error(f"Unexpected error in promote_user_on_comment_approval for user '{instance.user.username}': {e}", exc_info=True)./blog/apps.py
# --- ./blog/apps.py ---
# File: blog/apps.py
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class BlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'blog'

    def ready(self):
        """
        Connects signals and explicitly registers ModelAdmins for third-party apps.
        """
        import blog.signals # Connects blog signals
        
        # --- Explicitly register our custom TagAdmin. ---
        try:
            from django.contrib import admin
            from taggit.models import Tag
            from .admin import TagAdmin # Import our custom TagAdmin from blog/admin.py

            # Check if default TagAdmin is already registered (it normally is by taggit).
            if admin.site.is_registered(Tag): 
                admin.site.unregister(Tag) # Unregister the default one.
                logger.info("Unregistered default Taggit TagAdmin.")
            
            # Register our custom TagAdmin.
            admin.site.register(Tag, TagAdmin) 
            logger.debug("Successfully registered custom Blog app's TagAdmin.")

        except Exception as e:
            logger.error(f"Error registering custom TagAdmin: {e}", exc_info=True)
            # Log the error but don't re-raise, so Django can continue loading other apps.
            # If this becomes a problem, consider re-raising../blog/models.py
# --- ./blog/models.py ---
# File: blog/models.py
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from mptt.models import MPTTModel, TreeForeignKey
from categories.models import Category 
from taggit.managers import TaggableManager
from django.utils.translation import override 

class Post(models.Model):
    """ Represents a single blog post. """

    class Status(models.TextChoices):
        DRAFT = 'draft', _('Draft')
        PUBLISHED = 'published', _('Published')
        
    title = models.CharField(max_length=250, verbose_name=_("Title"))
    slug = models.SlugField(max_length=250, unique_for_date='published_date', verbose_name=_("Slug"))
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='blog_posts', verbose_name=_("Author"))
    
    content = models.TextField(verbose_name=_("Content"))
    featured_image = models.ImageField(
        upload_to='blog/featured/%Y/%m/%d/', 
        blank=True, 
        null=True, 
        verbose_name=_("Featured Image")
    )
    
    published_date = models.DateTimeField(default=timezone.now, verbose_name=_("Published Date"))
    status = models.CharField(max_length=10, choices=Status.choices, default=Status.DRAFT, verbose_name=_("Status"))
    
    # --- CORRECTED CATEGORY RELATIONSHIP ---
    # Using a ManyToManyField is simpler and more efficient for querying than GenericRelation.
    categories = models.ManyToManyField(
        Category,
        blank=True,
        verbose_name=_("Categories"),
        related_name="blog_posts"
    )

    # --- SEO and Curation Fields ---
    meta_title = models.CharField(max_length=70, blank=True, null=True, verbose_name=_("Meta Title (SEO)"))
    meta_description = models.CharField(max_length=160, blank=True, null=True, verbose_name=_("Meta Description (SEO)"))
    views_count = models.PositiveIntegerField(default=0, verbose_name=_("View Count"))
    editor_rating = models.PositiveIntegerField(
        default=0,
        verbose_name=_("Editor's Rating"),
        help_text=_("A score from 0-100 to feature this post. Higher numbers appear first.")
    )

    # --- Timestamps ---
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    tags = TaggableManager(
        verbose_name=_("Tags"),
        help_text=_("A comma-separated list of tags."),
        blank=True # Allows posts to have no tags
    )

    class Meta:
        ordering = ('-published_date',)
        verbose_name = _("blog post")
        verbose_name_plural = _("blog posts")

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse('blog:post_detail', args=[
            self.published_date.year,
            self.published_date.month,
            self.published_date.day,
            self.slug
        ])
    
    def get_absolute_url_for_language(self, language_code):
        with override(language_code):
            # 'self.slug' automáticamente devuelve el slug para el idioma del contexto que acabamos de setear con override.
            return reverse('blog:post_detail', args=[
                self.published_date.year,
                self.published_date.month,
                self.published_date.day,
                self.slug
            ])


class Comment(MPTTModel):
    """ Represents a single, nestable comment on a blog post. """
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments', verbose_name=_("Post"))
    parent = TreeForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, related_name='children', db_index=True, verbose_name=_("Parent Comment"))
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='comments_made', verbose_name=_("User"))
    author_name = models.CharField(max_length=100, blank=True, verbose_name=_("Author Name"))
    author_email = models.EmailField(blank=True, verbose_name=_("Author Email"))
    content = models.TextField(verbose_name=_("Content"))
    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Created At"))
    is_approved = models.BooleanField(default=False, verbose_name=_("Is Approved?"))

    class MPTTMeta:
        order_insertion_by = ['created_at']

    class Meta:
        verbose_name = _("comment")
        verbose_name_plural = _("comments")

    def __str__(self):
        return f"{'--' * self.level} Comment by {self.get_author_name()}"
    
    def get_author_name(self):
        if self.user:
            return self.user.profile.get_display_name()
        return self.author_name

    def get_author_avatar_url(self):
        from django.templatetags.static import static
        if self.user and hasattr(self.user, 'profile') and self.user.profile.avatar:
            default_paths = [c[0] for c in self.user.profile.AvatarChoice.choices]
            if self.user.profile.avatar.name not in default_paths:
                return self.user.profile.avatar.url
            return static(self.user.profile.default_avatar_choice)
        
        return static('images/avatars/default_anonymous.png')./blog/tests.py
# --- ./blog/tests.py ---
from django.test import TestCase

# Create your tests here.
./blog/__init__.py
# --- ./blog/__init__.py ---
./passenger_wsgi.py
# --- ./passenger_wsgi.py ---
import os
import sys

# Asegura que el directorio del proyecto esté en el PATH
project_home = '/home/sextavac/tvt'
if project_home not in sys.path:
    sys.path.insert(0, project_home)

# Configura la variable DJANGO_SETTINGS_MODULE a tu settings
os.environ['DJANGO_SETTINGS_MODULE'] = 'tvt.settings'

# Obtén la aplicación WSGI de Django
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()./core/views.py
# --- ./core/views.py ---
# core/views.py
import logging
from django.shortcuts import render
from pages.models import Page

# Get a logger instance for this module.
logger = logging.getLogger(__name__)

def home(request):
    """
    Finds the page marked as the 'homepage' in the database and renders it.
    If no homepage is set, it displays a default view.
    """
    logger.info(f"Homepage requested by user: {request.user.username or 'Anonymous'}")

    homepage = None
    try:
        homepage = Page.objects.filter(is_homepage=True, status='published').latest('updated_at')
        logger.debug(f"Serving homepage: '{homepage.title}' (ID: {homepage.id})")

    except Page.DoesNotExist:
        # This is a configuration warning, not an error. The site still works.
        logger.warning("No published page has been configured as the homepage. Serving a placeholder.")
        # The template itself handles displaying a user-friendly message.
        
    except Exception as e:
        # Catch any other unexpected database or logic errors.
        logger.error(
            f"An unexpected error occurred while fetching the homepage.",
            exc_info=True # Include the full traceback for debugging.
        )
        # In this case, homepage remains None, and the template will show a message.
        # A more robust solution might render a 500 error page.

    context = {
        'page': homepage,
    }

    return render(request, 'pages/page_detail.html', context)./core/migrations/__init__.py
# --- ./core/migrations/__init__.py ---
./core/admin.py
# --- ./core/admin.py ---
from django.contrib import admin

# Register your models here.
./core/urls.py
# --- ./core/urls.py ---
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]./core/apps.py
# --- ./core/apps.py ---
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'./core/models.py
# --- ./core/models.py ---
from django.db import models

# Create your models here.
./core/tests.py
# --- ./core/tests.py ---
from django.test import TestCase

# Create your tests here.
./core/__init__.py
# --- ./core/__init__.py ---
./core/templatetags/url_utils.py
# --- ./core/templatetags/url_utils.py ---
# core/templatetags/url_utils.py
from django import template

register = template.Library()

@register.simple_tag
def get_translated_url(obj, language_code):
    """
    Calls the get_absolute_url_for_language method on a given object
    and returns its result.
    Assumes the object has a method named 'get_absolute_url_for_language'.
    """
    if hasattr(obj, 'get_absolute_url_for_language'):
        return obj.get_absolute_url_for_language(language_code)
    # Fallback to current object's URL if method not found
    return obj.get_absolute_url() if hasattr(obj, 'get_absolute_url') else '#'./search/views.py
# --- ./search/views.py ---
# search/views.py
import logging
from django.shortcuts import render
from django.db.models import Q
from django.core.paginator import Paginator

from pages.models import Page
from blog.models import Post
from site_settings.models import SiteConfiguration

logger = logging.getLogger(__name__)

def search_results_view(request):
    """
    Performs a search across Pages and Blog Posts, ordering Pages by importance,
    and paginates the results correctly.
    """
    try:
        site_config = SiteConfiguration.get_solo()
        pages_per_page = site_config.search_pages_per_page
        posts_per_page = site_config.search_posts_per_page
    except SiteConfiguration.DoesNotExist:
        logger.warning("SiteConfiguration does not exist. Using default pagination settings.")
        pages_per_page = 5
        posts_per_page = 5

    query = request.GET.get('q', '')
    
    # Initialize with empty QuerySets
    page_results_qs = Page.objects.none()
    post_results_qs = Post.objects.none()

    if query:
        # Build the Q objects for the search query
        page_query = Q(title__icontains=query) | Q(content__icontains=query)
        post_query = Q(title__icontains=query) | Q(content__icontains=query)

        # --- ¡LA LÓGICA CORRECTA! ---
        # 1. Obtenemos TODAS las páginas que coinciden con la búsqueda.
        # 2. LUEGO, las ordenamos por importancia y después por título.
        page_results_qs = Page.objects.filter(page_query, status='published') \
                                      .distinct() \
                                      .order_by('importance_order', 'title')
        
        post_results_qs = Post.objects.filter(post_query, status='published') \
                                      .distinct().order_by('-published_date')

    # --- Paginación (ahora sobre los QuerySets correctos) ---
    page_paginator = Paginator(page_results_qs, pages_per_page)
    page_page_number = request.GET.get('p_page', 1)
    paginated_page_results = page_paginator.get_page(page_page_number)
    
    post_paginator = Paginator(post_results_qs, posts_per_page)
    post_page_number = request.GET.get('p_post', 1)
    paginated_post_results = post_paginator.get_page(post_page_number)
    
    # --- Contexto ---
    total_results = page_results_qs.count() + post_results_qs.count()

    context = {
        'query': query,
        'page_results': paginated_page_results,
        'post_results': paginated_post_results,
        'total_results': total_results,
    }

    return render(request, 'search/search_results.html', context)./search/migrations/__init__.py
# --- ./search/migrations/__init__.py ---
./search/admin.py
# --- ./search/admin.py ---
from django.contrib import admin

# Register your models here.
./search/urls.py
# --- ./search/urls.py ---
# search/urls.py
from django.urls import path
from . import views

app_name = 'search'

urlpatterns = [
    path('', views.search_results_view, name='search_results'),
]./search/apps.py
# --- ./search/apps.py ---
from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'
./search/models.py
# --- ./search/models.py ---
from django.db import models

# Create your models here.
./search/tests.py
# --- ./search/tests.py ---
from django.test import TestCase

# Create your tests here.
./search/__init__.py
# --- ./search/__init__.py ---
./categories/views.py
# --- ./categories/views.py ---
# File: categories/views.py
from django.shortcuts import render
from .models import Category

def category_tree_view(request):
    """
    Provides the root nodes for rendering a full category tree.
    """
    # We fetch ONLY the top-level categories.
    root_nodes = Category.objects.filter(parent__isnull=True)

    context = {
        'categories': root_nodes,
    }
    return render(request, 'categories/category_tree.html', context)./categories/migrations/0001_initial.py
# --- ./categories/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Category',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, verbose_name='Name')),
                ('name_es', models.CharField(max_length=100, null=True, verbose_name='Name')),
                ('name_en', models.CharField(max_length=100, null=True, verbose_name='Name')),
                ('name_ca', models.CharField(max_length=100, null=True, verbose_name='Name')),
                ('slug', models.SlugField(max_length=100, unique=True, verbose_name='Slug')),
                ('slug_es', models.SlugField(max_length=100, null=True, unique=True, verbose_name='Slug')),
                ('slug_en', models.SlugField(max_length=100, null=True, unique=True, verbose_name='Slug')),
                ('slug_ca', models.SlugField(max_length=100, null=True, unique=True, verbose_name='Slug')),
                ('description', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', verbose_name='Description')),
                ('description_es', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', null=True, verbose_name='Description')),
                ('description_en', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', null=True, verbose_name='Description')),
                ('description_ca', models.TextField(blank=True, help_text='An optional description for the category, can be shown on category pages.', null=True, verbose_name='Description')),
                ('meta_title', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, verbose_name='Meta Title (SEO)')),
                ('meta_title_es', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_en', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_ca', models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_description', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, verbose_name='Meta Description (SEO)')),
                ('meta_description_es', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_en', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_ca', models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('lft', models.PositiveIntegerField(editable=False)),
                ('rght', models.PositiveIntegerField(editable=False)),
                ('tree_id', models.PositiveIntegerField(db_index=True, editable=False)),
                ('level', models.PositiveIntegerField(editable=False)),
                ('parent', mptt.fields.TreeForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='categories.category', verbose_name='Parent Category')),
            ],
            options={
                'verbose_name': 'Category',
                'verbose_name_plural': 'Categories',
            },
        ),
    ]
./categories/migrations/0002_alter_category_options_alter_category_description_and_more.py
# --- ./categories/migrations/0002_alter_category_options_alter_category_description_and_more.py ---
# Generated by Django 5.2.3 on 2025-06-19 21:04

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('categories', '0001_initial'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='category',
            options={'ordering': ['name'], 'verbose_name': 'Category', 'verbose_name_plural': 'Categories'},
        ),
        migrations.AlterField(
            model_name='category',
            name='description',
            field=models.TextField(blank=True, help_text='An optional description for the category.', verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='description_ca',
            field=models.TextField(blank=True, help_text='An optional description for the category.', null=True, verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='description_en',
            field=models.TextField(blank=True, help_text='An optional description for the category.', null=True, verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='description_es',
            field=models.TextField(blank=True, help_text='An optional description for the category.', null=True, verbose_name='Description'),
        ),
        migrations.AlterField(
            model_name='category',
            name='meta_description',
            field=models.CharField(blank=True, help_text='A short description for search engine previews (max 160 chars).', max_length=160, null=True, verbose_name='Meta Description (SEO)'),
        ),
        migrations.AlterField(
            model_name='category',
            name='meta_title',
            field=models.CharField(blank=True, help_text='A precise title for search engine results (max 70 chars).', max_length=70, null=True, verbose_name='Meta Title (SEO)'),
        ),
        migrations.AlterField(
            model_name='category',
            name='parent',
            field=mptt.fields.TreeForeignKey(blank=True, help_text='Select a parent to create a sub-category.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='categories.category', verbose_name='Parent Category'),
        ),
    ]
./categories/migrations/__init__.py
# --- ./categories/migrations/__init__.py ---
./categories/admin.py
# --- ./categories/admin.py ---
# File: categories/admin.py
import logging
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from django.conf import settings 

# Third-party imports
from mptt.admin import DraggableMPTTAdmin 
from modeltranslation.admin import TabbedTranslationAdmin
from modeltranslation.translator import translator 

# Local application imports (ensure this model exists in categories.models)
from .models import Category


logger = logging.getLogger(__name__)


# Helper function to dynamically generate prepopulated_fields for multi-language slugs.
def get_language_aware_prepopulated_fields(model_kls):
    prepopulated_fields_dict = {}
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except translator.NotRegistered:
        logger.warning(f"Model {model_kls.__name__} not registered for translation. "
                       f"Dynamic prepopulated_fields might be incomplete.")
        return prepopulated_fields_dict 

    has_slug = hasattr(model_kls, 'slug')
    has_translatable_name = 'name' in trans_opts.fields if trans_opts else False

    if has_slug and has_translatable_name:
        for lang_code, _ in settings.LANGUAGES:
            prepopulated_fields_dict[f'slug_{lang_code}'] = (f'name_{lang_code}',)
                
    return prepopulated_fields_dict


# Helper function to dynamically generate search_fields for translatable models.
def get_language_aware_search_fields(model_kls):
    """
    Generates a tuple of search fields for a model in all configured languages.
    Assumes 'name' and 'description' are common translatable text fields.
    """
    search_fields_list = []
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except translator.NotRegistered:
        return tuple() 

    for lang_code, _ in settings.LANGUAGES:
        if 'name' in trans_opts.fields:
            search_fields_list.append(f'name_{lang_code}')
        if 'description' in trans_opts.fields: # Assuming description is also a common searchable field
            search_fields_list.append(f'description_{lang_code}')

    return tuple(search_fields_list)


@admin.register(Category)
class CategoryAdmin(TabbedTranslationAdmin, DraggableMPTTAdmin):
    """
    Admin options for the universal Category model.
    It combines TabbedTranslationAdmin for multilingual fields
    and DraggableMPTTAdmin for intuitive drag-and-drop hierarchy management.
    """
    
    # --- MPTT Configuration ---
    list_display = (
        'tree_actions',    
        'indented_title',  
        'slug',            
        # --- REMOVE THIS LINE ---
        # get_language_aware_search_fields.description # This line caused the error!
    )
    list_display_links = ('indented_title',) 

    mptt_level_indent = 20 

    # --- ModelTranslation Configuration ---
    prepopulated_fields = get_language_aware_prepopulated_fields(Category)
    
    # --- Standard Django Admin Configuration ---
    search_fields = get_language_aware_search_fields(Category)
    
    # --- Optional: Custom field for post count (ensure blog_posts is defined in models.py) ---
    # @admin.display(description=_("Post Count"))
    # def post_count_display(self, obj):
    #     return obj.blog_posts.count() if hasattr(obj, 'blog_posts') else 0
    # list_display = list_display + ('post_count_display',) # Add to list_display if you uncomment./categories/urls.py
# --- ./categories/urls.py ---
# File: categories/urls.py
from django.urls import path
from . import views

app_name = 'categories'

urlpatterns = [
    # La URL raíz de esta app mostrará el árbol de categorías
    path('', views.category_tree_view, name='category_list'),
]./categories/translation.py
# --- ./categories/translation.py ---
# File: categories/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Category

@register(Category)
class CategoryTranslationOptions(TranslationOptions):
    # ANTES: fields = ('name', 'slug', 'meta_title', 'meta_description')
    # AHORA:
    fields = ('name', 'slug', 'description', 'meta_title', 'meta_description')./categories/signals.py
# --- ./categories/signals.py ---
# File: categories/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.conf import settings
from .models import Category

@receiver([post_save, post_delete], sender=Category)
def clear_category_tree_cache(sender, instance, **kwargs):
    """
    Clears the cached category tree for all languages whenever a category
    is saved or deleted.
    """
    print("--- CATEGORY SIGNAL TRIGGERED: Clearing all category tree caches ---")
    for lang_code, _ in settings.LANGUAGES:
        cache_key = f'full_category_tree_nodes_{lang_code}_v1'
        cache.delete(cache_key)./categories/apps.py
# --- ./categories/apps.py ---
# File: categories/apps.py
from django.apps import AppConfig

class CategoriesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'categories'

    def ready(self):
        # This imports the signals so they are connected when Django starts.
        import categories.signals./categories/models.py
# --- ./categories/models.py ---
# File: categories/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from mptt.models import MPTTModel, TreeForeignKey

class Category(MPTTModel):
    """
    A universal, hierarchical category model using a simple self-referencing
    ForeignKey to handle nesting.
    """
    # Basic category fields
    name = models.CharField(
        max_length=100, 
        verbose_name=_("Name")
    )
    slug = models.SlugField(
        max_length=100, 
        unique=True, 
        verbose_name=_("Slug")
    )
    
    # Simple hierarchy field
    parent = TreeForeignKey(
        'self', 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True, 
        related_name='children',
        verbose_name=_("Parent Category"),
        help_text=_("Select a parent to create a sub-category.")
    )
    
    # Optional descriptive fields
    description = models.TextField(
        blank=True, 
        verbose_name=_("Description"),
        help_text=_("An optional description for the category.")
    )
    
    # SEO Fields
    meta_title = models.CharField(
        max_length=70, 
        blank=True, null=True,
        verbose_name=_("Meta Title (SEO)"),
        help_text=_("A precise title for search engine results (max 70 chars).")
    )
    meta_description = models.CharField(
        max_length=160, 
        blank=True, null=True,
        verbose_name=_("Meta Description (SEO)"),
        help_text=_("A short description for search engine previews (max 160 chars).")
    )

    class Meta:
        """ Standard Django model metadata. """
        verbose_name = _("Category")
        verbose_name_plural = _("Categories")
        # Order alphabetically by default in the admin and queries.
        ordering = ['name']

    def __str__(self):
        """ Provides a clear representation in the admin, showing hierarchy. """
        if self.parent:
            return f"{self.parent.name} -> {self.name}"
        return self.name
    
    @property
    def is_blog_category(self):
        """ Checks if this category is used for blog posts. """
        return hasattr(self, 'blog_posts') and self.blog_posts.exists()

    def get_absolute_url(self):
        """
        Generates the correct URL for the category's list page.
        """
        if self.is_blog_category:
            return reverse('blog:posts_by_category', args=[self.slug])
        else:
            # Fallback to the pages category list view
            return reverse('pages:pages_by_category', args=[self.slug])./categories/tests.py
# --- ./categories/tests.py ---
from django.test import TestCase

# Create your tests here.
./categories/__init__.py
# --- ./categories/__init__.py ---
./categories/templatetags/category_tags.py
# --- ./categories/templatetags/category_tags.py ---
# File: categories/templatetags/category_tags.py
import logging
from django import template
from django.core.cache import cache
from django.conf import settings
from ..models import Category

# Get a logger instance for this module
logger = logging.getLogger(__name__)

# This is necessary for Django to discover our custom tags
register = template.Library()


@register.inclusion_tag('core/partials/_tree_node_component.html', takes_context=True)
def render_category_tree(context):
    """
    Fetches and renders the entire category tree.

    This tag is highly optimized:
    1. It's language-aware, caching a separate tree for each active language.
    2. It uses a configurable cache timeout, managed from the SiteConfiguration model.
    3. The cache is automatically invalidated by signals when a category is changed.
    """
    # 1. Get the current language from the template context to build a unique cache key.
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'full_category_tree_nodes_{language_code}_v1'
    
    # 2. Try to fetch the full list of category nodes from the cache.
    nodes = cache.get(cache_key)
    
    # 3. If it's a "cache miss" (nodes is None), we query the database.
    if nodes is None:
        # We only log the DB query if caching was actually attempted (will be on a miss).
        logger.info(f"CACHE MISS for category tree (lang: {language_code}). Querying database.")
        
        # For `recursetree` to work efficiently, we fetch all nodes at once.
        # MPTT ensures they are correctly ordered for tree construction.
        nodes = Category.objects.all()
        
        # Evaluate to a list before caching to store the results, not the lazy queryset.
        nodes = list(nodes)

        # Get the cache timeout setting from our global site configuration.
        try:
            from site_settings.models import SiteConfiguration
            timeout = SiteConfiguration.get_solo().category_tree_cache_timeout
        except ImportError:
             logger.error("Could not import SiteConfiguration. Is the app in INSTALLED_APPS?")
             timeout = 3600 # Fallback to 1 hour
        except SiteConfiguration.DoesNotExist:
            logger.warning("SiteConfiguration not found. Using default cache timeout of 1 hour.")
            timeout = 3600 # Fallback to 1 hour
        
        # 4. Store the result in the cache if caching is enabled (timeout > 0).
        if timeout > 0:
            cache.set(cache_key, nodes, timeout)
            logger.debug(f"Cached category tree for {timeout} seconds.")
    else:
        logger.debug(f"CACHE HIT for category tree (lang: {language_code}). Serving from cache.")
            
    return {'nodes': nodes}./categories/templatetags/__init__.py
# --- ./categories/templatetags/__init__.py ---
./tvt/context_processors.py
# --- ./tvt/context_processors.py ---
from django.conf import settings

def languages_context(request):
    return {
        'LANGUAGES': settings.LANGUAGES,
    }./tvt/urls.py
# --- ./tvt/urls.py ---
from django.conf import settings
from django.conf.urls.i18n import i18n_patterns
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
from django.contrib.auth import views as auth_views
from django.contrib.staticfiles.urls import staticfiles_urlpatterns


# ==============================================================================
# URLS THAT SHOULD NOT BE TRANSLATED (e.g., admin, auth process)
# ==============================================================================
urlpatterns = [
    # 1. Third-party app URLs (like summernote)
    path('summernote/', include('django_summernote.urls')),

    # This includes all of Django's built-in auth URLs (login, password reset, etc.)
    # Our custom logout is technically handled by django.contrib.auth.urls's default logout,
    # as we now handle the POST request in the template. If we needed a custom
    # next_page, we'd define a specific logout path here BEFORE this include.
    path('accounts/', include('django.contrib.auth.urls')),
    path('i18n/', include('django.conf.urls.i18n')), 
]


# ==============================================================================
# URLS THAT WILL BE PREFIXED WITH A LANGUAGE CODE (e.g., /en/blog/, /es/blog/)
# ==============================================================================
urlpatterns += i18n_patterns(
    # 1. Django Admin
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls', namespace='accounts')),
    path('menus/', include('menus.urls', namespace='menus')),
    path('categories/', include('categories.urls', namespace='categories')),
    path('search/', include('search.urls', namespace='search')),
    path('pages/', include('pages.urls', namespace='pages')),
    path('blog/', include('blog.urls', namespace='blog')),
    path('contact/', include('contact.urls', namespace='contact')),
    path('gallery/', include('gallery.urls', namespace='gallery')),
    path('', include('core.urls')),
)


# ==============================================================================
# SERVING MEDIA FILES IN DEVELOPMENT
# ==============================================================================
# This is only for development (DEBUG=True) and should not be used in production.
# The web server (e.g., Nginx) should be configured to serve media files.
if settings.DEBUG:
    # Añadimos las URLs para los archivos MEDIA
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    
    # Este es para tus archivos de app (CSS, JS, imágenes por defecto)
    # Es la forma recomendada por Django para desarrollo.
    urlpatterns += staticfiles_urlpatterns()
# ==============================================================================./tvt/asgi.py
# --- ./tvt/asgi.py ---
"""
ASGI config for tvt project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')

application = get_asgi_application()
./tvt/settings.py
# --- ./tvt/settings.py ---
"""
Django settings for tvt project.

Generated by 'django-admin startproject' using Django 5.2.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""
from pathlib import Path #-> Asegúrate de que BASE_DIR está definido con pathlib
from decouple import config, Csv
from pathlib import Path
import os
import pymysql
pymysql.install_as_MySQLdb()
from django.utils.translation import gettext_lazy as _

ADMINS = [('Tavata', 'tavata.art@outlook.com')]

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# 1. Leer la variable de entorno principal.
#    Por seguridad, si no se define, se asume 'production'.
ENVIRONMENT = config('ENVIRONMENT', default='development', cast=str)

print("*********************************************")
print(f"**** EJECUTANDO EN AMBIENTE: {ENVIRONMENT.upper()} ****")
print("*********************************************")

# 2. Configurar otras variables basadas en el ambiente
if ENVIRONMENT == 'development':
    SECRET_KEY = config('SECRET_KEY', default='django-insecure-dev-key-default')
    DEBUG = True
    ALLOWED_HOSTS = ['127.0.0.1', 'localhost']
    EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
else: # Para 'testing', 'production' u otros
    SECRET_KEY = config('SECRET_KEY')
    # DEBUG es False por defecto, a menos que un ambiente específico lo active
    DEBUG = config('DEBUG', default=False, cast=bool)
    ALLOWED_HOSTS = config('ALLOWED_HOSTS', cast=Csv()) #-> Permite múltiples hosts separados por comas
    EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# Application definition

INSTALLED_APPS = [
    # 1. modeltranslation PRIMERO. Esto asegura que su "magia" de
    #    parcheo y registro se ejecute antes que cualquier otra cosa,
    #    especialmente antes que el 'admin'.
    'modeltranslation',

    # 2. Las apps de Django Core
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',

    # 3. Otras apps de Terceros
    'django_summernote',
    'solo',
    'mptt',
    'taggit',

    # 4. Nuestras Propias Aplicaciones
    'core.apps.CoreConfig',
    'pages.apps.PagesConfig',
    'blog.apps.BlogConfig',
    'menus.apps.MenusConfig', 
    'site_settings.apps.SiteSettingsConfig', 
    'search.apps.SearchConfig', 
    'contact.apps.ContactConfig',
    'widgets.apps.WidgetsConfig',
    'accounts.apps.AccountsConfig',
    'categories.apps.CategoriesConfig',
    'gallery.apps.GalleryConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.locale.LocaleMiddleware',  # <-- ¡Localization!
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'tvt.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.i18n',
                'tvt.context_processors.languages_context',
            ],
        },
    },
]

WSGI_APPLICATION = 'tvt.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# 3. Configurar la base de datos basada en el ambiente
# Primero, la configuración por defecto para desarrollo
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Luego, sobrescribimos si estamos en un ambiente de tipo MySQL
if ENVIRONMENT == 'testing' or ENVIRONMENT == 'production':
    DATABASES['default'] = {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': config('DB_NAME'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST'),
        'PORT': config('DB_PORT', default='3306'),
        'OPTIONS': {
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }


# --- CACHING CONFIGURATION ---
# https://docs.djangoproject.com/en/5.2/topics/cache/
CACHES = {
    'default': {
        # In-memory cache for development. Fast but resets with every server restart.
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'tavata-cms-unique-cache',
    }
}

# Para producción, podríamos usar algo más robusto como Redis:
# 'default': {
#     'BACKEND': 'django.core.cache.backends.redis.RedisCache',
#     'LOCATION': 'redis://127.0.0.1:6379/1',
# }


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

# Idioma por defecto
LANGUAGE_CODE = 'en' 

# Lista de idiomas disponibles
LANGUAGES = [
    ('es', _('Spanish')),
    ('en', _('English')),
    ('ca', _('Català')),
]

# Rutas donde Django buscará los archivos de traducción (.po/.mo)
LOCALE_PATHS = [
    BASE_DIR / 'locale/',
]

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = '/static/'

# La ruta donde `collectstatic` copiará todos los archivos para producción.
# Es bueno tenerla definida aunque en desarrollo no se use directamente.
STATIC_ROOT = BASE_DIR / 'staticfiles'

# ¡LA CONFIGURACIÓN CLAVE PARA DESARROLLO!
# Directorios adicionales donde el servidor de desarrollo de Django buscará archivos estáticos.
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

X_FRAME_OPTIONS = 'SAMEORIGIN'

# ==============================================================================
# LOGGING CONFIGURATION
# ==============================================================================

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False, # No desactiva los loggers por defecto de Django

    # --- FORMATTERS: Cómo se verá cada línea del log ---
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },

    # --- FILTERS: Para añadir contexto o filtrar logs ---
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },
    },

    # --- HANDLERS: A dónde se envía cada log (consola, archivo, email) ---
    'handlers': {
        # Handler para la consola de desarrollo
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'], # Solo funciona si DEBUG=True
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        # Handler para guardar en un archivo los warnings y errores
        'file_error': {
            'level': 'WARNING',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs/error.log', # Ruta al archivo
            'maxBytes': 1024 * 1024 * 5,  # 5 MB
            'backupCount': 2,
            'formatter': 'verbose',
        },
        # Handler para que los administradores reciban un email en caso de error 500
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'], # Solo funciona si DEBUG=False
            'class': 'django.utils.log.AdminEmailHandler',
        },
    },

    # --- LOGGERS: El cerebro que une todo ---
    'loggers': {
        # Logger principal de Django. Capturará todo lo que pase en el framework.
        'django': {
            'handlers': ['console', 'file_error', 'mail_admins'],
            'level': 'INFO',
            'propagate': True,
        },
        # Podemos crear loggers para nuestras propias apps si queremos
        # 'blog': {
        #     'handlers': ['console', 'file_error'],
        #     'level': 'DEBUG',
        # },
    },
}

# URL to redirect to after a successful login.
LOGIN_REDIRECT_URL = '/'

# URL to redirect to after a successful logout.
LOGOUT_REDIRECT_URL = '/'./tvt/wsgi.py
# --- ./tvt/wsgi.py ---
"""
WSGI config for tvt project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')

application = get_wsgi_application()
./tvt/__init__.py
# --- ./tvt/__init__.py ---
./menus/views.py
# --- ./menus/views.py ---
# File: menus/views.py
from django.shortcuts import render
from .models import Menu

def menu_view(request):
    # La plantilla ahora se encargará de llamar al tag
    return render(request, 'menus/menu_page.html')
./menus/migrations/0001_initial.py
# --- ./menus/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 22:24

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('pages', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Menu',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100, unique=True, verbose_name='Menu Title')),
                ('title_es', models.CharField(max_length=100, null=True, unique=True, verbose_name='Menu Title')),
                ('title_en', models.CharField(max_length=100, null=True, unique=True, verbose_name='Menu Title')),
                ('title_ca', models.CharField(max_length=100, null=True, unique=True, verbose_name='Menu Title')),
                ('slug', models.SlugField(max_length=100, unique=True, verbose_name='Slug')),
            ],
            options={
                'verbose_name': 'Menu',
                'verbose_name_plural': 'Menus',
            },
        ),
        migrations.CreateModel(
            name='MenuItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100, verbose_name='Link Text')),
                ('title_es', models.CharField(max_length=100, null=True, verbose_name='Link Text')),
                ('title_en', models.CharField(max_length=100, null=True, verbose_name='Link Text')),
                ('title_ca', models.CharField(max_length=100, null=True, verbose_name='Link Text')),
                ('order', models.PositiveIntegerField(default=0, verbose_name='Display Order')),
                ('link_type', models.CharField(choices=[('url', 'Manual URL'), ('page', 'Single Page'), ('all_blog_categories', 'Blog Categories Tree (Dropdown)'), ('important_pages', 'Important Pages List (Dropdown)')], default='url', max_length=50, verbose_name='Link Type')),
                ('link_url', models.CharField(blank=True, max_length=255, verbose_name='Manual URL')),
                ('icon_class', models.CharField(blank=True, max_length=100, verbose_name='Icon Class')),
                ('lft', models.PositiveIntegerField(editable=False)),
                ('rght', models.PositiveIntegerField(editable=False)),
                ('tree_id', models.PositiveIntegerField(db_index=True, editable=False)),
                ('level', models.PositiveIntegerField(editable=False)),
                ('link_page', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='pages.page', verbose_name='Page Link')),
                ('menu', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='items', to='menus.menu', verbose_name='Menu')),
                ('parent', mptt.fields.TreeForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='menus.menuitem', verbose_name='Parent Menu Item')),
            ],
            options={
                'verbose_name': 'Menu Item',
                'verbose_name_plural': 'Menu Items',
            },
        ),
    ]
./menus/migrations/0002_alter_menuitem_options_alter_menuitem_icon_class_and_more.py
# --- ./menus/migrations/0002_alter_menuitem_options_alter_menuitem_icon_class_and_more.py ---
# Generated by Django 5.2.3 on 2025-06-21 16:07

import django.db.models.deletion
import mptt.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('menus', '0001_initial'),
        ('pages', '0002_page_featured_image'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='menuitem',
            options={'ordering': ['order'], 'verbose_name': 'Menu Item', 'verbose_name_plural': 'Menu Items'},
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='icon_class',
            field=models.CharField(blank=True, help_text="FontAwesome class (e.g., 'fas fa-home') to display an icon next to the link.", max_length=100, verbose_name='Icon Class'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='link_page',
            field=models.ForeignKey(blank=True, help_text="Link to a specific internal page. Only used if Link Type is 'Single Page'.", null=True, on_delete=django.db.models.deletion.SET_NULL, to='pages.page', verbose_name='Page Link'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='link_type',
            field=models.CharField(choices=[('url', 'Manual URL'), ('page', 'Single Page'), ('all_blog_categories', 'Blog Categories Tree (Dropdown)'), ('important_pages', 'Important Pages List (Dropdown)')], default='url', help_text='Determines how this menu item behaves: a direct link, or a dynamic content generator.', max_length=50, verbose_name='Link Type'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='link_url',
            field=models.CharField(blank=True, help_text="Use for external URLs (e.g., 'https://google.com') or custom internal paths (e.g., '/blog/'). Only used if Link Type is 'Manual URL'.", max_length=255, verbose_name='Manual URL'),
        ),
        migrations.AlterField(
            model_name='menuitem',
            name='parent',
            field=mptt.fields.TreeForeignKey(blank=True, help_text='Select a parent item to nest this menu item within it.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='menus.menuitem', verbose_name='Parent Menu Item'),
        ),
    ]
./menus/migrations/__init__.py
# --- ./menus/migrations/__init__.py ---
./menus/admin.py
# --- ./menus/admin.py ---
# File: menus/admin.py
import logging
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from django.conf import settings # Required for dynamically accessing LANGUAGE_CODE

# Third-party imports
from mptt.admin import DraggableMPTTAdmin 
from modeltranslation.admin import TabbedTranslationAdmin
from modeltranslation.translator import translator, NotRegistered # NotRegistered is for helper function

# Local application imports
from .models import Menu, MenuItem # Ensure these models are defined in menus/models.py


logger = logging.getLogger(__name__)


# --- Helper functions for dynamic admin fields ---
# This helper is self-contained within this admin file for now.
# Ideally, for broader reuse across admin files, it could be moved to a shared utility module (e.g., core/admin_helpers.py).

def get_translated_fieldnames(field_base, model_kls=None):
    """
    Dynamically generates a list of translated field names (e.g., 'title_en', 'title_es', 'title_ca')
    for a given base field name (e.g., 'title'), based on Django project's LANGUAGES settings.

    Args:
        field_base (str): The base name of the field (e.g., 'title', 'content', 'description').
        model_kls (Model, optional): The model class to check if the field_base is
                                    actually translatable for that model. If not provided,
                                    it assumes the field could be translatable.
    Returns:
        tuple: A tuple of generated field names (e.g., ('title_en', 'title_es')).
    """
    generated_field_names = []
    
    # Check if the model_kls is provided and the field_base is indeed translatable for it.
    if model_kls:
        try:
            trans_opts = translator.get_options_for_model(model_kls)
            if field_base not in trans_opts.fields:
                # If the field is not registered for translation for this model,
                # return just the base field name as a single-element tuple.
                # This ensures backward compatibility if a non-translatable field is passed.
                return (field_base,) 
        except NotRegistered:
            # If the model itself is not registered for translation, return the base field.
            return (field_base,)

    # Generate translated field names for all configured languages.
    for lang_code, _ in settings.LANGUAGES:
        generated_field_names.append(f"{field_base}_{lang_code}")
    
    return tuple(generated_field_names)


# --- ADMIN FOR MAIN MENU CONTAINERS ---
@admin.register(Menu)
class MenuAdmin(TabbedTranslationAdmin):
    """
    Admin options for the main Menu containers (e.g., 'Main Menu', 'Footer Menu').
    This class handles the creation and top-level management of Menu objects.
    """
    list_display = ('title', 'slug') # 'title' is translatable, 'slug' is not.
    
    prepopulated_fields = {
        # The 'slug' field of the Menu model is NOT translatable, but its 'title' IS.
        # We prepopulate the non-translatable 'slug' from the 'title' field of the default language.
        'slug': (f'title_{settings.LANGUAGE_CODE}',)
    }

    # Search functionality over translated title fields.
    search_fields = get_translated_fieldnames('title', model_kls=Menu)

    # Note: MenuItem inline management is done via MenuItemAdmin directly for hierarchy.


# --- ADMIN FOR HIERARCHICAL MENU ITEMS ---
@admin.register(MenuItem)
class MenuItemAdmin(DraggableMPTTAdmin, TabbedTranslationAdmin):
    """
    Admin options for the hierarchical MenuItem model.
    This combines DraggableMPTTAdmin for intuitive drag-and-drop hierarchy management
    and TabbedTranslationAdmin for multilingual fields (like 'title').
    """
    # Fields to display in the tree view list of menu items.
    list_display = (
        'tree_actions',    # Provided by DraggableMPPTAAdmin for drag-and-drop handles.
        'indented_title',  # Provided by DraggableMPPTAAdmin to show indented title.
        'link_type',       # Displays the chosen link type (e.g., 'Page', 'Manual URL').
        'menu',            # Indicates which parent Menu container this item belongs to.
        'order',           # Display order to aid initial sorting or when not dragging.
    )
    
    # Makes the indented title clickable to go to the change form for the item.
    list_display_links = ('indented_title',)

    # Allows filtering menu items by their parent Menu container or link type.
    list_filter = ('menu', 'link_type',)
    
    # Fields that can be edited directly from the list view (for quick changes).
    list_editable = ('order', 'menu', 'link_type',)
    
    # MPTT-specific setting for the indentation width in the admin tree view.
    mptt_level_indent = 25 

    # Search functionality over translated title fields.
    search_fields = get_translated_fieldnames('title', model_kls=MenuItem)

    # Note: MenuItem model does not have a 'slug' field, so prepopulated_fields should not be set.
    # If a translable slug field existed on MenuItem, the implementation would be:
    # prepopulated_fields = get_translated_fieldnames('slug', model_kls=MenuItem)

    # Fields to display in the detailed change form for a single menu item.
    # This list should include all fields from the MenuItem model for editing.
    fields = (
        'menu',           # The parent Menu container.
        'parent',         # The parent MenuItem for nested hierarchy.
        'title',          # The translatable link text.
        'order',          # Display order.
        'link_type',      # Type of link (e.g., Page, Manual URL).
        'link_page',      # Conditional: linked Page object.
        'link_url',       # Conditional: manual URL string.
        'icon_class',     # Optional: FontAwesome icon class.
    )
./menus/urls.py
# --- ./menus/urls.py ---
from django.urls import path
from . import views

app_name = 'menus'

urlpatterns = [
    path('test/', views.menu_view, name='menu_test'),
]./menus/translation.py
# --- ./menus/translation.py ---
# menus/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Menu, MenuItem

# ==============================================================================
# 1. Register the Menu model for translation.
#    This makes the 'title' field multilingual.
# ==============================================================================
@register(Menu)
class MenuTranslationOptions(TranslationOptions):
    """ Translation options for the Menu model. """
    fields = ('title',)


# ==============================================================================
# 2. Register the MenuItem model for translation.
#    This makes the 'title' field of each link multilingual.
# ==============================================================================
@register(MenuItem)
class MenuItemTranslationOptions(TranslationOptions):
    """ Translation options for the MenuItem model. """
    fields = ('title',)./menus/signals.py
# --- ./menus/signals.py ---
# File: menus/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from .models import MenuItem, Menu

@receiver([post_save, post_delete], sender=MenuItem)
def clear_menu_cache(sender, instance, **kwargs):
    """
    Clears the relevant menu cache whenever a MenuItem is saved or deleted.
    """
    # We need to clear the cache for all languages
    from django.conf import settings
    if instance.menu:
        for lang_code, lang_name in settings.LANGUAGES:
            cache_key = f'menu_items_{instance.menu.slug}_{lang_code}_v1'
            cache.delete(cache_key)
        print(f"Cache cleared for menu '{instance.menu.slug}'")./menus/apps.py
# --- ./menus/apps.py ---
# File: menus/apps.py
from django.apps import AppConfig

class MenusConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'menus'

    def ready(self):
        # This line is crucial. It tells Django to connect the signals
        # defined in menus/signals.py when the application starts.
        import menus.signals ./menus/models.py
# --- ./menus/models.py ---
# File: menus/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

# Third-party imports
from mptt.models import MPTTModel, TreeForeignKey

# Local application imports (ensure these models exist in pages.models and categories.models)
from pages.models import Page # For linking to specific internal pages
# from categories.models import Category # If Category is needed for direct link types


class Menu(models.Model):
    """
    Represents a container for menu items, defining a specific menu location.
    Examples: 'Main Menu', 'Footer Menu', 'Social Media Links'.
    """
    title = models.CharField(max_length=100, unique=True, verbose_name=_("Menu Title"))
    slug = models.SlugField(max_length=100, unique=True, verbose_name=_("Slug"))

    class Meta:
        verbose_name = _("Menu")
        verbose_name_plural = _("Menus")

    def __str__(self):
        # Modeltranslation automatically provides the translated title.
        return self.title


class MenuItem(MPTTModel):
    """
    Represents a single, hierarchical item within a specific Menu.
    It can be a simple link, or a dynamic placeholder that generates sub-items
    (e.g., a "Blog Categories" dropdown).
    """

    # Enum for defining the type of link this menu item represents.
    class LinkType(models.TextChoices):
        URL = 'url', _('Manual URL')
        PAGE = 'page', _('Single Page')
        # These types are placeholders for dynamic content generation in the frontend.
        ALL_BLOG_CATEGORIES = 'all_blog_categories', _('Blog Categories Tree (Dropdown)')
        IMPORTANT_PAGES = 'important_pages', _('Important Pages List (Dropdown)')

    # --- Core Relationships ---
    # The Menu container this item belongs to.
    menu = models.ForeignKey(
        Menu, 
        on_delete=models.CASCADE, 
        related_name="items", 
        verbose_name=_("Menu")
    )
    
    # The 'parent' field enables hierarchical (nested) menu structures,
    # provided by django-mptt.
    parent = TreeForeignKey(
        'self', # Refers to the MenuItem model itself.
        on_delete=models.CASCADE, 
        null=True, 
        blank=True, 
        related_name='children', 
        db_index=True, # For efficient lookups.
        verbose_name=_("Parent Menu Item"),
        help_text=_("Select a parent item to nest this menu item within it.")
    )
    
    # --- Item Content and Order ---
    title = models.CharField(max_length=100, verbose_name=_("Link Text"))
    order = models.PositiveIntegerField(default=0, verbose_name=_("Display Order"))

    # --- Link Configuration ---
    # Specifies how the menu item will generate its URL or dynamic content.
    link_type = models.CharField(
        max_length=50, # Sufficient for all TextChoices values.
        choices=LinkType.choices,
        default=LinkType.URL,
        verbose_name=_("Link Type"),
        help_text=_("Determines how this menu item behaves: a direct link, or a dynamic content generator.")
    )

    # Conditional link fields. Only one of these should typically be filled.
    link_page = models.ForeignKey(
        Page, 
        on_delete=models.SET_NULL, # If the page is deleted, the menu item link becomes null.
        null=True, 
        blank=True, 
        verbose_name=_("Page Link"),
        help_text=_("Link to a specific internal page. Only used if Link Type is 'Single Page'.")
    )
    link_url = models.CharField(
        max_length=255, 
        blank=True, 
        verbose_name=_("Manual URL"),
        help_text=_("Use for external URLs (e.g., 'https://google.com') or custom internal paths (e.g., '/blog/'). Only used if Link Type is 'Manual URL'.")
    )
    icon_class = models.CharField(
        max_length=100, 
        blank=True, 
        verbose_name=_("Icon Class"),
        help_text=_("FontAwesome class (e.g., 'fas fa-home') to display an icon next to the link.")
    )

    class MPTTMeta:
        """ MPTT specific options for ordering nodes within the tree. """
        order_insertion_by = ['order'] # Orders items by their 'order' field.

    class Meta:
        """ Standard Django model metadata. """
        verbose_name = _("Menu Item")
        verbose_name_plural = _("Menu Items")
        # Ensure consistent display order for all queries by default.
        ordering = ['order'] 

    def __str__(self):
        """ Returns an indented string representation useful for admin display. """
        # 'self.level' is automatically provided by django-mptt.
        return f"{'--' * self.level} {self.title}"

    def get_url(self):
        """
        Generates the actual URL for the menu item based on its link_type.
        Returns a placeholder '#' if no valid URL is configured.
        """
        if self.link_type == self.LinkType.PAGE and self.link_page:
            return self.link_page.get_absolute_url()
        elif self.link_type == self.LinkType.URL and self.link_url:
            return self.link_url
        # For dynamic link types (like ALL_BLOG_CATEGORIES) the URL is often '#'
        # as clicking the top-level item expands the dropdown, not navigates.
        return "#"
./menus/tests.py
# --- ./menus/tests.py ---
from django.test import TestCase

# Create your tests here.
./menus/__init__.py
# --- ./menus/__init__.py ---
./menus/templatetags/menu_tags.py
# --- ./menus/templatetags/menu_tags.py ---
# File: menus/templatetags/menu_tags.py
import logging
from django import template
from django.core.cache import cache
from django.conf import settings # Needed for settings.LANGUAGES and settings.LANGUAGE_CODE
from django.db.models import Count, Q # Needed for dynamic children queries

# Import necessary models for the dynamic logic
from ..models import Menu, MenuItem # Relative import for models within the same app
from pages.models import Page # For Important Pages list
from categories.models import Category # For Blog Categories list

logger = logging.getLogger(__name__)

# Import SiteConfiguration for cache timeout settings (handle potential ImportError or DoesNotExist)
try:
    from site_settings.models import SiteConfiguration
except ImportError:
    logger.error("Could not import SiteConfiguration. Ensure 'site_settings' app is in INSTALLED_APPS.")
    SiteConfiguration = None # Fallback for type hinting / future handling

logger = logging.getLogger(__name__) # Get logger specific to this module
register = template.Library() # Register this as a Django template library


@register.inclusion_tag('menus/partials/_navbar_main_level.html', takes_context=True)
def show_menu(context, menu_slug):
    """
    Fetches and renders the top-level menu items for a main navigation bar.
    Handles caching and prepares dynamic sub-items.
    """
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'menu_nodes_main_level_{menu_slug}_{language_code}_v1'
    
    # Try getting the top-level nodes (with attached dynamic_children) from cache
    top_level_nodes = cache.get(cache_key)

    if top_level_nodes is None:
        logger.info(f"CACHE MISS for main level menu '{menu_slug}' (lang: {language_code}). Building.")
        try:
            menu = Menu.objects.get(slug=menu_slug)
            
            # Fetch ALL menu items for this menu. 
            # We need them all to attach dynamic children to parents properly.
            all_menu_items = list(menu.items.all().order_by('tree_id', 'lft'))
            
            # --- ATTACH DYNAMIC CHILDREN LOGIC ---
            # This loop attaches 'dynamic_children' to the relevant parent MenuItem instances,
            # which will be used by the template during rendering.
            for item_obj in all_menu_items: 
                item_obj.dynamic_children = [] # Initialize for all items

                blog_cat_limit = getattr(SiteConfiguration.get_solo(), 'blog_items_per_page', 9) if SiteConfiguration else 9
                important_pages_limit = getattr(SiteConfiguration.get_solo(), 'search_importance_limit', 3) if SiteConfiguration else 3

                if item_obj.link_type == MenuItem.LinkType.ALL_BLOG_CATEGORIES:
                    blog_categories = Category.objects.annotate(
                        num_blog_posts=Count('blog_posts', filter=Q(blog_posts__status='published'))
                    ).filter(num_blog_posts__gt=0).order_by('tree_id', 'lft')
                    item_obj.dynamic_children = list(blog_categories[:blog_cat_limit])

                elif item_obj.link_type == MenuItem.LinkType.IMPORTANT_PAGES:
                    important_pages_qs = Page.objects.filter(
                        status='published', 
                        importance_order__lt=99
                    ).order_by('importance_order', 'title')
                    item_obj.dynamic_children = list(important_pages_qs[:important_pages_limit])

            # Now, filter for only the top-level nodes (level 0) for the main navbar.
            # The children will be accessed in the template using .children.all() and .dynamic_children
            # on these top-level nodes.
            raw_top_level_nodes = [item for item in all_menu_items if item.level == 0]

            # Get cache timeout and set cache.
            try:
                config = SiteConfiguration.get_solo()
                timeout = config.menu_cache_timeout
            except SiteConfiguration.DoesNotExist:
                timeout = 3600
            
            cache.set(cache_key, raw_top_level_nodes, timeout) # Cache only top-level nodes for efficiency
            top_level_nodes = raw_top_level_nodes
            
        except Menu.DoesNotExist:
            logger.warning(f"Menu with slug '{menu_slug}' does not exist.")
            top_level_nodes = [] # Return empty list if menu does not exist
    else:
        logger.debug(f"CACHE HIT for main level menu '{menu_slug}' (lang: {language_code}). Serving from cache.")
            
    return {'nodes': top_level_nodes} # Pass only top-level nodes to _navbar_main_level.html



# --- show_social_links_menu ---
@register.inclusion_tag('menus/partials/_social_links_partial.html', takes_context=True)
def show_social_links_menu(context):
    """
    Renders the social media links menu.
    It's a simplified version of show_menu for a fixed slug 'social-links'.
    """
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'social_links_menu_{language_code}_v1'
    
    menu_items_processed = cache.get(cache_key)

    if menu_items_processed is None:
        logger.info(f"CACHE MISS for 'social-links' menu (lang: {language_code}). Querying database.")
        
        try:
            from site_settings.models import SiteConfiguration # Import here
            timeout = SiteConfiguration.get_solo().menu_cache_timeout
        except (ImportError, SiteConfiguration.DoesNotExist):
            timeout = 3600 # Fallback

        try:
            menu = Menu.objects.get(slug='social-links')
            menu_items_processed = list(menu.items.all()) # Simple list of items for social links

            if timeout > 0:
                cache.set(cache_key, menu_items_processed, timeout)

        except Menu.DoesNotExist:
            logger.warning("Menu with slug 'social-links' does not exist. Cannot display social media icons.")
            menu_items_processed = []
    else:
        logger.debug(f"CACHE HIT for 'social-links' menu (lang: {language_code}). Serving from cache.")

    return {'nodes': menu_items_processed}

@register.inclusion_tag('menus/partials/_simple_horizontal_menu.html', takes_context=True)
def show_simple_menu(context, menu_slug):
    """
    Fetches and renders menu items for a simple, non-hierarchical menu
    like a footer menu.
    """
    language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
    cache_key = f'simple_menu_items_{menu_slug}_{language_code}_v1'
    
    items = cache.get(cache_key)

    if items is None:
        logger.info(f"CACHE MISS for simple menu '{menu_slug}' (lang: {language_code}). Building.")
        try:
            menu = Menu.objects.get(slug=menu_slug)
            # Solo queremos los items de nivel 0, ya que es un menú simple.
            items = list(menu.items.filter(level=0).order_by('order')) 
            
            try:
                config = SiteConfiguration.objects.get()
                timeout = config.menu_cache_timeout
            except SiteConfiguration.DoesNotExist:
                timeout = 3600
            
            cache.set(cache_key, items, timeout)
            
        except Menu.DoesNotExist:
            logger.warning(f"Menu with slug '{menu_slug}' does not exist for show_simple_menu.")
            items = []
    else:
        logger.debug(f"CACHE HIT for simple menu '{menu_slug}' (lang: {language_code}).")

    return {'nodes': items}./menus/templatetags/__init__.py
# --- ./menus/templatetags/__init__.py ---
./widgets/views.py
# --- ./widgets/views.py ---
from django.shortcuts import render

# Create your views here.
./widgets/migrations/0003_widget_carousel_interval_ms_alter_widget_widget_type.py
# --- ./widgets/migrations/0003_widget_carousel_interval_ms_alter_widget_widget_type.py ---
# Generated by Django 5.2.3 on 2025-06-22 11:34

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('widgets', '0002_widget_column_count_widget_section_title_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='widget',
            name='carousel_interval_ms',
            field=models.PositiveIntegerField(default=5000, help_text="Time in milliseconds between slides for 'Post Carousel' widget.", verbose_name='Carousel Interval (ms)'),
        ),
        migrations.AlterField(
            model_name='widget',
            name='widget_type',
            field=models.CharField(choices=[('recent_posts', 'Recent Blog Posts'), ('most_viewed_posts', 'Most Viewed Blog Posts'), ('most_commented_posts', 'Most Commented Blog Posts'), ('blog_categories', 'Blog Category List'), ('editor_picks_posts', "Editor's Picks (Blog Posts)"), ('post_grid_recent', 'Post Grid: Recent Posts'), ('post_grid_popular', 'Post Grid: Most Viewed'), ('post_grid_commented', 'Post Grid: Most Commented'), ('post_grid_editor', "Post Grid: Editor's Picks"), ('post_carousel', 'Post Carousel')], max_length=50, verbose_name='Widget Type'),
        ),
    ]
./widgets/migrations/0001_initial.py
# --- ./widgets/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('categories', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='WidgetZone',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, verbose_name='Zone Name')),
                ('slug', models.SlugField(max_length=100, unique=True, verbose_name='Slug (used in templates)')),
            ],
            options={
                'verbose_name': 'Widget Zone',
                'verbose_name_plural': 'Widget Zones',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Widget',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('widget_type', models.CharField(choices=[('recent_posts', 'Recent Blog Posts'), ('most_viewed_posts', 'Most Viewed Blog Posts'), ('most_commented_posts', 'Most Commented Blog Posts'), ('blog_categories', 'Blog Category List'), ('editor_picks_posts', "Editor's Picks (Blog Posts)")], max_length=50, verbose_name='Widget Type')),
                ('title', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, verbose_name='Widget Title')),
                ('title_es', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, null=True, verbose_name='Widget Title')),
                ('title_en', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, null=True, verbose_name='Widget Title')),
                ('title_ca', models.CharField(help_text='The title that will be displayed above the widget.', max_length=100, null=True, verbose_name='Widget Title')),
                ('order', models.PositiveIntegerField(default=0, verbose_name='Display Order')),
                ('item_count', models.PositiveIntegerField(default=5, help_text="Used by widgets that display a list of items, like 'Recent Posts' or 'Blog Categories'.", verbose_name='Number of items to show')),
                ('cache_timeout', models.PositiveIntegerField(default=900, help_text='How long the results of this widget should be stored in cache. 0 to disable caching for this widget.', verbose_name='Cache Timeout (in seconds)')),
                ('category_filter', models.ForeignKey(blank=True, help_text='If selected, the widget will only show items from this specific category.', null=True, on_delete=django.db.models.deletion.SET_NULL, to='categories.category', verbose_name='Filter by Category (optional)')),
                ('zone', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='widgets', to='widgets.widgetzone', verbose_name='Widget Zone')),
            ],
            options={
                'verbose_name': 'Widget',
                'verbose_name_plural': 'Widgets',
                'ordering': ['zone', 'order'],
            },
        ),
    ]
./widgets/migrations/__init__.py
# --- ./widgets/migrations/__init__.py ---
./widgets/migrations/0002_widget_column_count_widget_section_title_and_more.py
# --- ./widgets/migrations/0002_widget_column_count_widget_section_title_and_more.py ---
# Generated by Django 5.2.3 on 2025-06-21 20:02

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('widgets', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='widget',
            name='column_count',
            field=models.PositiveIntegerField(default=3, help_text='Number of columns for grid display (e.g., 2, 3, 4).', verbose_name='Column Count'),
        ),
        migrations.AddField(
            model_name='widget',
            name='section_title',
            field=models.CharField(blank=True, help_text="A main title for this grid section (e.g., 'Latest Posts', 'Our Bestsellers').", max_length=200, null=True, verbose_name='Section Title (Optional)'),
        ),
        migrations.AddField(
            model_name='widget',
            name='view_all_link_text',
            field=models.CharField(blank=True, help_text="Text for the 'View All' link below the grid (e.g., 'View All Posts').", max_length=100, null=True, verbose_name='View All Link Text'),
        ),
        migrations.AddField(
            model_name='widget',
            name='view_all_link_url',
            field=models.CharField(blank=True, help_text="URL for the 'View All' link (e.g., '/blog/').", max_length=255, null=True, verbose_name='View All Link URL'),
        ),
        migrations.AlterField(
            model_name='widget',
            name='widget_type',
            field=models.CharField(choices=[('recent_posts', 'Recent Blog Posts'), ('most_viewed_posts', 'Most Viewed Blog Posts'), ('most_commented_posts', 'Most Commented Blog Posts'), ('blog_categories', 'Blog Category List'), ('editor_picks_posts', "Editor's Picks (Blog Posts)"), ('post_grid_recent', 'Post Grid: Recent Posts'), ('post_grid_popular', 'Post Grid: Most Viewed'), ('post_grid_commented', 'Post Grid: Most Commented'), ('post_grid_editor', "Post Grid: Editor's Picks")], max_length=50, verbose_name='Widget Type'),
        ),
    ]
./widgets/widgets.py
# --- ./widgets/widgets.py ---
# File: widgets/widgets.py
from django import forms

class CustomClearableFileInput(forms.ClearableFileInput):
    """
    A custom file input widget that uses a specific template
    to provide full control over its HTML rendering.
    """
    # This tells Django to use our custom HTML file to render this widget.
    template_name = 'widgets/custom_clearable_file_input.html'./widgets/admin.py
# --- ./widgets/admin.py ---
# File: widgets/admin.py
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from .models import WidgetZone, Widget
from modeltranslation.admin import TabbedTranslationAdmin

class WidgetInline(admin.TabularInline):
    """
    Defines the editor for Widgets when they are managed 'inline'
    within a WidgetZone.
    """
    model = Widget
    # We now use the single, universal 'category_filter' field.
    fields = ('title', 'widget_type', 'order', 'item_count', 'cache_timeout', 'category_filter')
    extra = 1
    ordering = ['order']
    # Adding a class to make the inline editor more compact
    classes = ('collapse',)


@admin.register(WidgetZone)
class WidgetZoneAdmin(admin.ModelAdmin):
    """ Admin options for the WidgetZone model. """
    list_display = ('name', 'slug', 'widget_count')
    search_fields = ('name', 'slug')
    prepopulated_fields = {'slug': ('name',)}
    inlines = [WidgetInline]

    @admin.display(description=_("Number of Widgets"))
    def widget_count(self, obj):
        """Calculates the number of widgets in this zone."""
        return obj.widgets.count()


@admin.register(Widget)
class WidgetAdmin(TabbedTranslationAdmin):
    """ 
    A global list view for all Widgets, allowing for quick edits and
    re-assignment across different zones.
    """
    list_display = ('title', 'zone', 'widget_type', 'order', 'cache_timeout', 'column_count', 'section_title', 'view_all_link_text', 'view_all_link_url', 'carousel_interval_ms')
    list_filter = ('zone', 'widget_type')
    list_editable = ('order', 'zone', 'cache_timeout')
    search_fields = ('title',)
    
    # We update the fields for the detail edit form as well.
    fields = ('title', 'zone', 'widget_type', 'order', 'item_count', 'cache_timeout', 'category_filter')

    ordering = ('zone', 'order')
./widgets/translation.py
# --- ./widgets/translation.py ---
# widgets/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Widget

@register(Widget)
class WidgetTranslationOptions(TranslationOptions):
    fields = ('title',)./widgets/signals.py
# --- ./widgets/signals.py ---
# widgets/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.conf import settings
from blog.models import Post # Importamos Post porque sus cambios afectan a los widgets
from .models import Widget

def clear_all_widget_caches():
    """
    A simple but effective strategy: clear ALL widget caches.
    A more granular approach is possible but much more complex.
    """
    # Obtenemos TODOS los widgets de la base de datos
    all_widgets = Widget.objects.all()
    # Para cada widget y cada idioma, construimos la clave y la borramos
    for widget in all_widgets:
        for lang_code, _ in settings.LANGUAGES:
            cache_key = f'widget_items_{widget.id}_{lang_code}_v1'
            cache.delete(cache_key)
    print("--- ALL WIDGET CACHES CLEARED ---")


# Si se guarda o borra un Widget
@receiver([post_save, post_delete], sender=Widget)
def on_widget_change(sender, instance, **kwargs):
    clear_all_widget_caches()

# ¡LA PARTE IMPORTANTE!
# Si se guarda o borra un Post, los widgets de "Recientes", "Vistos", etc.,
# deben actualizarse.
@receiver([post_save, post_delete], sender=Post)
def on_post_change(sender, instance, **kwargs):
    clear_all_widget_caches()

# En el futuro, podríamos añadir signals para Comments, Pages, etc../widgets/apps.py
# --- ./widgets/apps.py ---
from django.apps import AppConfig


class WidgetsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'widgets'

    def ready(self):
        import widgets.signals  # Import the signals module to ensure it is registered
        # This will automatically connect the signals defined in widgets/signals.py
        # when the app is ready, allowing us to handle post_save and post_delete events.

        # Note: No need to import widget_tags here; they are loaded by Django's template system
        # when the template tags are used in templates.
        # The import here is only for signals, which handle cache invalidation.

        # If you have any other initialization code, you can add it here.
        # For example, you might want to register custom template tags or filters.
        # However, in this case, we are only concerned with signals for cache management../widgets/models.py
# --- ./widgets/models.py ---
# widgets/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _
from categories.models import Category

class WidgetZone(models.Model):
    """
    Defines a specific area in a template where widgets can be placed.
    e.g., 'Blog Sidebar', 'Footer Column 1', 'Homepage Sidebar'.
    """
    name = models.CharField(max_length=100, verbose_name=_("Zone Name"))
    slug = models.SlugField(max_length=100, unique=True, verbose_name=_("Slug (used in templates)"))

    class Meta:
        verbose_name = _("Widget Zone")
        verbose_name_plural = _("Widget Zones")
        ordering = ['name']

    def __str__(self):
        return self.name


class Widget(models.Model):
    """
    Represents a single, configurable widget that can be placed in a WidgetZone.
    """
    class WidgetType(models.TextChoices):
        RECENT_POSTS = 'recent_posts', _('Recent Blog Posts')
        MOST_VIEWED_POSTS = 'most_viewed_posts', _('Most Viewed Blog Posts')
        MOST_COMMENTED_POSTS = 'most_commented_posts', _('Most Commented Blog Posts')
        BLOG_CATEGORIES = 'blog_categories', _('Blog Category List')
        EDITOR_PICKS_POSTS = 'editor_picks_posts', _("Editor's Picks (Blog Posts)")
        
        # --- NEW WIDGET TYPES FOR FLEXIBLE POST GRIDS ---
        POST_GRID_RECENT = 'post_grid_recent', _("Post Grid: Recent Posts")
        POST_GRID_POPULAR = 'post_grid_popular', _("Post Grid: Most Viewed")
        POST_GRID_COMMENTED = 'post_grid_commented', _("Post Grid: Most Commented")
        POST_GRID_EDITOR = 'post_grid_editor', _("Post Grid: Editor's Picks")

        POST_CAROUSEL = 'post_carousel', _("Post Carousel")
        # We can easily add more types in the future:
        # PAGE_LIST = 'page_list', _('List of Pages')
        # HTML_CONTENT = 'html_content', _('Custom HTML Content')

    zone = models.ForeignKey(
        WidgetZone, 
        on_delete=models.CASCADE, 
        related_name="widgets", 
        verbose_name=_("Widget Zone")
    )
    widget_type = models.CharField(
        max_length=50, 
        choices=WidgetType.choices, 
        verbose_name=_("Widget Type")
    )
    title = models.CharField(
        max_length=100, 
        verbose_name=_("Widget Title"),
        help_text=_("The title that will be displayed above the widget.")
    )
    order = models.PositiveIntegerField(
        default=0, 
        verbose_name=_("Display Order")
    )
    
    # --- Configuration Fields (optional, used by specific widget types) ---
    item_count = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Number of items to show"),
        # Texto mejorado para reflejar su uso dual
        help_text=_("Used by widgets that display a list of items, like 'Recent Posts' or 'Blog Categories'.")
    )
    
    cache_timeout = models.PositiveIntegerField(
        default=900, # Default to 15 minutes (900 seconds)
        verbose_name=_("Cache Timeout (in seconds)"),
        help_text=_("How long the results of this widget should be stored in cache. 0 to disable caching for this widget.")
    )
    
    category_filter = models.ForeignKey(
        Category,
        null=True, blank=True,
        on_delete=models.SET_NULL,
        verbose_name=_("Filter by Category (optional)"),
        help_text=_("If selected, the widget will only show items from this specific category.")
    )

    # --- NEW: Grid/Column Configuration ---
    column_count = models.PositiveIntegerField(
        default=3,
        verbose_name=_("Column Count"),
        help_text=_("Number of columns for grid display (e.g., 2, 3, 4).")
    )
    
    # --- NEW: Section Title (optional, if widget contains its own section title) ---
    section_title = models.CharField(
        max_length=200,
        blank=True, null=True,
        verbose_name=_("Section Title (Optional)"),
        help_text=_("A main title for this grid section (e.g., 'Latest Posts', 'Our Bestsellers').")
    )

    # --- NEW: Text for 'View All' link for the grid ---
    view_all_link_text = models.CharField(
        max_length=100,
        blank=True, null=True,
        verbose_name=_("View All Link Text"),
        help_text=_("Text for the 'View All' link below the grid (e.g., 'View All Posts').")
    )
    view_all_link_url = models.CharField( # Storing as CharField to allow direct URLs or URL names
        max_length=255,
        blank=True, null=True,
        verbose_name=_("View All Link URL"),
        help_text=_("URL for the 'View All' link (e.g., '/blog/').")
    )
    # --- NEW: Grid/Column Configuration ---
    column_count = models.PositiveIntegerField(
        default=3,
        verbose_name=_("Column Count"),
        help_text=_("Number of columns for grid display (e.g., 2, 3, 4).")
    )
    
    # --- NEW: Section Title (optional, if widget contains its own section title) ---
    section_title = models.CharField(
        max_length=200,
        blank=True, null=True,
        verbose_name=_("Section Title (Optional)"),
        help_text=_("A main title for this grid section (e.g., 'Latest Posts', 'Our Bestsellers').")
    )

    # --- NEW: Text for 'View All' link for the grid ---
    view_all_link_text = models.CharField(
        max_length=100,
        blank=True, null=True,
        verbose_name=_("View All Link Text"),
        help_text=_("Text for the 'View All' link below the grid (e.g., 'View All Posts').")
    )
    view_all_link_url = models.CharField( # Storing as CharField to allow direct URLs or URL names
        max_length=255,
        blank=True, null=True,
        verbose_name=_("View All Link URL"),
        help_text=_("URL for the 'View All' link (e.g., '/blog/').")
    )
    carousel_interval_ms = models.PositiveIntegerField(
        default=5000, # 5 seconds in milliseconds
        verbose_name=_("Carousel Interval (ms)"),
        help_text=_("Time in milliseconds between slides for 'Post Carousel' widget.")
    )
    
    class Meta:
        ordering = ['zone', 'order']
        verbose_name = _("Widget")
        verbose_name_plural = _("Widgets")

    def __str__(self):
        return f"{self.title} ({self.get_widget_type_display()}) in {self.zone.name}"

# Create your models here.
./widgets/tests.py
# --- ./widgets/tests.py ---
from django.test import TestCase

# Create your tests here.
./widgets/__init__.py
# --- ./widgets/__init__.py ---
./widgets/templatetags/widget_tags.py
# --- ./widgets/templatetags/widget_tags.py ---
# File: widgets/templatetags/widget_tags.py
import logging
from django import template
from django.db.models import Count, Q
from django.core.cache import cache
from django.conf import settings # Needed for settings.LANGUAGES and settings.LANGUAGE_CODE

# Import all needed models at the top
from blog.models import Post 
from categories.models import Category # Universal Category model
from widgets.models import Widget, WidgetZone

# Ensure static is imported from Django's template tags
from django.templatetags.static import static 

logger = logging.getLogger(__name__)
register = template.Library()

# --- HELPER FUNCTION: GET THUMBNAIL URL ---
def _get_thumbnail_url(obj):
    """
    Returns the URL for the thumbnail of a given object.
    Currently supports Post objects with 'featured_image'.
    """
    if isinstance(obj, Post) and obj.featured_image:
        return obj.featured_image.url
    
    # Fallback to a default placeholder image if no specific image is found.
    # You MUST ensure 'static/images/placeholders/default_thumbnail.png' exists.
    return static('images/placeholders/default_thumbnail.png')

@register.inclusion_tag('widgets/render_zone.html', takes_context=True)
def show_widget_zone(context, zone_slug):
    """
    Renders all widgets for a specific zone, utilizing a configurable cache
    for each widget to optimize performance.
    """
    try:
        zone = WidgetZone.objects.prefetch_related('widgets').get(slug=zone_slug)
        widgets_queryset = zone.widgets.all()
    except WidgetZone.DoesNotExist:
        logger.warning(f"Widget zone with slug '{zone_slug}' not found.")
        return {'processed_widgets': []} # Return empty if zone doesn't exist

    processed_widgets = [] # Initialize this list here, outside the loop

    # Iterate through each widget configured for this zone
    for widget_instance in widgets_queryset: # Renamed to widget_instance for clarity
        language_code = context.get('LANGUAGE_CODE', settings.LANGUAGE_CODE)
        cache_key = f'widget_items_{widget_instance.id}_{language_code}_v1'
        
        items_to_cache = None # Initialize variable that will hold items for caching
        
        # 1. Try to get items from cache if caching is enabled for this widget.
        if widget_instance.cache_timeout > 0:
            items_to_cache = cache.get(cache_key)

        # 2. If it's a cache miss, query the database and process.
        if items_to_cache is None:
            if widget_instance.cache_timeout > 0: # Log only if caching was attempted
                logger.info(f"CACHE MISS for widget '{widget_instance.title}' (ID: {widget_instance.id}). Querying database.")
            
            # --- WIDGET LOGIC DISPATCHER (match/case) ---
            # This 'items_container' will hold the list of items from the DB query.
            items_container = [] # Initialize for the match/case block

            match widget_instance.widget_type:
                case 'recent_posts':
                    items_qs = Post.objects.filter(status='published').order_by('-published_date')
                    items_container = list(items_qs[:widget_instance.item_count]) # Evaluate QuerySet
                
                case 'most_viewed_posts':
                    items_qs = Post.objects.filter(status='published').order_by('-views_count', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case 'most_commented_posts':
                    items_qs = Post.objects.filter(status='published') \
                                           .annotate(num_comments=Count('comments', filter=Q(comments__is_approved=True))) \
                                           .filter(num_comments__gt=0) \
                                           .order_by('-num_comments', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                
                case 'editor_picks_posts':
                    items_qs = Post.objects.filter(status='published', editor_rating__gt=0) \
                                           .order_by('-editor_rating', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                
                case 'blog_categories':
                    categories_qs = Category.objects.annotate(
                        num_blog_posts=Count('blog_posts', filter=Q(blog_posts__status='published'))
                    ).filter(num_blog_posts__gt=0).order_by('-num_blog_posts', 'name')
                    items_container = list(categories_qs[:widget_instance.item_count])
                
                # --- NEW CASES FOR POST GRIDS ---
                case 'post_grid_recent':
                    items_qs = Post.objects.filter(status='published').order_by('-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                    # No new thumbnail_url required here, as the template will handle it dynamically.

                case 'post_grid_popular':
                    items_qs = Post.objects.filter(status='published').order_by('-views_count', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case 'post_grid_commented':
                    items_qs = Post.objects.filter(status='published') \
                                           .annotate(num_comments=Count('comments', filter=Q(comments__is_approved=True))) \
                                           .filter(num_comments__gt=0) \
                                           .order_by('-num_comments', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])
                
                case 'post_grid_editor':
                    items_qs = Post.objects.filter(status='published', editor_rating__gt=0) \
                                           .order_by('-editor_rating', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case 'post_carousel':
                    # You can configure which posts go into the carousel.
                    # For simplicity, let's use a "top N" most recent posts or highly rated posts.
                    # This example uses editor_rating > 0.
                    items_qs = Post.objects.filter(status='published', editor_rating__gt=0) \
                                           .order_by('-editor_rating', '-published_date')
                    items_container = list(items_qs[:widget_instance.item_count])

                case _: # Unrecognized widget type
                    logger.warning(f"Unrecognized widget type '{widget_instance.widget_type}' for widget '{widget_instance.title}'.")
                    items_container = [] # Empty list for safety.
            
            # --- Common Post-based Processing (Applies only to Post items) ---
            # Attach thumbnail_url to Post objects. This runs once per item on cache miss.
            # This should not run for categories.
            if widget_instance.widget_type in ['recent_posts', 'most_viewed_posts', 'most_commented_posts', 'editor_picks_posts', 'post_grid_recent', 'post_grid_popular', 'post_grid_commented', 'post_grid_editor', 'post_carousel']:
                for post_obj in items_container: 
                    # post_obj is already a Post instance here (from items_container)
                    post_obj.thumbnail_url = _get_thumbnail_url(post_obj)
            
            items_to_cache = items_container # Assign the processed list for caching

            # 3. Store result in cache if timeout is set.
            if widget_instance.cache_timeout > 0: # Only cache if timeout > 0
                cache.set(cache_key, items_to_cache, widget_instance.cache_timeout)
                logger.info(f"CACHE SET for widget '{widget_instance.title}' (ID: {widget_instance.id}) for {widget_instance.cache_timeout} seconds.")
        else: # Cache HIT
            logger.info(f"CACHE HIT for widget '{widget_instance.title}' (ID: {widget_instance.id}). Serving from cache.")

        # --- IMPORTANT: Append to processed_widgets list outside the `if items_to_cache is None` block ---
        # `items_to_cache` will hold either the cached value or the newly fetched value.
        processed_widgets.append({'widget': widget_instance, 'items': items_to_cache})
        
    return {'processed_widgets': processed_widgets, 'request': context['request']}./widgets/templatetags/__init__.py
# --- ./widgets/templatetags/__init__.py ---
./contact/views.py
# --- ./contact/views.py ---
# contact/views.py
from django.shortcuts import render, redirect
from django.urls import reverse
from django.contrib import messages
from django.utils.translation import gettext
from .forms import ContactForm

def contact_view(request):
    """
    Displays the contact form and handles form submission.
    """
    if request.method == 'POST':
        # If the form is submitted, bind the POST data to a form instance.
        form = ContactForm(request.POST)
        if form.is_valid():
            # If the data is valid, save it to the database.
            form.save()

            # Create a success message.
            success_message = gettext("Thank you for your message! We will get back to you shortly.")
            messages.success(request, success_message)

            # Redirect to the same page to prevent form resubmission (Post/Redirect/Get pattern).
            return redirect(reverse('contact:contact_form') + '#contact-form')
    else:
        # If it's a GET request, create a blank form instance.
        form = ContactForm()

    return render(request, 'contact/contact_form.html', {'form': form})

# Create your views here.
./contact/forms.py
# --- ./contact/forms.py ---
# contact/forms.py
from django import forms
from django.utils.translation import gettext_lazy as _
from .models import ContactMessage

class ContactForm(forms.ModelForm):
    """
    A form for users to send contact messages.
    It's based on the ContactMessage model.
    """
    class Meta:
        model = ContactMessage
        # These are the fields the user will see and fill out.
        # We exclude fields like 'is_read' or 'priority' which are for admin use only.
        fields = ['name', 'email', 'subject', 'message']

        # Here we can add Bootstrap classes and other attributes to our form fields.
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control', 
                'placeholder': _('Your Full Name')
            }),
            'email': forms.EmailInput(attrs={
                'class': 'form-control', 
                'placeholder': _('Your Email Address')
            }),
            'subject': forms.TextInput(attrs={
                'class': 'form-control', 
                'placeholder': _('Message Subject')
            }),
            'message': forms.Textarea(attrs={
                'class': 'form-control', 
                'rows': 5,
                'placeholder': _('Write your message here...')
            }),
        }

        # Optional: Customize the labels if needed.
        # By default, Django uses the verbose_name from the model.
        labels = {
            'name': _('Full Name'),
            'email': _('Email Address'),
        }./contact/migrations/0001_initial.py
# --- ./contact/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ContactMessage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=150, verbose_name='Name')),
                ('email', models.EmailField(max_length=254, verbose_name='Email')),
                ('subject', models.CharField(max_length=200, verbose_name='Subject')),
                ('message', models.TextField(verbose_name='Message')),
                ('priority', models.IntegerField(choices=[(1, 'Low'), (2, 'Medium'), (3, 'High'), (4, 'Urgent'), (5, 'Critical')], default=2, verbose_name='Priority')),
                ('is_read', models.BooleanField(default=False, help_text='Indicates if an admin has reviewed this message.', verbose_name='Has been read?')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Received At')),
                ('responded_at', models.DateTimeField(blank=True, help_text='Automatically set when the message is first marked as read.', null=True, verbose_name='Responded At')),
                ('responded_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='handled_contact_messages', to=settings.AUTH_USER_MODEL, verbose_name='Responded By')),
            ],
            options={
                'verbose_name': 'Contact Message',
                'verbose_name_plural': 'Contact Messages',
                'ordering': ['-priority', '-created_at'],
            },
        ),
    ]
./contact/migrations/__init__.py
# --- ./contact/migrations/__init__.py ---
./contact/admin.py
# --- ./contact/admin.py ---
# contact/admin.py
import logging
from django.contrib import admin
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from .models import ContactMessage

logger = logging.getLogger(__name__)

@admin.register(ContactMessage)
class ContactMessageAdmin(admin.ModelAdmin):
    """ Admin options for the ContactMessage model. """
    list_display = ('subject', 'name', 'priority', 'is_read', 'responded_by', 'responded_at')
    list_filter = ('is_read', 'priority', 'created_at')
    search_fields = ('name', 'email', 'subject', 'message')
    list_editable = ('is_read', 'priority')
    readonly_fields = ('name', 'email', 'subject', 'message', 'created_at', 'responded_at', 'responded_by')

    def save_model(self, request, obj, form, change):
        """
        Custom save logic: sets 'responded_at' timestamp and 'responded_by' user
        when a message is first marked as read, and clears them if marked as unread.
        """
        # Check if 'is_read' is among the fields that have been changed in the form.
        if 'is_read' in form.changed_data:
            # Case 1: The message is being marked as READ.
            if obj.is_read:
                # We only set the data the first time it's marked as read.
                if not obj.responded_at:
                    obj.responded_at = timezone.now()
                    obj.responded_by = request.user
                    logger.info(
                        f"Admin user '{request.user.username}' (ID: {request.user.id}) marked "
                        f"contact message ID {obj.id} ('{obj.subject}') as READ."
                    )
            # Case 2: The message is being marked as UNREAD.
            else:
                obj.responded_at = None
                obj.responded_by = None
                logger.info(
                    f"Admin user '{request.user.username}' (ID: {request.user.id}) marked "
                    f"contact message ID {obj.id} as UNREAD."
                )
        # Call the original save_model method to continue the saving process.
        super().save_model(request, obj, form, change)./contact/urls.py
# --- ./contact/urls.py ---
# contact/urls.py
from django.urls import path
from . import views

app_name = 'contact'

urlpatterns = [
    path('', views.contact_view, name='contact_form'),
]./contact/apps.py
# --- ./contact/apps.py ---
from django.apps import AppConfig


class ContactConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'contact'
./contact/models.py
# --- ./contact/models.py ---
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.contrib.auth.models import User 

class ContactMessage(models.Model):
    """
    Represents a message submitted through the site's contact form.
    """
    
    # An enumeration for message priority levels.
    # This is the modern, recommended way to create choices in Django.
    class Priority(models.IntegerChoices):
        LOW = 1, _('Low')
        MEDIUM = 2, _('Medium')
        HIGH = 3, _('High')
        URGENT = 4, _('Urgent')
        CRITICAL = 5, _('Critical')

    # Fields for the submitted message content
    name = models.CharField(max_length=150, verbose_name=_("Name"))
    email = models.EmailField(verbose_name=_("Email"))
    subject = models.CharField(max_length=200, verbose_name=_("Subject"))
    message = models.TextField(verbose_name=_("Message"))
    
    # Fields for internal management
    priority = models.IntegerField(
        choices=Priority.choices, 
        default=Priority.MEDIUM,
        verbose_name=_("Priority")
    )
    is_read = models.BooleanField(
        default=False, 
        verbose_name=_("Has been read?"),
        help_text=_("Indicates if an admin has reviewed this message.")
    )
    
    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True, 
        verbose_name=_("Received At")
    )
    responded_at = models.DateTimeField(
        null=True, 
        blank=True, 
        verbose_name=_("Responded At"),
        help_text=_("Automatically set when the message is first marked as read.")
    )
    responded_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL, # Don't delete the message if the user is deleted
        null=True, # this field can be empty if no admin has responded yet
        blank=True,
        related_name='handled_contact_messages',
        verbose_name=_("Responded By")
    )
    class Meta:
        # Default ordering puts the most important and newest messages at the top.
        ordering = ['-priority', '-created_at']
        verbose_name = _("Contact Message")
        verbose_name_plural = _("Contact Messages")

    def __str__(self):
        return f'Message from {self.name} - "{self.subject}"'./contact/tests.py
# --- ./contact/tests.py ---
from django.test import TestCase

# Create your tests here.
./contact/__init__.py
# --- ./contact/__init__.py ---
./create_superuser.py
# --- ./create_superuser.py ---
import os
import django

# Configura el entorno Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')  # Asegúrate de que 'tvt' es el nombre correcto de tu proyecto
django.setup()

from django.contrib.auth import get_user_model
User = get_user_model()
User.objects.create_superuser(
    username='tavata', 
    email='tavata.art@gmail.com', 
    password='@ng3lBTeVeTD', 
    is_staff=True, 
    is_superuser=True
)./pages/views.py
# --- ./pages/views.py ---
# pages/views.py
import logging
from django.shortcuts import render, get_object_or_404
from .models import Page
from categories.models import Category
from django.core.paginator import Paginator # Asegúrate de importar Paginator
from site_settings.models import SiteConfiguration

logger = logging.getLogger(__name__)

def page_detail_view(request, slug):
    # Buscamos una página que coincida con el slug Y que esté publicada.
    # Si no la encuentra, automáticamente devuelve un error 404.
    page = get_object_or_404(Page, slug=slug, status='published')

    # El contexto es el diccionario de datos que pasamos a la plantilla.
    context = {
        'page': page,
        'translatable_object': page,
    }

    return render(request, 'pages/page_detail.html', context)

def pages_by_category_view(request, category_slug):
    """
    Displays a paginated list of published pages belonging
    to a specific category.
    """
    category = get_object_or_404(Category, slug=category_slug)
    all_pages_in_category = category.pages.filter(status='published').order_by('title')

    try:
        site_config = SiteConfiguration.get_solo()
        # Usamos el mismo setting que para el blog para mantener la consistencia
        items_per_page = site_config.blog_items_per_page 
    except SiteConfiguration.DoesNotExist:
        logger.warning("SiteConfiguration does not exist. Using default items per page.")
        items_per_page = 9 # Fallback

    paginator = Paginator(all_pages_in_category, items_per_page)
    page_number = request.GET.get('page', 1)

    pages_list = paginator.get_page(page_number)

    context = {
        'category': category,
        'pages_list': pages_list, # Pasamos el objeto paginado
    }
    return render(request, 'pages/pages_by_category.html', context)
   ./pages/migrations/0001_initial.py
# --- ./pages/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('categories', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Page',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=250, verbose_name='Title')),
                ('title_es', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_en', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('title_ca', models.CharField(max_length=250, null=True, verbose_name='Title')),
                ('slug', models.SlugField(max_length=250, unique=True, verbose_name='Slug (URL friendly)')),
                ('slug_es', models.SlugField(max_length=250, null=True, unique=True, verbose_name='Slug (URL friendly)')),
                ('slug_en', models.SlugField(max_length=250, null=True, unique=True, verbose_name='Slug (URL friendly)')),
                ('slug_ca', models.SlugField(max_length=250, null=True, unique=True, verbose_name='Slug (URL friendly)')),
                ('content', models.TextField(verbose_name='Content')),
                ('content_es', models.TextField(null=True, verbose_name='Content')),
                ('content_en', models.TextField(null=True, verbose_name='Content')),
                ('content_ca', models.TextField(null=True, verbose_name='Content')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('published', 'Published')], default='draft', max_length=10, verbose_name='Status')),
                ('is_homepage', models.BooleanField(default=False, help_text='Mark only one page with this option. If multiple are marked, the most recent one will be used.', verbose_name='Is Homepage?')),
                ('meta_title', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_es', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_en', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_title_ca', models.CharField(blank=True, max_length=70, null=True, verbose_name='Meta Title (SEO)')),
                ('meta_description', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_es', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_en', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('meta_description_ca', models.CharField(blank=True, max_length=160, null=True, verbose_name='Meta Description (SEO)')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Creation Date')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Last Updated')),
                ('importance_order', models.PositiveIntegerField(default=99, help_text="A lower number means higher priority in search results. E.g., 1 for 'About Us', 2 for 'Contact', 99 for others.", verbose_name='Importance Order')),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='pages', to=settings.AUTH_USER_MODEL, verbose_name='Author')),
                ('categories', models.ManyToManyField(blank=True, related_name='pages', to='categories.category', verbose_name='Categories')),
            ],
            options={
                'verbose_name': 'page',
                'verbose_name_plural': 'pages',
                'ordering': ['-created_at'],
            },
        ),
    ]
./pages/migrations/0002_page_featured_image.py
# --- ./pages/migrations/0002_page_featured_image.py ---
# Generated by Django 5.2.3 on 2025-06-21 10:41

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('pages', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='page',
            name='featured_image',
            field=models.ImageField(blank=True, null=True, upload_to='blog/featured/', verbose_name='Featured Image'),
        ),
    ]
./pages/migrations/__init__.py
# --- ./pages/migrations/__init__.py ---
./pages/admin.py
# --- ./pages/admin.py ---
# File: pages/admin.py
import logging
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from django.conf import settings # Required for dynamically generating search fields

# Third-party imports
from django_summernote.admin import SummernoteModelAdmin # For WYSIWYG editor on Page
from modeltranslation.admin import TabbedTranslationAdmin # For multilingual admin
from modeltranslation.translator import translator # Required for dynamic fields

# Local application imports (ensure these models exist in pages.models, categories.models)
from .models import Page 
from categories.models import Category # Universal Category model


logger = logging.getLogger(__name__)


# Helper function to dynamically generate search_fields and prepopulated_fields
# This is a re-use of the logic from blog/admin.py
def get_language_aware_admin_fields(model_kls):
    search_fields_list = []
    prepopulated_fields_dict = {}
    
    trans_opts = None
    try:
        trans_opts = translator.get_options_for_model(model_kls)
    except translator.NotRegistered:
        logger.warning(f"Model {model_kls.__name__} not registered for translation. Dynamic admin fields might be incomplete.")
        pass 

    for lang_code, _ in settings.LANGUAGES:
        if trans_opts:
            # Assuming 'title' and 'content' are common translatable fields
            if 'title' in trans_opts.fields:
                search_fields_list.append(f'title_{lang_code}')
            if 'content' in trans_opts.fields:
                search_fields_list.append(f'content_{lang_code}')
        
        # Consistent prepopulated_fields for slug based on title
        if hasattr(model_kls, 'slug') and hasattr(model_kls, f'title_{lang_code}'): 
            prepopulated_fields_dict[f'slug_{lang_code}'] = (f'title_{lang_code}',)
            
    return tuple(search_fields_list), prepopulated_fields_dict


# --- ADMIN FOR UNIVERSAL CATEGORIES ---
# This part is for the Category model in the categories app, not in pages app.
# Ensure this is defined in categories/admin.py, not here.


# --- ADMIN FOR PAGES ---
@admin.register(Page)
class PageAdmin(SummernoteModelAdmin, TabbedTranslationAdmin):
    """
    Admin options for the Page model, integrating Summernote for content,
    ModelTranslation for multilingual fields, and managing categories.
    """
    # What fields to display in the list view
    list_display = ('title', 'status', 'is_homepage', 'importance_order', 'author', 'display_categories_list')
    
    # Allow editing these fields directly from the list view
    list_editable = ('status', 'is_homepage', 'importance_order') # Removed 'author' if it's a many-to-many relationship
    
    # Filters in the right sidebar
    list_filter = ('status', 'author', 'categories', 'is_homepage')
    
    # Generate search_fields and prepopulated_fields dynamically
    _search_fields, _prepopulated_fields = get_language_aware_admin_fields(Page)
    search_fields = _search_fields
    prepopulated_fields = _prepopulated_fields
    
    # Default ordering for the list
    ordering = ('importance_order', '-updated_at')
    
    # ManyToManyField for categories, uses a nice multi-selector interface
    filter_horizontal = ('categories',) 
    
    # Summernote fields must be specified for each language (e.g., 'content_en')
    summernote_fields = tuple([f'content_{lang_code}' for lang_code, _ in settings.LANGUAGES])


    # Custom method to display categories in the list view
    @admin.display(description=_("Categories"))
    def display_categories_list(self, obj):
        return ", ".join([cat.name for cat in obj.categories.all()])./pages/urls.py
# --- ./pages/urls.py ---
# pages/urls.py
from django.urls import path
from . import views

app_name = 'pages' # <-- AÑADIMOS ESTA LÍNEA

urlpatterns = [
    # NUEVA RUTA: Recibirá un 'slug' de categoría como parámetro
    # Ejemplo: /pages/category/tutoriales/
    path('category/<slug:category_slug>/', views.pages_by_category_view, name='pages_by_category'),

    # Ruta existente para el detalle de una página
    # Ejemplo: /pages/sobre-nosotros/
    path('<slug:slug>/', views.page_detail_view, name='page_detail'),
]./pages/translation.py
# --- ./pages/translation.py ---
# pages/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Page
    
@register(Page)
class PageTranslationOptions(TranslationOptions):
    fields = ('title', 'slug', 'content', 'meta_title', 'meta_description')./pages/apps.py
# --- ./pages/apps.py ---
from django.apps import AppConfig


class PagesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pages'
./pages/models.py
# --- ./pages/models.py ---
from django.db import models
from django.contrib.auth.models import User
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from django.contrib.contenttypes.fields import GenericRelation
from categories.models import Category
from django.utils.translation import override 

class Page(models.Model):
    """ Represents a single static page in the CMS, like 'About Us'. """
    
    STATUS_CHOICES = (
        ('draft', _('Draft')),
        ('published', _('Published')),
    )
    
    title = models.CharField(max_length=250, verbose_name=_("Title"))
    slug = models.SlugField(max_length=250, unique=True, verbose_name=_("Slug (URL friendly)"))
    content = models.TextField(verbose_name=_("Content")) # The editor will be applied in admin.py
    
    author = models.ForeignKey(User, on_delete=models.PROTECT, related_name="pages", verbose_name=_("Author"))
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft', verbose_name=_("Status"))
    
    categories = models.ManyToManyField(
        Category,
        blank=True,
        verbose_name=_("Categories"),
        related_name="pages"
    )
    
    is_homepage = models.BooleanField(
        default=False,
        verbose_name=_("Is Homepage?"),
        help_text=_("Mark only one page with this option. If multiple are marked, the most recent one will be used.")
    )

    meta_title = models.CharField(max_length=70, blank=True, null=True, verbose_name=_("Meta Title (SEO)"))
    meta_description = models.CharField(max_length=160, blank=True, null=True, verbose_name=_("Meta Description (SEO)"))

    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Creation Date"))
    updated_at = models.DateTimeField(auto_now=True, verbose_name=_("Last Updated"))

    importance_order = models.PositiveIntegerField(
        default=99,
        verbose_name=_("Importance Order"),
        help_text=_("A lower number means higher priority in search results. E.g., 1 for 'About Us', 2 for 'Contact', 99 for others.")
    )
    featured_image = models.ImageField(
        upload_to='blog/featured/', 
        blank=True, 
        null=True, 
        verbose_name=_("Featured Image")
    )
    class Meta:
        verbose_name = _("page")
        verbose_name_plural = _("pages")
        ordering = ['-created_at']

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        # Uses the 'pages' namespace to generate the correct URL.
        return reverse('pages:page_detail', kwargs={'slug': self.slug})
    
    def get_absolute_url_for_language(self, language_code):
        with override(language_code):
            # 'self.slug' automáticamente devuelve el slug para el idioma actual del contexto.
            # Al usar 'override(language_code)', estamos forzando el contexto.
            return reverse('pages:page_detail', kwargs={'slug': self.slug}) ./pages/tests.py
# --- ./pages/tests.py ---
from django.test import TestCase

# Create your tests here.
./pages/__init__.py
# --- ./pages/__init__.py ---
./site_settings/views.py
# --- ./site_settings/views.py ---
from django.shortcuts import render

# Create your views here.
./site_settings/migrations/0002_siteconfiguration_category_tree_cache_timeout.py
# --- ./site_settings/migrations/0002_siteconfiguration_category_tree_cache_timeout.py ---
# Generated by Django 5.2.3 on 2025-06-19 20:53

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('site_settings', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='siteconfiguration',
            name='category_tree_cache_timeout',
            field=models.PositiveIntegerField(default=43200, help_text='How long the full category tree should be stored in cache. High values are recommended.', verbose_name='Category Tree Cache Timeout (in seconds)'),
        ),
    ]
./site_settings/migrations/0001_initial.py
# --- ./site_settings/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='SiteConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('blog_items_per_page', models.PositiveIntegerField(default=9, help_text='Number of posts to show on the main blog page and on category pages.', verbose_name='Items per Page in Blog/Category lists')),
                ('search_pages_per_page', models.PositiveIntegerField(default=5, verbose_name='Pages per Page in Search Results')),
                ('search_posts_per_page', models.PositiveIntegerField(default=5, verbose_name='Posts per Page in Search Results')),
                ('search_results_per_page', models.PositiveIntegerField(default=5, help_text='Number of items to show per section (Pages/Posts) on the search results page.', verbose_name='Results per Page in Search')),
                ('search_importance_limit', models.PositiveIntegerField(default=3, help_text='How many top-priority pages to display before regular search results.', verbose_name="Number of 'Important' Pages to show first in search")),
                ('comment_indentation_pixels', models.PositiveIntegerField(default=20, help_text='Controls the visual indentation for nested comments in the admin.', verbose_name='Comment Indentation (in pixels)')),
                ('auto_approve_comments', models.BooleanField(default=False, help_text='If checked, new comments will be published immediately without moderation.', verbose_name='Auto-approve comments')),
                ('menu_cache_timeout', models.PositiveIntegerField(default=3600, help_text='How long the site menus should be stored in cache. Set to 0 to disable menu caching (not recommended).', verbose_name='Menu Cache Timeout (in seconds)')),
                ('site_logo', models.ImageField(blank=True, help_text='The main logo displayed in the top bar.', null=True, upload_to='site_branding/', verbose_name='Site Logo')),
                ('site_slogan', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, verbose_name='Site Slogan')),
                ('site_slogan_es', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, null=True, verbose_name='Site Slogan')),
                ('site_slogan_en', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, null=True, verbose_name='Site Slogan')),
                ('site_slogan_ca', models.CharField(blank=True, help_text='A short tagline displayed next to the logo.', max_length=150, null=True, verbose_name='Site Slogan')),
                ('trusted_commenter_threshold', models.PositiveIntegerField(default=10, help_text='The number of approved comments a user needs to post before their future comments are auto-approved.', verbose_name='Trusted Commenter Threshold')),
                ('top_bar_banner_image', models.ImageField(blank=True, help_text='An optional banner image displayed in the top bar.', null=True, upload_to='site_branding/banners/', verbose_name='Top Bar Banner Image')),
                ('top_bar_banner_link', models.URLField(blank=True, help_text='The URL the banner image will link to.', max_length=255, verbose_name='Top Bar Banner Link')),
            ],
            options={
                'verbose_name': 'Site Configuration',
                'verbose_name_plural': 'Site Configuration',
            },
        ),
    ]
./site_settings/migrations/0004_siteconfiguration_user_profile_items_per_page.py
# --- ./site_settings/migrations/0004_siteconfiguration_user_profile_items_per_page.py ---
# Generated by Django 5.2.3 on 2025-06-21 13:20

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('site_settings', '0003_siteconfiguration_gallery_items_per_page'),
    ]

    operations = [
        migrations.AddField(
            model_name='siteconfiguration',
            name='user_profile_items_per_page',
            field=models.PositiveIntegerField(default=5, help_text="Number of posts/comments to show per page on a user's public profile.", verbose_name='Items per Page on Public Profile'),
        ),
    ]
./site_settings/migrations/__init__.py
# --- ./site_settings/migrations/__init__.py ---
./site_settings/migrations/0003_siteconfiguration_gallery_items_per_page.py
# --- ./site_settings/migrations/0003_siteconfiguration_gallery_items_per_page.py ---
# Generated by Django 5.2.3 on 2025-06-21 10:47

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('site_settings', '0002_siteconfiguration_category_tree_cache_timeout'),
    ]

    operations = [
        migrations.AddField(
            model_name='siteconfiguration',
            name='gallery_items_per_page',
            field=models.PositiveIntegerField(default=9, help_text='Number of images to show on the image gallery page.', verbose_name='Items per Page in Gallery'),
        ),
    ]
./site_settings/admin.py
# --- ./site_settings/admin.py ---
# File: site_settings/admin.py
from django.contrib import admin
from solo.admin import SingletonModelAdmin
from modeltranslation.admin import TabbedTranslationAdmin
from .models import SiteConfiguration

@admin.register(SiteConfiguration)
class SiteConfigurationAdmin(SingletonModelAdmin, TabbedTranslationAdmin):
    """
    Admin for the SiteConfiguration singleton model.
    We keep it simple and let solo and modeltranslation handle the rendering.
    """
    # No 'fields' or 'fieldsets'. Let the libraries do their job.
    pass./site_settings/translation.py
# --- ./site_settings/translation.py ---
from modeltranslation.translator import register, TranslationOptions
from .models import SiteConfiguration

@register(SiteConfiguration)
class SiteConfigurationTranslationOptions(TranslationOptions):
    fields = ('site_slogan',)./site_settings/apps.py
# --- ./site_settings/apps.py ---
from django.apps import AppConfig


class SiteSettingsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'site_settings'
./site_settings/models.py
# --- ./site_settings/models.py ---
from django.db import models
from django.utils.translation import gettext_lazy as _, gettext
from solo.models import SingletonModel

class SiteConfiguration(SingletonModel):
    """
    Singleton model to store site-wide configuration settings.
    Only one instance of this model will ever exist.
    """

    # --- Pagination Settings ---
    blog_items_per_page = models.PositiveIntegerField(
        default=9, 
        verbose_name=_("Items per Page in Blog/Category lists"),
        help_text=_("Number of posts to show on the main blog page and on category pages.")
    )
    search_pages_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Pages per Page in Search Results")
    )
    search_posts_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Posts per Page in Search Results")
    )
    search_results_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Results per Page in Search"),
        help_text=_("Number of items to show per section (Pages/Posts) on the search results page.")
    )
    # --- Search Settings ---
    search_importance_limit = models.PositiveIntegerField(
        default=3,
        verbose_name=_("Number of 'Important' Pages to show first in search"),
        help_text=_("How many top-priority pages to display before regular search results.")
    )

    # --- Admin Display Settings ---
    comment_indentation_pixels = models.PositiveIntegerField(
        default=20,
        verbose_name=_("Comment Indentation (in pixels)"),
        help_text=_("Controls the visual indentation for nested comments in the admin.")
    )

    # --- Comment Moderation Settings ---
    auto_approve_comments = models.BooleanField(
        default=False, 
        verbose_name=_("Auto-approve comments"),
        help_text=_("If checked, new comments will be published immediately without moderation.")
    )
        # --- Caching Settings ---
    menu_cache_timeout = models.PositiveIntegerField(
        default=3600, # Default to 1 hour (3600 seconds)
        verbose_name=_("Menu Cache Timeout (in seconds)"),
        help_text=_("How long the site menus should be stored in cache. Set to 0 to disable menu caching (not recommended).")
    )
    # --- Branding Settings ---
    site_logo = models.ImageField(
        upload_to='site_branding/',
        blank=True, null=True,
        verbose_name=_("Site Logo"),
        help_text=_("The main logo displayed in the top bar.")
    )
    site_slogan = models.CharField(
        max_length=150, 
        blank=True, 
        verbose_name=_("Site Slogan"),
        help_text=_("A short tagline displayed next to the logo.")
    )
    trusted_commenter_threshold = models.PositiveIntegerField(
        default=10,
        verbose_name=_("Trusted Commenter Threshold"),
        help_text=_("The number of approved comments a user needs to post before their future comments are auto-approved.")
    )
    category_tree_cache_timeout = models.PositiveIntegerField(
        default=43200, # Default to 12 hours
        verbose_name=_("Category Tree Cache Timeout (in seconds)"),
        help_text=_("How long the full category tree should be stored in cache. High values are recommended.")
    )
    gallery_items_per_page = models.PositiveIntegerField(
        default=9,
        verbose_name=_("Items per Page in Gallery"),
        help_text=_("Number of images to show on the image gallery page.")
    )
    user_profile_items_per_page = models.PositiveIntegerField(
        default=5, 
        verbose_name=_("Items per Page on Public Profile"),
        help_text=_("Number of posts/comments to show per page on a user's public profile.")
    )
    # --- Top Bar Banner/Ad Settings ---
    top_bar_banner_image = models.ImageField(
        upload_to='site_branding/banners/',
        blank=True, null=True,
        verbose_name=_("Top Bar Banner Image"),
        help_text=_("An optional banner image displayed in the top bar.")
    )
    top_bar_banner_link = models.URLField(
        max_length=255, 
        blank=True, 
        verbose_name=_("Top Bar Banner Link"),
        help_text=_("The URL the banner image will link to.")
    )

    class Meta:
        verbose_name = _("Site Configuration")
        verbose_name_plural = _("Site Configuration")

    def __str__(self):
        return gettext("Site Configuration")./site_settings/tests.py
# --- ./site_settings/tests.py ---
from django.test import TestCase

# Create your tests here.
./site_settings/__init__.py
# --- ./site_settings/__init__.py ---
./site_settings/templatetags/settings_tags.py
# --- ./site_settings/templatetags/settings_tags.py ---
# File: site_settings/templatetags/settings_tags.py
from django import template
from site_settings.models import SiteConfiguration

register = template.Library()

@register.simple_tag
def get_site_config():
    """
    A simple template tag to fetch the single SiteConfiguration object.
    This allows easy access to global settings in templates.
    It uses caching for high performance.
    """
    # We can add caching here as we did with widgets.
    # For simplicity now, we get it directly.

    # .get() is safe because django-solo ensures there's only one.
    return SiteConfiguration.get_solo()./site_settings/templatetags/__init__.py
# --- ./site_settings/templatetags/__init__.py ---
./gallery/views.py
# --- ./gallery/views.py ---
# File: gallery/views.py
from django.shortcuts import render, get_object_or_404
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.utils.html import strip_tags 
from django.utils.translation import get_language, activate, deactivate 
from django.conf import settings # Import settings for accessing LANGUAGES

from site_settings.models import SiteConfiguration # For pagination settings
from blog.models import Post # For collecting featured images from posts
from pages.models import Page # For collecting featured images from pages (assuming it has featured_image)
from .models import Image # For images specifically in the gallery app
import logging
import datetime

logger = logging.getLogger(__name__)

# Helper function to get a truncated description (remains the same)
def get_truncated_description(text, max_length=200):
    """Safely truncates and cleans text for description display."""
    if not text:
        return ""
    stripped_text = strip_tags(str(text)) 
    if len(stripped_text) > max_length:
        return stripped_text[:max_length] + "..."
    return stripped_text

def gallery_view(request):
    """
    Collects images from the Image model and featured images from Posts and Pages,
    normalizes their data, sorts them, and displays them in a paginated gallery.
    """
    gallery_items_data = [] # This list will hold uniform dictionaries for the template
    current_lang = get_language() # Get current language for consistent data retrieval

    # --- Get all images from the gallery.Image model ---
    # Log the number of objects found before processing
    logger.debug(f"Collecting images from gallery.Image model. Found {Image.objects.count()} objects.")
    for img_obj in Image.objects.all():
        # Ensure image has a file attached before trying to get its URL
        img_url = img_obj.image.url if img_obj.image else '' 
        # get_absolute_url() needs to be correctly defined in Image model
        detail_url = img_obj.get_absolute_url() 
        logger.debug(f"Processing Image (ID: {img_obj.pk}): URL={img_url}, DetailURL={detail_url}, Title={img_obj.title}")

        gallery_items_data.append({
            'image_url': img_url,
            'title': img_obj.title, # Modeltranslation handles title directly
            'description': get_truncated_description(img_obj.description),
            'detail_url': detail_url,
            'date': img_obj.uploaded_at, # Use uploaded_at for sorting
            'type': 'Image'
        })
    
    # --- Get featured images from blog.Post model ---
    # Filter for published posts that have a featured image
    posts_with_images = Post.objects.filter(
        status='published', 
        featured_image__isnull=False # Ensure featured_image is not null
    ).exclude(featured_image='').order_by('-published_date') # Exclude empty string
    
    logger.debug(f"Collecting featured images from blog.Post model. Found {posts_with_images.count()} objects.")
    for post_obj in posts_with_images:
        post_img_url = post_obj.featured_image.url if post_obj.featured_image else ''
        post_detail_url = post_obj.get_absolute_url()
        post_published_date = post_obj.published_date 
        
        # Use get_language()/activate/deactivate for language-specific fields like title/description from other models
        # It ensures we grab the translation in the CURRENT language for uniform data collection.
        old_lang = get_language()
        activate(current_lang) 
        
        gallery_items_data.append({
            'image_url': post_img_url,
            'title': post_obj.title, # Modeltranslation handles this
            'description': get_truncated_description(getattr(post_obj, 'meta_description', '') or post_obj.content), 
            'detail_url': post_detail_url,
            'date': post_published_date,
            'type': 'Post'
        })
        activate(old_lang) # Restore original language context

    # --- Get featured images from pages.Page model (if featured_image field exists) ---
    try:
        # Check if Page model has featured_image before querying
        if hasattr(Page, 'featured_image'):
            pages_with_images = Page.objects.filter(
                status='published',
                featured_image__isnull=False
            ).exclude(featured_image='').order_by('-updated_at')
            
            logger.debug(f"Collecting featured images from pages.Page model. Found {pages_with_images.count()} objects.")
            for page_obj in pages_with_images:
                page_img_url = page_obj.featured_image.url if page_obj.featured_image else ''
                page_detail_url = page_obj.get_absolute_url()
                page_updated_at = page_obj.updated_at
                
                old_lang = get_language()
                activate(current_lang)
                gallery_items_data.append({
                    'image_url': page_img_url,
                    'title': page_obj.title, # Modeltranslation handles this
                    'description': get_truncated_description(getattr(page_obj, 'meta_description', '') or page_obj.content),
                    'detail_url': page_detail_url,
                    'date': page_updated_at,
                    'type': 'Page'
                })
                activate(old_lang) # Restore original language context
        else:
            logger.debug("Page model does not have 'featured_image' field. Skipping page image collection.")
    except Exception as e:
        logger.warning(f"Error collecting featured images from Pages: {e}. Check Page model's 'featured_image' field configuration.")


    # --- Sort the combined list by date (newest first) ---
    # Ensure 'date' key always exists with a valid datetime object for sorting.
    # Handle cases where `date` might be None, placing them at the end.
    gallery_items_data.sort(key=lambda x: x.get('date') if x.get('date') is not None else datetime.min, reverse=True)
    
    # --- Apply Pagination ---
    try:
        site_config = SiteConfiguration.get_solo()
        gallery_items_per_page = getattr(site_config, 'gallery_items_per_page', 9) 
    except SiteConfiguration.DoesNotExist:
        gallery_items_per_page = 9 # Fallback value
        logger.warning("SiteConfiguration not found. Using default gallery pagination (9 items).")
    
    paginator = Paginator(gallery_items_data, gallery_items_per_page)
    page_number = request.GET.get('page')

    try:
        images_on_page = paginator.get_page(page_number)
    except PageNotAnInteger:
        images_on_page = paginator.get_page(1)
    except EmptyPage:
        # If the page number is out of range, get the last page, or an empty list if no items
        if paginator.num_pages > 0:
            images_on_page = paginator.get_page(paginator.num_pages)
        else:
            images_on_page = [] # No pages to display if paginator has 0 pages
    
    logger.info(f"Gallery view accessed. Showing page {getattr(images_on_page, 'number', 0)} of {getattr(images_on_page, 'paginator.num_pages', 0)} images.")

    context = {
        'images': images_on_page # Passed to template as 'images'
    }

    return render(request, 'gallery/gallery_page.html', context)

# NEW: View for individual image detail (basic placeholder)
def image_detail_view(request, pk):
    """ Displays details for a single image from the gallery. """
    image = get_object_or_404(Image, pk=pk)
    context = {
        'image': image,
        'translatable_object': image,
    }
    # Create this template: gallery/templates/gallery/image_detail.html
    return render(request, 'gallery/image_detail.html', context)./gallery/migrations/0001_initial.py
# --- ./gallery/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-20 21:50

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Image',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100)),
                ('image', models.ImageField(upload_to='gallery/')),
                ('uploaded_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]
./gallery/migrations/0002_image_title_ca_image_title_en_image_title_es.py
# --- ./gallery/migrations/0002_image_title_ca_image_title_en_image_title_es.py ---
# Generated by Django 5.2.3 on 2025-06-20 22:10

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('gallery', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='image',
            name='title_ca',
            field=models.CharField(max_length=100, null=True),
        ),
        migrations.AddField(
            model_name='image',
            name='title_en',
            field=models.CharField(max_length=100, null=True),
        ),
        migrations.AddField(
            model_name='image',
            name='title_es',
            field=models.CharField(max_length=100, null=True),
        ),
    ]
./gallery/migrations/0004_alter_image_options_image_description_and_more.py
# --- ./gallery/migrations/0004_alter_image_options_image_description_and_more.py ---
# Generated by Django 5.2.3 on 2025-06-21 10:41

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('gallery', '0003_alter_image_image_alter_image_title_and_more'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='image',
            options={'ordering': ['-uploaded_at'], 'verbose_name': 'Image', 'verbose_name_plural': 'Images'},
        ),
        migrations.AddField(
            model_name='image',
            name='description',
            field=models.TextField(blank=True, verbose_name='Description'),
        ),
        migrations.AddField(
            model_name='image',
            name='description_ca',
            field=models.TextField(blank=True, null=True, verbose_name='Description'),
        ),
        migrations.AddField(
            model_name='image',
            name='description_en',
            field=models.TextField(blank=True, null=True, verbose_name='Description'),
        ),
        migrations.AddField(
            model_name='image',
            name='description_es',
            field=models.TextField(blank=True, null=True, verbose_name='Description'),
        ),
    ]
./gallery/migrations/0003_alter_image_image_alter_image_title_and_more.py
# --- ./gallery/migrations/0003_alter_image_image_alter_image_title_and_more.py ---
# Generated by Django 5.2.3 on 2025-06-21 09:22

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('gallery', '0002_image_title_ca_image_title_en_image_title_es'),
    ]

    operations = [
        migrations.AlterField(
            model_name='image',
            name='image',
            field=models.ImageField(upload_to='gallery/', verbose_name='Image'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title',
            field=models.CharField(max_length=100, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title_ca',
            field=models.CharField(max_length=100, null=True, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title_en',
            field=models.CharField(max_length=100, null=True, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='title_es',
            field=models.CharField(max_length=100, null=True, verbose_name='Title'),
        ),
        migrations.AlterField(
            model_name='image',
            name='uploaded_at',
            field=models.DateTimeField(auto_now_add=True, verbose_name='Uploaded at'),
        ),
    ]
./gallery/migrations/__init__.py
# --- ./gallery/migrations/__init__.py ---
./gallery/admin.py
# --- ./gallery/admin.py ---
# File: gallery/admin.py
from django.contrib import admin
from .models import Image
from django.utils.translation import gettext_lazy as _
from modeltranslation.admin import TabbedTranslationAdmin
from django.conf import settings # NEW: Import settings
import logging

logger = logging.getLogger(__name__)

@admin.register(Image)
class ImageAdmin(TabbedTranslationAdmin):
    """
    Admin options for the Image model, integrating ModelTranslation for multilingual fields.
    Dynamically generates search_fields based on configured languages.
    """
    list_display = (
        'get_translated_title',  
        'image',                 
        'uploaded_at',           
    )
    list_filter = ('uploaded_at',) 
    ordering = ('-uploaded_at',) 

    # --- NEW: Dynamically generate search_fields ---
    # We create a list of all translatable fields (as defined in translation.py)
    # for each configured language.
    search_fields = []
    for lang_code, lang_name in settings.LANGUAGES:
        # Assuming 'title' and 'description' are the translatable fields for Image
        # as defined in gallery/translation.py
        search_fields.append(f'title_{lang_code}')
        search_fields.append(f'description_{lang_code}')
    # Convert the list to a tuple, as search_fields expects a tuple.
    search_fields = tuple(search_fields)
    # --- END NEW ---

    # Control which fields are editable in the form
    fields = ('title', 'description', 'image',) # Now 'title' and 'description' refer to the modeltranslation default fields (current language)

    # Custom method to display the translated title in the list view.
    @admin.display(description=_('Title'))
    def get_translated_title(self, obj):
        # obj.title automatically returns the translated title for the current admin language.
        return obj.title 
    
    def save_model(self, request, obj, form, change):
        """ Log when an image is saved or updated. """
        super().save_model(request, obj, form, change)
        if change:
            logger.info(f"Image '{obj.title}' (ID: {obj.id}) updated by {request.user.username}.")
        else:
            logger.info(f"New image '{obj.title}' (ID: {obj.id}) added by {request.user.username}.")
./gallery/urls.py
# --- ./gallery/urls.py ---
# File: gallery/urls.py
from django.urls import path
from . import views

app_name = 'gallery'

urlpatterns = [
    path('', views.gallery_view, name='gallery_view'),
    path('image/<int:pk>/', views.image_detail_view, name='image_detail'), # NEW: for individual image detail
]./gallery/translation.py
# --- ./gallery/translation.py ---
# File: gallery/translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Image

@register(Image)
class ImageTranslationOptions(TranslationOptions):
    fields = ('title', 'description',) # Include 'description' for translation./gallery/apps.py
# --- ./gallery/apps.py ---
from django.apps import AppConfig


class GalleryConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'gallery'
./gallery/models.py
# --- ./gallery/models.py ---
# File: gallery/models.py
from django.db import models
from django.urls import reverse # Import reverse
from django.utils.translation import gettext_lazy as _
from django.utils.translation import override 
import logging

logger = logging.getLogger(__name__)

class Image(models.Model):
    """
    Represents an image in the gallery with a title and description.
    """
    # Title stores the image's name/description, translatable.
    title = models.CharField(max_length=100, verbose_name=_("Title"))
    
    # Image file field. Images will be uploaded to the 'gallery/' subfolder in MEDIA_ROOT.
    image = models.ImageField(upload_to='gallery/', verbose_name=_("Image"))
    
    # NEW: Optional description for the image, translatable.
    description = models.TextField(blank=True, verbose_name=_("Description"))
    
    # Auto-added timestamp for when the image was uploaded.
    uploaded_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Uploaded at"))

    class Meta:
        ordering = ['-uploaded_at']
        verbose_name = _("Image")
        verbose_name_plural = _("Images")

    def __str__(self):
        # modeltranslation automatically returns the translated title.
        return self.title

    def get_absolute_url(self):
        """ Returns the URL to view this specific image's detail page. """
        # This will point to a dedicated view for the image itself.
        return reverse('gallery:image_detail', args=[self.pk]) 
    
    def get_absolute_url_for_language(self, language_code):
        with override(language_code):
            # El PK no cambia con el idioma, así que solo necesitamos el reverse en el contexto del idioma.
            return reverse('gallery:image_detail', args=[self.pk])./gallery/tests.py
# --- ./gallery/tests.py ---
from django.test import TestCase

# Create your tests here.
./gallery/__init__.py
# --- ./gallery/__init__.py ---
./manage.py
# --- ./manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tvt.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
./accounts/views.py
# --- ./accounts/views.py ---
# File: accounts/views.py
import logging
import os
import uuid
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import get_user_model
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.conf import settings 
from django.contrib import messages
from django.contrib.auth import login
from django.contrib.auth.decorators import login_required
from django.utils.translation import gettext
from .forms import CustomUserCreationForm, UserUpdateForm, ProfileUpdateForm

# Import the models required for the public profile view
from .models import Profile # Model for user profiles
from blog.models import Post, Comment # Models for posts and comments

from site_settings.models import SiteConfiguration 

# Get a logger instance for this module.
logger = logging.getLogger(__name__)
User = get_user_model()

# --- SIGNUP VIEW ---
def signup_view(request):
    """ Handles new user registration. """
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            logger.info(f"New user account created: '{user.username}' (ID: {user.id})")
            login(request, user)
            messages.success(request, gettext("Welcome! Your account has been created successfully."))
            return redirect('home')
        else:
            logger.warning(f"Signup form failed validation. Errors: {form.errors.as_json()}")
    else:
        form = CustomUserCreationForm()
        
    return render(request, 'registration/signup.html', {'form': form})


@login_required 
def profile_edit_view(request):
    if request.method == 'POST':
        user_form = UserUpdateForm(request.POST, instance=request.user)
        profile_form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user.profile)

        if user_form.is_valid() and profile_form.is_valid():
            # Guardamos el formulario de usuario, que es simple.
            user_form.save()
            
            # --- LÓGICA FINAL Y EXPLÍCITA DE AVATAR ---
            profile = request.user.profile

            # Caso 1: El usuario subió una nueva imagen.
            if 'avatar' in request.FILES:
                uploaded_file = request.FILES['avatar']
                # Construimos el nuevo nombre de archivo
                extension = os.path.splitext(uploaded_file.name)[1]
                new_filename = f"avatars/{uuid.uuid4().hex}{extension}"
                
                # Si ya existe una imagen personalizada, la borramos para no dejar basura.
                if profile.avatar and os.path.exists(profile.avatar.path):
                    default_paths = [c[0] for c in profile.AvatarChoice.choices]
                    if profile.avatar.name not in default_paths:
                        os.remove(profile.avatar.path)
                
                # Guardamos el nuevo archivo con el nuevo nombre.
                profile.avatar.save(new_filename, uploaded_file)
                logger.info(f"User '{request.user.username}' uploaded new avatar, saved as {new_filename}")
            
            # Caso 2: El usuario marcó "Limpiar".
            elif profile_form.cleaned_data.get('avatar-clear'):
                chosen_default = profile_form.cleaned_data.get('default_avatar_choice')
                profile.avatar = chosen_default
                logger.info(f"User '{request.user.username}' cleared avatar, reverting to {chosen_default}")

            # Actualizamos los otros campos del perfil desde los datos validados del formulario
            profile.display_name = profile_form.cleaned_data['display_name']
            profile.bio = profile_form.cleaned_data['bio']
            profile.location = profile_form.cleaned_data['location']
            profile.website_url = profile_form.cleaned_data['website_url']
            
            # Si no se limpió el avatar, la elección por defecto también se guarda
            if not profile_form.cleaned_data.get('avatar-clear'):
                 profile.default_avatar_choice = profile_form.cleaned_data.get('default_avatar_choice')
            
            profile.save() # Guardamos todos los cambios en el objeto profile
            
            messages.success(request, gettext("Your profile has been updated successfully!"))
            return redirect('accounts:profile_edit')
            
        else:
            logger.warning("Profile update form failed validation.", extra={'errors': profile_form.errors.as_json()})

    else:
        user_form = UserUpdateForm(instance=request.user)
        profile_form = ProfileUpdateForm(instance=request.user.profile)

    context = {
        'user_form': user_form,
        'profile_form': profile_form
    }
    
    return render(request, 'registration/profile_edit.html', context)

def user_profile_public_view(request, username):
    """
    Displays public information for a given user, including their profile details
    and a paginated list of their public contributions (posts, comments).
    """
    try:
        # Get the user by username, or return a 404
        user_obj = get_object_or_404(User, username=username)
        # Ensure the user has an associated profile
        if not hasattr(user_obj, 'profile') or user_obj.profile is None:
            logger.warning(f"User '{username}' does not have an associated profile. Creating one.")
            # This should ideally not happen due to the signal, but as a failsafe
            profile = user_obj.profile = Profile.objects.create(user=user_obj)
        else:
            profile = user_obj.profile

        logger.info(f"Public profile view accessed for user: '{username}'.")

        # --- User's Blog Posts (Publicly visible) ---
        user_posts = Post.objects.filter(
            author=user_obj, 
            status='published'
        ).order_by('-published_date')

        # --- User's Comments (Approved and publicly visible) ---
        user_comments = Comment.objects.filter(
            user=user_obj, 
            is_approved=True
        ).order_by('-created_at')

        site_config = SiteConfiguration.get_solo()
        items_per_page = getattr(site_config, 'user_profile_items_per_page', 5) # Fallback to 5


        # Paginate Posts
        posts_paginator = Paginator(user_posts, items_per_page)
        posts_page_number = request.GET.get('posts_page', 1)
        paginated_user_posts = posts_paginator.get_page(posts_page_number)

        # Paginate Comments
        comments_paginator = Paginator(user_comments, items_per_page)
        comments_page_number = request.GET.get('comments_page', 1)
        paginated_user_comments = comments_paginator.get_page(comments_page_number)

        context = {
            'user_obj': user_obj, # The User object
            'profile': profile,   # The associated Profile object
            'user_posts': paginated_user_posts,
            'user_comments': paginated_user_comments,
        }
        return render(request, 'accounts/public_profile_view.html', context)

    except User.DoesNotExist:
        logger.warning(f"Public profile requested for non-existent user: '{username}'.")
        raise
    except Exception as e:
        logger.error(f"Error accessing public profile for user '{username}': {e}", exc_info=True)
        raise # Re-raise for Django to handle 500 error page

def user_directory_view(request):
    """
    Displays a paginated list of all active users in the system.
    """
    # 1. Get all active users, ordered by username.
    # You might want to filter out staff/superusers if you don't want them listed.
    all_users = User.objects.filter(
        is_active=True,
        profile__is_listed_publicly=True
    ).order_by('username')
    
    # 2. Get pagination settings.
    try:
        site_config = SiteConfiguration.get_solo()
        items_per_page = getattr(site_config, 'user_directory_items_per_page', 25)
    except SiteConfiguration.DoesNotExist:
        items_per_page = 25
        logger.warning("SiteConfiguration not found. Using default user directory items per page (25).")

    # 3. Apply pagination.
    paginator = Paginator(all_users, items_per_page)
    page_number = request.GET.get('page')

    try:
        users_on_page = paginator.get_page(page_number)
    except PageNotAnInteger:
        users_on_page = paginator.get_page(1)
    except EmptyPage:
        if paginator.num_pages > 0:
            users_on_page = paginator.get_page(paginator.num_pages)
        else:
            users_on_page = []

    logger.info(f"User directory view accessed. Showing page {getattr(users_on_page, 'number', 0)} of {getattr(users_on_page, 'paginator.num_pages', 0)} users.")

    context = {
        'users': users_on_page, # Pass the paginated user objects
    }
    return render(request, 'accounts/user_directory.html', context)./accounts/forms.py
# --- ./accounts/forms.py ---
# File: accounts/forms.py
import logging
from django import forms
from django.contrib.auth.models import User
from django.contrib.auth.forms import UserCreationForm
from django.utils.translation import gettext_lazy as _
from widgets.widgets import CustomClearableFileInput
from .models import Profile

logger = logging.getLogger(__name__)


# --- 1. Custom SIGNUP Form (for new user registration) ---
class CustomUserCreationForm(UserCreationForm):
    """
    A custom form for new user registration. It only handles User model fields.
    """
    class Meta(UserCreationForm.Meta):
        model = User
        # The 'fields' tuple should only contain fields from the User model.
        # 'password1' and 'password2' are handled automatically by UserCreationForm.
        fields = ("username",)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['password2'].help_text = None
        self.fields['username'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Choose a username')})
        self.fields['password1'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Enter password')})
        self.fields['password2'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Confirm password')})
        self.fields['username'].label = _('Username')
        self.fields['password1'].label = _('Password')
        self.fields['password2'].label = _('Confirm Password')


# --- 2. Custom User UPDATE Form (for editing basic User data) ---
class UserUpdateForm(forms.ModelForm):
    """
    A form for updating basic, non-sensitive user information.
    """
    email = forms.EmailField(
        required=True, 
        widget=forms.EmailInput(attrs={'class': 'form-control'})
    )

    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'email']
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['first_name'].label = _('First Name')
        self.fields['last_name'].label = _('Last Name')
        self.fields['email'].label = _('Contact Email')
        self.fields['first_name'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Your first name')})
        self.fields['last_name'].widget.attrs.update({'class': 'form-control', 'placeholder': _('Your last name')})


# --- 3. Custom Profile UPDATE Form (for editing extended Profile data) ---
class ProfileUpdateForm(forms.ModelForm):
    """
    A form for updating the extended profile, using a custom widget for the avatar.
    """
    # We explicitly define the avatar field to force our custom widget.
    avatar = forms.ImageField(
        label=_("Profile Picture"),
        required=False,
        widget=CustomClearableFileInput() # Custom widget for file input
    )
    clear_avatar = forms.BooleanField(
        label=_("Use default avatar"),
        required=False,
        # Le damos una clase de Bootstrap para que se vea bien
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )
    class Meta:
        model = Profile
        fields = [
            'display_name', 
            'bio', 
            'location', 
            'website_url', 
            'avatar', 
            'default_avatar_choice',
            'is_listed_publicly'
        ]
        
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Apply Bootstrap classes to the rest of the fields.
        self.fields['display_name'].widget.attrs.update({'class': 'form-control'})
        self.fields['bio'].widget.attrs.update({'class': 'form-control', 'rows': 4})
        self.fields['location'].widget.attrs.update({'class': 'form-control'})
        self.fields['website_url'].widget.attrs.update({'class': 'form-control', 'placeholder': 'https://...'})
        self.fields['default_avatar_choice'].widget.attrs.update({'class': 'form-select'})

        logger.debug(f"ProfileUpdateForm initialized for instance: {self.instance}")
./accounts/migrations/0001_initial.py
# --- ./accounts/migrations/0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-19 15:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Profile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('display_name', models.CharField(blank=True, help_text='Your full name or a nickname, which will be shown publicly.', max_length=150, verbose_name='Display Name')),
                ('public_email', models.EmailField(blank=True, help_text="An email address you don't mind sharing publicly for contact.", max_length=254, verbose_name='Public Email')),
                ('website_url', models.URLField(blank=True, max_length=255, verbose_name='Website URL')),
                ('location', models.CharField(blank=True, max_length=100, verbose_name='Location')),
                ('bio', models.TextField(blank=True, verbose_name='Biography')),
                ('avatar', models.ImageField(default='images/avatars/default_private.png', upload_to='avatars/', verbose_name='Avatar')),
                ('default_avatar_choice', models.CharField(choices=[('images/avatars/default_private.png', "Don't specify"), ('images/avatars/default_female.png', 'Female'), ('images/avatars/default_male.png', 'Male'), ('images/avatars/default_nonbinary.png', 'Non-binary')], default='images/avatars/default_private.png', max_length=100, verbose_name='Default Avatar Preference')),
                ('is_trusted_commenter', models.BooleanField(default=False, help_text='If checked, comments are automatically approved.', verbose_name='Is a Trusted Commenter?')),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Profile',
                'verbose_name_plural': 'Profiles',
            },
        ),
    ]
./accounts/migrations/0002_profile_is_listed_publicly.py
# --- ./accounts/migrations/0002_profile_is_listed_publicly.py ---
# Generated by Django 5.2.3 on 2025-06-22 08:34

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='profile',
            name='is_listed_publicly',
            field=models.BooleanField(default=True, help_text='If checked, your profile will be visible in the public user directory.', verbose_name='List profile publicly?'),
        ),
    ]
./accounts/migrations/__init__.py
# --- ./accounts/migrations/__init__.py ---
./accounts/migrations/0003_alter_profile_is_listed_publicly.py
# --- ./accounts/migrations/0003_alter_profile_is_listed_publicly.py ---
# Generated by Django 5.2.3 on 2025-06-22 13:52

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0002_profile_is_listed_publicly'),
    ]

    operations = [
        migrations.AlterField(
            model_name='profile',
            name='is_listed_publicly',
            field=models.BooleanField(default=False, help_text='If checked, your profile will be visible in the public user directory.', verbose_name='List profile publicly?'),
        ),
    ]
./accounts/admin.py
# --- ./accounts/admin.py ---
# accounts/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Profile

# Define an inline admin descriptor for Profile model
# which acts a bit like a singleton
class ProfileInline(admin.StackedInline):
    model = Profile
    can_delete = False
    verbose_name_plural = 'profile'

# Define a new User admin
class UserAdmin(BaseUserAdmin):
    inlines = (ProfileInline,)

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)./accounts/urls.py
# --- ./accounts/urls.py ---
# accounts/urls.py
from django.urls import path
from . import views

app_name = 'accounts'

urlpatterns = [
    path('signup/', views.signup_view, name='signup'),
    path('profile/edit/', views.profile_edit_view, name='profile_edit'),
    path('profile/<str:username>/', views.user_profile_public_view, name='public_profile'),
    path('directory/', views.user_directory_view, name='user_directory'),
]./accounts/apps.py
# --- ./accounts/apps.py ---
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'
./accounts/models.py
# --- ./accounts/models.py ---
# accounts/models.py
from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils.translation import gettext_lazy as _
from django.templatetags.static import static 

class Profile(models.Model):
    """
    Extends Django's base User model to include additional user information,
    such as a display name, avatar, and bio.
    """
    
    # --- Avatar Choices Enumeration ---
    # This provides a user-friendly way to select a default avatar.
    class AvatarChoice(models.TextChoices):
        PRIVATE = 'images/avatars/default_private.png', _("Don't specify")
        FEMALE = 'images/avatars/default_female.png', _('Female')
        MALE = 'images/avatars/default_male.png', _('Male')
        NONBINARY = 'images/avatars/default_nonbinary.png', _('Non-binary')

    # --- Core Relationship ---
    # A One-to-One link to Django's built-in User model.
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")

    # --- Identity & Contact Fields ---
    display_name = models.CharField(
        max_length=150, 
        blank=True, 
        verbose_name=_("Display Name"),
        help_text=_("Your full name or a nickname, which will be shown publicly.")
    )
    public_email = models.EmailField(
        blank=True, 
        verbose_name=_("Public Email"),
        help_text=_("An email address you don't mind sharing publicly for contact.")
    )
    website_url = models.URLField(
        max_length=255, 
        blank=True, 
        verbose_name=_("Website URL")
    )

    # --- Profile Information Fields ---
    location = models.CharField(
        max_length=100, 
        blank=True, 
        verbose_name=_("Location")
    )
    bio = models.TextField(
        blank=True, 
        verbose_name=_("Biography")
    )
    
    # --- Avatar Fields ---
    avatar = models.ImageField(
        upload_to='avatars/', 
        default='images/avatars/default_private.png', 
        verbose_name=_("Avatar")
    )
    default_avatar_choice = models.CharField(
        max_length=100,
        choices=AvatarChoice.choices,
        default=AvatarChoice.PRIVATE,
        verbose_name=_("Default Avatar Preference")
    )
    is_trusted_commenter = models.BooleanField(
        default=False,
        verbose_name=_("Is a Trusted Commenter?"),
        help_text=_("If checked, comments are automatically approved.")
    )
    is_listed_publicly = models.BooleanField(
        default=False, # consider False for new registrations.
                       # We will make this configurable in the signup process.
        verbose_name=_("List profile publicly?"),
        help_text=_("If checked, your profile will be visible in the public user directory.")
    )

    class Meta:
        verbose_name = _("Profile")
        verbose_name_plural = _("Profiles")

    # accounts/models.py
    def get_avatar_url(self):
        # Si el usuario ha subido un archivo, su nombre NO será una de las rutas por defecto.
        default_paths = [c[0] for c in self.AvatarChoice.choices]
        if self.avatar and self.avatar.name not in default_paths:
            return self.avatar.url

        # Si no, mostramos el avatar por defecto que el usuario haya elegido.
        return static(self.default_avatar_choice)
        
    def __str__(self):
        return f"{self.user.username}'s Profile"

    def get_display_name(self):
        """
        Returns the user's preferred display name, with fallbacks.
        Order of preference: Profile's display_name -> User's full_name -> User's username.
        """
        return self.display_name or self.user.get_full_name() or self.user.username


# --- Django Signal to Automate Profile Creation ---
@receiver(post_save, sender=User)
def create_or_update_user_profile(sender, instance, created, **kwargs):
    """
    Signal to automatically create a Profile when a new User is created.
    """
    if created:
        # Simply create the profile. Django will handle the default avatar.
        Profile.objects.create(user=instance)

    # This part ensures that if you save a User, its related Profile
    # is also saved, which can be useful for other signals.
    if hasattr(instance, 'profile'):
        instance.profile.save()./accounts/tests.py
# --- ./accounts/tests.py ---
from django.test import TestCase

# Create your tests here.
./accounts/__init__.py
# --- ./accounts/__init__.py ---
